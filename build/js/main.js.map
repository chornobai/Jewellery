{"version":3,"names":[],"mappings":"","sources":["main.js"],"sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./source/js/main.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./source/js/filter.js\":\n/*!*****************************!*\\\n  !*** ./source/js/filter.js ***!\n  \\*****************************/\n/*! exports provided: initFilter */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"initFilter\\\", function() { return initFilter; });\\nfunction initFilter() {\\n  var filterOpen = document.querySelector('.filter-open');\\n  var filterClose = document.querySelector('.filter-close');\\n  var filterBlock = document.querySelector('.filter');\\n  var filterTriggers = filterBlock.querySelectorAll('.filter-fieldset');\\n  filterBlock.classList.remove('filter--nojs'); // --- Открыть фильтр\\n\\n  filterOpen.addEventListener('click', function (evt) {\\n    evt.preventDefault();\\n    filterBlock.classList.add('filter--active');\\n  }); // --- Закрыть фильтр\\n\\n  filterClose.addEventListener('click', function (evt) {\\n    evt.preventDefault();\\n    filterBlock.classList.remove('filter--active');\\n  }); // --- Accordion\\n\\n  filterTriggers.forEach(function (item) {\\n    item.addEventListener('click', function (evt) {\\n      evt.preventDefault();\\n      item.classList.toggle('filter-fieldset--active');\\n      item.blur();\\n    });\\n  });\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./source/js/filter.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/login.js\":\n/*!****************************!*\\\n  !*** ./source/js/login.js ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"var LOGIN_OVERLAY = 'login-wrapper--overlay';\\nvar loginLinks = document.querySelectorAll('.login-link');\\nvar loginBlock = document.querySelector('.login-wrapper');\\nvar loginClose = loginBlock.querySelector('.login-top-button');\\nvar loginMail = loginBlock.querySelector('#email-login');\\nvar loginForm = loginBlock.querySelector('form'); // Проверка - поддерживает ли браузер запись в LocalStorage //\\n\\nvar isStorageSupport = true;\\nvar storage = '';\\n\\ntry {\\n  storage = localStorage.getItem('email');\\n} catch (err) {\\n  isStorageSupport = false;\\n} // Открытие модального окна и фокус в поле Email ---\\n\\n\\nloginLinks.forEach(function (link) {\\n  link.addEventListener('click', function (evt) {\\n    evt.preventDefault();\\n    loginBlock.classList.add(LOGIN_OVERLAY);\\n    loginMail.focus();\\n\\n    if (storage) {\\n      loginMail.focus();\\n    }\\n  });\\n}); // Запись в LocalStorage ---\\n\\nloginForm.addEventListener('submit', function (evt) {\\n  if (!loginMail.value) {\\n    evt.preventDefault();\\n  }\\n\\n  if (isStorageSupport) {\\n    localStorage.setItem('email', loginMail.value);\\n  }\\n}); // Закрытие модального окна ---\\n// Кнопка\\n\\nloginClose.addEventListener('click', function (evt) {\\n  evt.preventDefault();\\n  loginBlock.classList.remove(LOGIN_OVERLAY);\\n}); // Esc\\n\\ndocument.addEventListener('keydown', function (evt) {\\n  if (evt.key === 'Escape' || evt.key === 'Esc') {\\n    loginBlock.classList.remove(LOGIN_OVERLAY);\\n  }\\n}); // Overlay\\n\\ndocument.addEventListener('click', function (evt) {\\n  if (evt.target === loginBlock) {\\n    loginBlock.classList.remove(LOGIN_OVERLAY);\\n  }\\n}); // ---\\n// --- Зацикленный фокус ---\\n// add all the elements inside modal which you want to make focusable\\n\\nvar focusableElements = 'button, [href], input,  [tabindex]:not([tabindex=\\\"-1\\\"])';\\nvar modal = document.querySelector('.login-wrapper'); // select the modal by it's id\\n\\nvar firstFocusableElement = modal.querySelectorAll(focusableElements)[0]; // get first element to be focused inside modal\\n\\nvar focusableContent = modal.querySelectorAll(focusableElements);\\nvar lastFocusableElement = focusableContent[focusableContent.length - 1]; // get last element to be focused inside modal\\n\\ndocument.addEventListener('keydown', function (e) {\\n  var isTabPressed = e.key === 'Tab' || e.keyCode === 9;\\n\\n  if (!isTabPressed) {\\n    return;\\n  }\\n\\n  if (e.shiftKey) {\\n    // if shift key pressed for shift + tab combination\\n    if (document.activeElement === firstFocusableElement) {\\n      lastFocusableElement.focus(); // add focus for the last focusable element\\n\\n      e.preventDefault();\\n    }\\n  } else {\\n    // if tab key is pressed\\n    if (document.activeElement === lastFocusableElement) {\\n      // if focused has reached to last focusable element then focus first focusable element after pressing tab\\n      firstFocusableElement.focus(); // add focus for the first focusable element\\n\\n      e.preventDefault();\\n    }\\n  }\\n});\\nfirstFocusableElement.focus();\\n\\n//# sourceURL=webpack:///./source/js/login.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/main.js\":\n/*!***************************!*\\\n  !*** ./source/js/main.js ***!\n  \\***************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _menu_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./menu.js */ \\\"./source/js/menu.js\\\");\\n/* harmony import */ var _menu_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_menu_js__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var _login_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./login.js */ \\\"./source/js/login.js\\\");\\n/* harmony import */ var _login_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_login_js__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var _slider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slider.js */ \\\"./source/js/slider.js\\\");\\n/* harmony import */ var _filter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filter.js */ \\\"./source/js/filter.js\\\");\\n/* harmony import */ var _question_accordion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./question-accordion */ \\\"./source/js/question-accordion.js\\\");\\n\\n\\n\\n\\n // Проверка активной страницы ---\\n\\nvar CATALOG_PAGE = document.querySelector('.main-catalog');\\n\\nif (CATALOG_PAGE) {\\n  Object(_filter_js__WEBPACK_IMPORTED_MODULE_3__[\\\"initFilter\\\"])();\\n} else {\\n  Object(_question_accordion__WEBPACK_IMPORTED_MODULE_4__[\\\"initMainAccordion\\\"])();\\n  Object(_slider_js__WEBPACK_IMPORTED_MODULE_2__[\\\"initSwiper\\\"])();\\n  window.addEventListener('resize', function (evt) {\\n    evt.preventDefault();\\n    Object(_slider_js__WEBPACK_IMPORTED_MODULE_2__[\\\"initSwiper\\\"])().update();\\n  });\\n}\\n\\n//# sourceURL=webpack:///./source/js/main.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/menu.js\":\n/*!***************************!*\\\n  !*** ./source/js/menu.js ***!\n  \\***************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\neval(\"var menuButton = document.querySelector('.header-top__button');\\nvar menu = document.querySelector('.header');\\nvar menuLinks = document.querySelectorAll('.navigation-link');\\nmenu.classList.remove('header-nojs');\\nmenuButton.addEventListener('click', function (evt) {\\n  evt.preventDefault();\\n  menu.classList.toggle('header-open-menu');\\n});\\nmenuLinks.forEach(function (item) {\\n  item.addEventListener('click', function (evt) {\\n    evt.preventDefault();\\n    menu.classList.remove('header-open-menu');\\n    var blockId = item.getAttribute('href');\\n    document.querySelector(\\\"\\\".concat(blockId)).scrollIntoView({\\n      behavior: 'smooth',\\n      block: 'start'\\n    });\\n  });\\n});\\n\\n//# sourceURL=webpack:///./source/js/menu.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/question-accordion.js\":\n/*!*****************************************!*\\\n  !*** ./source/js/question-accordion.js ***!\n  \\*****************************************/\n/*! exports provided: initMainAccordion */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"initMainAccordion\\\", function() { return initMainAccordion; });\\nfunction initMainAccordion() {\\n  var questionBlock = document.querySelector('.questions');\\n  var questionTriggers = questionBlock.querySelectorAll('.questions-item');\\n  questionBlock.classList.remove('questions--nojs'); // Accordion for questions\\n\\n  questionTriggers.forEach(function (item) {\\n    item.addEventListener('click', function (evt) {\\n      evt.preventDefault();\\n      item.classList.toggle('questions-item--active');\\n      item.blur();\\n    });\\n  });\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./source/js/question-accordion.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/slider.js\":\n/*!*****************************!*\\\n  !*** ./source/js/slider.js ***!\n  \\*****************************/\n/*! exports provided: initSwiper */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"initSwiper\\\", function() { return initSwiper; });\\n/* harmony import */ var _vendor_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/swiper-bundle.js */ \\\"./source/js/vendor/swiper-bundle.js\\\");\\n/* harmony import */ var _vendor_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\nfunction initSwiper() {\\n  var slider = new _vendor_swiper_bundle_js__WEBPACK_IMPORTED_MODULE_0___default.a('.slider-row', {\\n    direction: 'horizontal',\\n    spaceBetween: 15,\\n    keyboardControl: true,\\n    updateOnWindowResize: true,\\n    touchRatio: 0,\\n    simulateTouch: false,\\n    observer: true,\\n    observeParents: true,\\n    observeSliderChildren: true,\\n    watchSlidesProgress: true,\\n    preloadImages: true,\\n    keyboard: {\\n      enabled: true\\n    },\\n    navigation: {\\n      nextEl: '.swiper-button-next',\\n      prevEl: '.swiper-button-prev'\\n    },\\n    breakpoints: {\\n      320: {\\n        slidesPerView: 2,\\n        slidesPerGroup: 2,\\n        pagination: {\\n          el: '.swiper-pagination',\\n          clickable: true,\\n          type: 'fraction',\\n          renderFraction: function renderFraction(currentClass, totalClass) {\\n            return \\\" <span class=\\\\\\\"\\\".concat(currentClass, \\\"\\\\\\\"></span>  of  <span class=\\\\\\\"\\\").concat(totalClass, \\\"\\\\\\\"></span>\\\");\\n          }\\n        },\\n        touchRatio: 1,\\n        simulateTouch: true\\n      },\\n      768: {\\n        slidesPerView: 2,\\n        slidesPerGroup: 2,\\n        touchRatio: 1,\\n        simulateTouch: true,\\n        spaceBetween: 20,\\n        pagination: {\\n          el: '.swiper-pagination',\\n          clickable: true,\\n          type: 'bullets',\\n          renderBullet: function renderBullet(index, className) {\\n            return \\\"<span class=\\\\\\\"\\\".concat(className, \\\"\\\\\\\">\\\").concat(index + 1, \\\"</span>\\\");\\n          }\\n        }\\n      },\\n      1024: {\\n        slidesPerView: 4,\\n        slidesPerGroup: 4,\\n        touchRatio: 0,\\n        simulateTouch: false,\\n        pagination: {\\n          el: '.swiper-pagination',\\n          clickable: true,\\n          type: 'bullets',\\n          renderBullet: function renderBullet(index, className) {\\n            return \\\"<span class=\\\\\\\"\\\".concat(className, \\\"\\\\\\\">\\\").concat(index + 1, \\\"</span>\\\");\\n          }\\n        },\\n        watchOverflow: true\\n      }\\n    },\\n    a11y: {\\n      enabled: true,\\n      prevSlideMessage: 'Previous slide',\\n      nextSlideMessage: 'Next slide'\\n    }\\n  });\\n  var buttons = document.querySelectorAll('.slider-button');\\n  buttons.forEach(function (item) {\\n    item.setAttribute('tabindex', '0');\\n    item.removeAttribute('aria-disabled');\\n    item.removeAttribute('disabled');\\n    item.classList.remove('swiper-button-disabled');\\n    item.addEventListener('click', function (evt) {\\n      evt.preventDefault();\\n      item.setAttribute('tabindex', '0');\\n      item.removeAttribute('aria-disabled');\\n      item.removeAttribute('disabled');\\n      item.classList.remove('swiper-button-disabled');\\n    });\\n  });\\n  return slider;\\n}\\n\\n\\n\\n//# sourceURL=webpack:///./source/js/slider.js?\");\n\n/***/ }),\n\n/***/ \"./source/js/vendor/swiper-bundle.js\":\n/*!*******************************************!*\\\n  !*** ./source/js/vendor/swiper-bundle.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\neval(\"var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\\n\\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\\n\\nfunction _nonIterableSpread() { throw new TypeError(\\\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\"); }\\n\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name; if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(o); if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\n\\nfunction _iterableToArray(iter) { if (typeof Symbol !== \\\"undefined\\\" && iter[Symbol.iterator] != null || iter[\\\"@@iterator\\\"] != null) return Array.from(iter); }\\n\\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\\n\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\\n\\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\\n\\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \\\"prototype\\\", { writable: false }); return Constructor; }\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } Object.defineProperty(subClass, \\\"prototype\\\", { value: Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }), writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\\n\\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\\n\\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \\\"object\\\" || typeof call === \\\"function\\\")) { return call; } else if (call !== void 0) { throw new TypeError(\\\"Derived constructors may only return object or undefined\\\"); } return _assertThisInitialized(self); }\\n\\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return self; }\\n\\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \\\"function\\\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \\\"function\\\") { throw new TypeError(\\\"Super expression must either be null or a function\\\"); } if (typeof _cache !== \\\"undefined\\\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\\n\\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\\n\\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \\\"undefined\\\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \\\"function\\\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\\n\\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\\\"[native code]\\\") !== -1; }\\n\\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\\n\\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\\n\\nfunction _typeof(obj) { \\\"@babel/helpers - typeof\\\"; return _typeof = \\\"function\\\" == typeof Symbol && \\\"symbol\\\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \\\"function\\\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }, _typeof(obj); }\\n\\n/* eslint-disable no-compare-neg-zero */\\n\\n/* eslint-disable no-empty */\\n\\n/* eslint-disable no-useless-concat */\\n\\n/* eslint-disable no-shadow */\\n\\n/* eslint-disable no-nested-ternary */\\n\\n/* eslint-disable no-undef */\\n\\n/**\\n * Swiper 7.3.3\\n * Most modern mobile touch slider and framework with hardware accelerated transitions\\n * https://swiperjs.com\\n *\\n * Copyright 2014-2021 Vladimir Kharlampidi\\n *\\n * Released under the MIT License\\n *\\n * Released on: December 16, 2021\\n */\\n(function (global, factory) {\\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\\n\\t\\t\\t\\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_FACTORY__),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);\\n})(this, function () {\\n  /**\\n   * SSR Window 4.0.2\\n   * Better handling for window object in SSR environment\\n   * https://github.com/nolimits4web/ssr-window\\n   *\\n   * Copyright 2021, Vladimir Kharlampidi\\n   *\\n   * Licensed under MIT\\n   *\\n   * Released on: December 13, 2021\\n   */\\n\\n  /* eslint-disable no-param-reassign */\\n  function isObject$1(obj) {\\n    return obj !== null && _typeof(obj) === 'object' && 'constructor' in obj && obj.constructor === Object;\\n  }\\n\\n  function extend$1() {\\n    var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n    var src = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n    Object.keys(src).forEach(function (key) {\\n      if (typeof target[key] === 'undefined') {\\n        target[key] = src[key];\\n      } else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\\n        extend$1(target[key], src[key]);\\n      }\\n    });\\n  }\\n\\n  var ssrDocument = {\\n    body: {},\\n    addEventListener: function addEventListener() {},\\n    removeEventListener: function removeEventListener() {},\\n    activeElement: {\\n      blur: function blur() {},\\n      nodeName: ''\\n    },\\n    querySelector: function querySelector() {\\n      return null;\\n    },\\n    querySelectorAll: function querySelectorAll() {\\n      return [];\\n    },\\n    getElementById: function getElementById() {\\n      return null;\\n    },\\n    createEvent: function createEvent() {\\n      return {\\n        initEvent: function initEvent() {}\\n      };\\n    },\\n    createElement: function createElement() {\\n      return {\\n        children: [],\\n        childNodes: [],\\n        style: {},\\n        setAttribute: function setAttribute() {},\\n        getElementsByTagName: function getElementsByTagName() {\\n          return [];\\n        }\\n      };\\n    },\\n    createElementNS: function createElementNS() {\\n      return {};\\n    },\\n    importNode: function importNode() {\\n      return null;\\n    },\\n    location: {\\n      hash: '',\\n      host: '',\\n      hostname: '',\\n      href: '',\\n      origin: '',\\n      pathname: '',\\n      protocol: '',\\n      search: ''\\n    }\\n  };\\n\\n  function getDocument() {\\n    var doc = typeof document !== 'undefined' ? document : {};\\n    extend$1(doc, ssrDocument);\\n    return doc;\\n  }\\n\\n  var ssrWindow = {\\n    document: ssrDocument,\\n    navigator: {\\n      userAgent: ''\\n    },\\n    location: {\\n      hash: '',\\n      host: '',\\n      hostname: '',\\n      href: '',\\n      origin: '',\\n      pathname: '',\\n      protocol: '',\\n      search: ''\\n    },\\n    history: {\\n      replaceState: function replaceState() {},\\n      pushState: function pushState() {},\\n      go: function go() {},\\n      back: function back() {}\\n    },\\n    CustomEvent: function CustomEvent() {\\n      return this;\\n    },\\n    addEventListener: function addEventListener() {},\\n    removeEventListener: function removeEventListener() {},\\n    getComputedStyle: function getComputedStyle() {\\n      return {\\n        getPropertyValue: function getPropertyValue() {\\n          return '';\\n        }\\n      };\\n    },\\n    Image: function Image() {},\\n    Date: function Date() {},\\n    screen: {},\\n    setTimeout: function setTimeout() {},\\n    clearTimeout: function clearTimeout() {},\\n    matchMedia: function matchMedia() {\\n      return {};\\n    },\\n    requestAnimationFrame: function requestAnimationFrame(callback) {\\n      if (typeof setTimeout === 'undefined') {\\n        callback();\\n        return null;\\n      }\\n\\n      return setTimeout(callback, 0);\\n    },\\n    cancelAnimationFrame: function cancelAnimationFrame(id) {\\n      if (typeof setTimeout === 'undefined') {\\n        return;\\n      }\\n\\n      clearTimeout(id);\\n    }\\n  };\\n\\n  function getWindow() {\\n    var win = typeof window !== 'undefined' ? window : {};\\n    extend$1(win, ssrWindow);\\n    return win;\\n  }\\n  /**\\n   * Dom7 4.0.2\\n   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API\\n   * https://framework7.io/docs/dom7.html\\n   *\\n   * Copyright 2021, Vladimir Kharlampidi\\n   *\\n   * Licensed under MIT\\n   *\\n   * Released on: December 13, 2021\\n   */\\n\\n  /* eslint-disable no-proto */\\n\\n\\n  function makeReactive(obj) {\\n    var proto = obj.__proto__;\\n    Object.defineProperty(obj, '__proto__', {\\n      get: function get() {\\n        return proto;\\n      },\\n      set: function set(value) {\\n        proto.__proto__ = value;\\n      }\\n    });\\n  }\\n\\n  var Dom7 = /*#__PURE__*/function (_Array) {\\n    _inherits(Dom7, _Array);\\n\\n    var _super = _createSuper(Dom7);\\n\\n    function Dom7(items) {\\n      var _this;\\n\\n      _classCallCheck(this, Dom7);\\n\\n      _this = _super.call.apply(_super, [this].concat(_toConsumableArray(items || [])));\\n      makeReactive(_assertThisInitialized(_this));\\n      return _this;\\n    }\\n\\n    return _createClass(Dom7);\\n  }( /*#__PURE__*/_wrapNativeSuper(Array));\\n\\n  function arrayFlat() {\\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n    var res = [];\\n    arr.forEach(function (el) {\\n      if (Array.isArray(el)) {\\n        res.push.apply(res, _toConsumableArray(arrayFlat(el)));\\n      } else {\\n        res.push(el);\\n      }\\n    });\\n    return res;\\n  }\\n\\n  function arrayFilter(arr, callback) {\\n    return Array.prototype.filter.call(arr, callback);\\n  }\\n\\n  function arrayUnique(arr) {\\n    var uniqueArray = [];\\n\\n    for (var i = 0; i < arr.length; i += 1) {\\n      if (uniqueArray.indexOf(arr[i]) === -1) {\\n        uniqueArray.push(arr[i]);\\n      }\\n    }\\n\\n    return uniqueArray;\\n  }\\n\\n  function qsa(selector, context) {\\n    if (typeof selector !== 'string') {\\n      return [selector];\\n    }\\n\\n    var a = [];\\n    var res = context.querySelectorAll(selector);\\n\\n    for (var i = 0; i < res.length; i += 1) {\\n      a.push(res[i]);\\n    }\\n\\n    return a;\\n  }\\n\\n  function $(selector, context) {\\n    var window = getWindow();\\n    var document = getDocument();\\n    var arr = [];\\n\\n    if (!context && selector instanceof Dom7) {\\n      return selector;\\n    }\\n\\n    if (!selector) {\\n      return new Dom7(arr);\\n    }\\n\\n    if (typeof selector === 'string') {\\n      var _html = selector.trim();\\n\\n      if (_html.indexOf('<') >= 0 && _html.indexOf('>') >= 0) {\\n        var toCreate = 'div';\\n\\n        if (_html.indexOf('<li') === 0) {\\n          toCreate = 'ul';\\n        }\\n\\n        if (_html.indexOf('<tr') === 0) {\\n          toCreate = 'tbody';\\n        }\\n\\n        if (_html.indexOf('<td') === 0 || _html.indexOf('<th') === 0) {\\n          toCreate = 'tr';\\n        }\\n\\n        if (_html.indexOf('<tbody') === 0) {\\n          toCreate = 'table';\\n        }\\n\\n        if (_html.indexOf('<option') === 0) {\\n          toCreate = 'select';\\n        }\\n\\n        var tempParent = document.createElement(toCreate);\\n        tempParent.innerHTML = _html;\\n\\n        for (var i = 0; i < tempParent.childNodes.length; i += 1) {\\n          arr.push(tempParent.childNodes[i]);\\n        }\\n      } else {\\n        arr = qsa(selector.trim(), context || document);\\n      } // arr = qsa(selector, document);\\n\\n    } else if (selector.nodeType || selector === window || selector === document) {\\n      arr.push(selector);\\n    } else if (Array.isArray(selector)) {\\n      if (selector instanceof Dom7) {\\n        return selector;\\n      }\\n\\n      arr = selector;\\n    }\\n\\n    return new Dom7(arrayUnique(arr));\\n  }\\n\\n  $.fn = Dom7.prototype; // eslint-disable-next-line\\n\\n  function addClass() {\\n    for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {\\n      classes[_key] = arguments[_key];\\n    }\\n\\n    var classNames = arrayFlat(classes.map(function (c) {\\n      return c.split(' ');\\n    }));\\n    this.forEach(function (el) {\\n      var _el$classList;\\n\\n      (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classNames));\\n    });\\n    return this;\\n  }\\n\\n  function removeClass() {\\n    for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\\n      classes[_key2] = arguments[_key2];\\n    }\\n\\n    var classNames = arrayFlat(classes.map(function (c) {\\n      return c.split(' ');\\n    }));\\n    this.forEach(function (el) {\\n      var _el$classList2;\\n\\n      (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classNames));\\n    });\\n    return this;\\n  }\\n\\n  function toggleClass() {\\n    for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n      classes[_key3] = arguments[_key3];\\n    }\\n\\n    var classNames = arrayFlat(classes.map(function (c) {\\n      return c.split(' ');\\n    }));\\n    this.forEach(function (el) {\\n      classNames.forEach(function (className) {\\n        el.classList.toggle(className);\\n      });\\n    });\\n  }\\n\\n  function hasClass() {\\n    for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\\n      classes[_key4] = arguments[_key4];\\n    }\\n\\n    var classNames = arrayFlat(classes.map(function (c) {\\n      return c.split(' ');\\n    }));\\n    return arrayFilter(this, function (el) {\\n      return classNames.filter(function (className) {\\n        return el.classList.contains(className);\\n      }).length > 0;\\n    }).length > 0;\\n  }\\n\\n  function attr(attrs, value) {\\n    if (arguments.length === 1 && typeof attrs === 'string') {\\n      // Get attr\\n      if (this[0]) {\\n        return this[0].getAttribute(attrs);\\n      }\\n\\n      return undefined;\\n    } // Set attrs\\n\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (arguments.length === 2) {\\n        // String\\n        this[i].setAttribute(attrs, value);\\n      } else {\\n        // Object\\n        for (var attrName in attrs) {\\n          this[i][attrName] = attrs[attrName];\\n          this[i].setAttribute(attrName, attrs[attrName]);\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function removeAttr(attr) {\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].removeAttribute(attr);\\n    }\\n\\n    return this;\\n  }\\n\\n  function transform(transform) {\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].style.transform = transform;\\n    }\\n\\n    return this;\\n  }\\n\\n  function transition$1(duration) {\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].style.transitionDuration = typeof duration !== 'string' ? \\\"\\\".concat(duration, \\\"ms\\\") : duration;\\n    }\\n\\n    return this;\\n  }\\n\\n  function on() {\\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\\n      args[_key5] = arguments[_key5];\\n    }\\n\\n    var eventType = args[0],\\n        targetSelector = args[1],\\n        listener = args[2],\\n        capture = args[3];\\n\\n    if (typeof args[1] === 'function') {\\n      eventType = args[0];\\n      listener = args[1];\\n      capture = args[2];\\n      targetSelector = undefined;\\n    }\\n\\n    if (!capture) {\\n      capture = false;\\n    }\\n\\n    function handleLiveEvent(e) {\\n      var target = e.target;\\n\\n      if (!target) {\\n        return;\\n      }\\n\\n      var eventData = e.target.dom7EventData || [];\\n\\n      if (eventData.indexOf(e) < 0) {\\n        eventData.unshift(e);\\n      }\\n\\n      if ($(target).is(targetSelector)) {\\n        listener.apply(target, eventData);\\n      } else {\\n        var _parents = $(target).parents(); // eslint-disable-line\\n\\n\\n        for (var k = 0; k < _parents.length; k += 1) {\\n          if ($(_parents[k]).is(targetSelector)) {\\n            listener.apply(_parents[k], eventData);\\n          }\\n        }\\n      }\\n    }\\n\\n    function handleEvent(e) {\\n      var eventData = e && e.target ? e.target.dom7EventData || [] : [];\\n\\n      if (eventData.indexOf(e) < 0) {\\n        eventData.unshift(e);\\n      }\\n\\n      listener.apply(this, eventData);\\n    }\\n\\n    var events = eventType.split(' ');\\n    var j;\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      var el = this[i];\\n\\n      if (!targetSelector) {\\n        for (j = 0; j < events.length; j += 1) {\\n          var _event = events[j];\\n\\n          if (!el.dom7Listeners) {\\n            el.dom7Listeners = {};\\n          }\\n\\n          if (!el.dom7Listeners[_event]) {\\n            el.dom7Listeners[_event] = [];\\n          }\\n\\n          el.dom7Listeners[_event].push({\\n            listener: listener,\\n            proxyListener: handleEvent\\n          });\\n\\n          el.addEventListener(_event, handleEvent, capture);\\n        }\\n      } else {\\n        // Live events\\n        for (j = 0; j < events.length; j += 1) {\\n          var _event2 = events[j];\\n\\n          if (!el.dom7LiveListeners) {\\n            el.dom7LiveListeners = {};\\n          }\\n\\n          if (!el.dom7LiveListeners[_event2]) {\\n            el.dom7LiveListeners[_event2] = [];\\n          }\\n\\n          el.dom7LiveListeners[_event2].push({\\n            listener: listener,\\n            proxyListener: handleLiveEvent\\n          });\\n\\n          el.addEventListener(_event2, handleLiveEvent, capture);\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function off() {\\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\\n      args[_key6] = arguments[_key6];\\n    }\\n\\n    var eventType = args[0],\\n        targetSelector = args[1],\\n        listener = args[2],\\n        capture = args[3];\\n\\n    if (typeof args[1] === 'function') {\\n      eventType = args[0];\\n      listener = args[1];\\n      capture = args[2];\\n      targetSelector = undefined;\\n    }\\n\\n    if (!capture) {\\n      capture = false;\\n    }\\n\\n    var events = eventType.split(' ');\\n\\n    for (var i = 0; i < events.length; i += 1) {\\n      var _event3 = events[i];\\n\\n      for (var j = 0; j < this.length; j += 1) {\\n        var el = this[j];\\n        var handlers = void 0;\\n\\n        if (!targetSelector && el.dom7Listeners) {\\n          handlers = el.dom7Listeners[_event3];\\n        } else if (targetSelector && el.dom7LiveListeners) {\\n          handlers = el.dom7LiveListeners[_event3];\\n        }\\n\\n        if (handlers && handlers.length) {\\n          for (var k = handlers.length - 1; k >= 0; k -= 1) {\\n            var handler = handlers[k];\\n\\n            if (listener && handler.listener === listener) {\\n              el.removeEventListener(_event3, handler.proxyListener, capture);\\n              handlers.splice(k, 1);\\n            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {\\n              el.removeEventListener(_event3, handler.proxyListener, capture);\\n              handlers.splice(k, 1);\\n            } else if (!listener) {\\n              el.removeEventListener(_event3, handler.proxyListener, capture);\\n              handlers.splice(k, 1);\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function trigger() {\\n    var window = getWindow();\\n\\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\\n      args[_key7] = arguments[_key7];\\n    }\\n\\n    var events = args[0].split(' ');\\n    var eventData = args[1];\\n\\n    for (var i = 0; i < events.length; i += 1) {\\n      var _event4 = events[i];\\n\\n      for (var j = 0; j < this.length; j += 1) {\\n        var el = this[j];\\n\\n        if (window.CustomEvent) {\\n          var evt = new window.CustomEvent(_event4, {\\n            detail: eventData,\\n            bubbles: true,\\n            cancelable: true\\n          });\\n          el.dom7EventData = args.filter(function (data, dataIndex) {\\n            return dataIndex > 0;\\n          });\\n          el.dispatchEvent(evt);\\n          el.dom7EventData = [];\\n          delete el.dom7EventData;\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function transitionEnd$1(callback) {\\n    var dom = this;\\n\\n    function fireCallBack(e) {\\n      if (e.target !== this) {\\n        return;\\n      }\\n\\n      callback.call(this, e);\\n      dom.off('transitionend', fireCallBack);\\n    }\\n\\n    if (callback) {\\n      dom.on('transitionend', fireCallBack);\\n    }\\n\\n    return this;\\n  }\\n\\n  function outerWidth(includeMargins) {\\n    if (this.length > 0) {\\n      if (includeMargins) {\\n        var _styles = this.styles();\\n\\n        return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));\\n      }\\n\\n      return this[0].offsetWidth;\\n    }\\n\\n    return null;\\n  }\\n\\n  function outerHeight(includeMargins) {\\n    if (this.length > 0) {\\n      if (includeMargins) {\\n        var _styles2 = this.styles();\\n\\n        return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));\\n      }\\n\\n      return this[0].offsetHeight;\\n    }\\n\\n    return null;\\n  }\\n\\n  function offset() {\\n    if (this.length > 0) {\\n      var _window = getWindow();\\n\\n      var _document = getDocument();\\n\\n      var el = this[0];\\n      var box = el.getBoundingClientRect();\\n      var body = _document.body;\\n      var clientTop = el.clientTop || body.clientTop || 0;\\n      var clientLeft = el.clientLeft || body.clientLeft || 0;\\n      var scrollTop = el === _window ? _window.scrollY : el.scrollTop;\\n      var scrollLeft = el === _window ? _window.scrollX : el.scrollLeft;\\n      return {\\n        top: box.top + scrollTop - clientTop,\\n        left: box.left + scrollLeft - clientLeft\\n      };\\n    }\\n\\n    return null;\\n  }\\n\\n  function styles() {\\n    var window = getWindow();\\n\\n    if (this[0]) {\\n      return window.getComputedStyle(this[0], null);\\n    }\\n\\n    return {};\\n  }\\n\\n  function css(props, value) {\\n    var window = getWindow();\\n    var i;\\n\\n    if (arguments.length === 1) {\\n      if (typeof props === 'string') {\\n        // .css('width')\\n        if (this[0]) {\\n          return window.getComputedStyle(this[0], null).getPropertyValue(props);\\n        }\\n      } else {\\n        // .css({ width: '100px' })\\n        for (i = 0; i < this.length; i += 1) {\\n          for (var prop in props) {\\n            this[i].style[prop] = props[prop];\\n          }\\n        }\\n\\n        return this;\\n      }\\n    }\\n\\n    if (arguments.length === 2 && typeof props === 'string') {\\n      // .css('width', '100px')\\n      for (i = 0; i < this.length; i += 1) {\\n        this[i].style[props] = value;\\n      }\\n\\n      return this;\\n    }\\n\\n    return this;\\n  }\\n\\n  function each(callback) {\\n    if (!callback) {\\n      return this;\\n    }\\n\\n    this.forEach(function (el, index) {\\n      callback.apply(el, [el, index]);\\n    });\\n    return this;\\n  }\\n\\n  function filter(callback) {\\n    var result = arrayFilter(this, callback);\\n    return $(result);\\n  }\\n\\n  function html(html) {\\n    if (typeof html === 'undefined') {\\n      return this[0] ? this[0].innerHTML : null;\\n    }\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].innerHTML = html;\\n    }\\n\\n    return this;\\n  }\\n\\n  function text(text) {\\n    if (typeof text === 'undefined') {\\n      return this[0] ? this[0].textContent.trim() : null;\\n    }\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      this[i].textContent = text;\\n    }\\n\\n    return this;\\n  }\\n\\n  function is(selector) {\\n    var window = getWindow();\\n    var document = getDocument();\\n    var el = this[0];\\n    var compareWith;\\n    var i;\\n\\n    if (!el || typeof selector === 'undefined') {\\n      return false;\\n    }\\n\\n    if (typeof selector === 'string') {\\n      if (el.matches) {\\n        return el.matches(selector);\\n      }\\n\\n      if (el.webkitMatchesSelector) {\\n        return el.webkitMatchesSelector(selector);\\n      }\\n\\n      if (el.msMatchesSelector) {\\n        return el.msMatchesSelector(selector);\\n      }\\n\\n      compareWith = $(selector);\\n\\n      for (i = 0; i < compareWith.length; i += 1) {\\n        if (compareWith[i] === el) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n    if (selector === document) {\\n      return el === document;\\n    }\\n\\n    if (selector === window) {\\n      return el === window;\\n    }\\n\\n    if (selector.nodeType || selector instanceof Dom7) {\\n      compareWith = selector.nodeType ? [selector] : selector;\\n\\n      for (i = 0; i < compareWith.length; i += 1) {\\n        if (compareWith[i] === el) {\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    }\\n\\n    return false;\\n  }\\n\\n  function index() {\\n    var child = this[0];\\n    var i;\\n\\n    if (child) {\\n      i = 0; // eslint-disable-next-line\\n\\n      while ((child = child.previousSibling) !== null) {\\n        if (child.nodeType === 1) {\\n          i += 1;\\n        }\\n      }\\n\\n      return i;\\n    }\\n\\n    return undefined;\\n  }\\n\\n  function eq(index) {\\n    if (typeof index === 'undefined') {\\n      return this;\\n    }\\n\\n    var length = this.length;\\n\\n    if (index > length - 1) {\\n      return $([]);\\n    }\\n\\n    if (index < 0) {\\n      var returnIndex = length + index;\\n\\n      if (returnIndex < 0) {\\n        return $([]);\\n      }\\n\\n      return $([this[returnIndex]]);\\n    }\\n\\n    return $([this[index]]);\\n  }\\n\\n  function append() {\\n    var newChild;\\n    var document = getDocument();\\n\\n    for (var k = 0; k < arguments.length; k += 1) {\\n      newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];\\n\\n      for (var i = 0; i < this.length; i += 1) {\\n        if (typeof newChild === 'string') {\\n          var tempDiv = document.createElement('div');\\n          tempDiv.innerHTML = newChild;\\n\\n          while (tempDiv.firstChild) {\\n            this[i].appendChild(tempDiv.firstChild);\\n          }\\n        } else if (newChild instanceof Dom7) {\\n          for (var j = 0; j < newChild.length; j += 1) {\\n            this[i].appendChild(newChild[j]);\\n          }\\n        } else {\\n          this[i].appendChild(newChild);\\n        }\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function prepend(newChild) {\\n    var document = getDocument();\\n    var i;\\n    var j;\\n\\n    for (i = 0; i < this.length; i += 1) {\\n      if (typeof newChild === 'string') {\\n        var tempDiv = document.createElement('div');\\n        tempDiv.innerHTML = newChild;\\n\\n        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {\\n          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\\n        }\\n      } else if (newChild instanceof Dom7) {\\n        for (j = 0; j < newChild.length; j += 1) {\\n          this[i].insertBefore(newChild[j], this[i].childNodes[0]);\\n        }\\n      } else {\\n        this[i].insertBefore(newChild, this[i].childNodes[0]);\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  function next(selector) {\\n    if (this.length > 0) {\\n      if (selector) {\\n        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\\n          return $([this[0].nextElementSibling]);\\n        }\\n\\n        return $([]);\\n      }\\n\\n      if (this[0].nextElementSibling) {\\n        return $([this[0].nextElementSibling]);\\n      }\\n\\n      return $([]);\\n    }\\n\\n    return $([]);\\n  }\\n\\n  function nextAll(selector) {\\n    var nextEls = [];\\n    var el = this[0];\\n\\n    if (!el) {\\n      return $([]);\\n    }\\n\\n    while (el.nextElementSibling) {\\n      var _next = el.nextElementSibling; // eslint-disable-line\\n\\n      if (selector) {\\n        if ($(_next).is(selector)) {\\n          nextEls.push(_next);\\n        }\\n      } else {\\n        nextEls.push(_next);\\n      }\\n\\n      el = _next;\\n    }\\n\\n    return $(nextEls);\\n  }\\n\\n  function prev(selector) {\\n    if (this.length > 0) {\\n      var el = this[0];\\n\\n      if (selector) {\\n        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {\\n          return $([el.previousElementSibling]);\\n        }\\n\\n        return $([]);\\n      }\\n\\n      if (el.previousElementSibling) {\\n        return $([el.previousElementSibling]);\\n      }\\n\\n      return $([]);\\n    }\\n\\n    return $([]);\\n  }\\n\\n  function prevAll(selector) {\\n    var prevEls = [];\\n    var el = this[0];\\n\\n    if (!el) {\\n      return $([]);\\n    }\\n\\n    while (el.previousElementSibling) {\\n      var _prev = el.previousElementSibling; // eslint-disable-line\\n\\n      if (selector) {\\n        if ($(_prev).is(selector)) {\\n          prevEls.push(_prev);\\n        }\\n      } else {\\n        prevEls.push(_prev);\\n      }\\n\\n      el = _prev;\\n    }\\n\\n    return $(prevEls);\\n  }\\n\\n  function parent(selector) {\\n    var parents = []; // eslint-disable-line\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (this[i].parentNode !== null) {\\n        if (selector) {\\n          if ($(this[i].parentNode).is(selector)) {\\n            parents.push(this[i].parentNode);\\n          }\\n        } else {\\n          parents.push(this[i].parentNode);\\n        }\\n      }\\n    }\\n\\n    return $(parents);\\n  }\\n\\n  function parents(selector) {\\n    var parents = []; // eslint-disable-line\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      var _parent = this[i].parentNode; // eslint-disable-line\\n\\n      while (_parent) {\\n        if (selector) {\\n          if ($(_parent).is(selector)) {\\n            parents.push(_parent);\\n          }\\n        } else {\\n          parents.push(_parent);\\n        }\\n\\n        _parent = _parent.parentNode;\\n      }\\n    }\\n\\n    return $(parents);\\n  }\\n\\n  function closest(selector) {\\n    var closest = this; // eslint-disable-line\\n\\n    if (typeof selector === 'undefined') {\\n      return $([]);\\n    }\\n\\n    if (!closest.is(selector)) {\\n      closest = closest.parents(selector).eq(0);\\n    }\\n\\n    return closest;\\n  }\\n\\n  function find(selector) {\\n    var foundElements = [];\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      var found = this[i].querySelectorAll(selector);\\n\\n      for (var j = 0; j < found.length; j += 1) {\\n        foundElements.push(found[j]);\\n      }\\n    }\\n\\n    return $(foundElements);\\n  }\\n\\n  function children(selector) {\\n    var children = []; // eslint-disable-line\\n\\n    for (var i = 0; i < this.length; i += 1) {\\n      var childNodes = this[i].children;\\n\\n      for (var j = 0; j < childNodes.length; j += 1) {\\n        if (!selector || $(childNodes[j]).is(selector)) {\\n          children.push(childNodes[j]);\\n        }\\n      }\\n    }\\n\\n    return $(children);\\n  }\\n\\n  function remove() {\\n    for (var i = 0; i < this.length; i += 1) {\\n      if (this[i].parentNode) {\\n        this[i].parentNode.removeChild(this[i]);\\n      }\\n    }\\n\\n    return this;\\n  }\\n\\n  var Methods = {\\n    addClass: addClass,\\n    removeClass: removeClass,\\n    hasClass: hasClass,\\n    toggleClass: toggleClass,\\n    attr: attr,\\n    removeAttr: removeAttr,\\n    transform: transform,\\n    transition: transition$1,\\n    on: on,\\n    off: off,\\n    trigger: trigger,\\n    transitionEnd: transitionEnd$1,\\n    outerWidth: outerWidth,\\n    outerHeight: outerHeight,\\n    styles: styles,\\n    offset: offset,\\n    css: css,\\n    each: each,\\n    html: html,\\n    text: text,\\n    is: is,\\n    index: index,\\n    eq: eq,\\n    append: append,\\n    prepend: prepend,\\n    next: next,\\n    nextAll: nextAll,\\n    prev: prev,\\n    prevAll: prevAll,\\n    parent: parent,\\n    parents: parents,\\n    closest: closest,\\n    find: find,\\n    children: children,\\n    filter: filter,\\n    remove: remove\\n  };\\n  Object.keys(Methods).forEach(function (methodName) {\\n    Object.defineProperty($.fn, methodName, {\\n      value: Methods[methodName],\\n      writable: true\\n    });\\n  });\\n\\n  function deleteProps(obj) {\\n    var object = obj;\\n    Object.keys(object).forEach(function (key) {\\n      try {\\n        object[key] = null;\\n      } catch (e) {// no getter for object\\n      }\\n\\n      try {\\n        delete object[key];\\n      } catch (e) {// something got wrong\\n      }\\n    });\\n  }\\n\\n  function nextTick(callback) {\\n    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n    return setTimeout(callback, delay);\\n  }\\n\\n  function now() {\\n    return Date.now();\\n  }\\n\\n  function getComputedStyle$1(el) {\\n    var window = getWindow();\\n    var style;\\n\\n    if (window.getComputedStyle) {\\n      style = window.getComputedStyle(el, null);\\n    }\\n\\n    if (!style && el.currentStyle) {\\n      style = el.currentStyle;\\n    }\\n\\n    if (!style) {\\n      style = el.style;\\n    }\\n\\n    return style;\\n  }\\n\\n  function getTranslate(el) {\\n    var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';\\n    var window = getWindow();\\n    var matrix;\\n    var curTransform;\\n    var transformMatrix;\\n    var curStyle = getComputedStyle$1(el);\\n\\n    if (window.WebKitCSSMatrix) {\\n      curTransform = curStyle.transform || curStyle.webkitTransform;\\n\\n      if (curTransform.split(',').length > 6) {\\n        curTransform = curTransform.split(', ').map(function (a) {\\n          return a.replace(',', '.');\\n        }).join(', ');\\n      } // Some old versions of Webkit choke when 'none' is passed; pass\\n      // empty string instead in this case\\n\\n\\n      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\\n    } else {\\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\\n      matrix = transformMatrix.toString().split(',');\\n    }\\n\\n    if (axis === 'x') {\\n      // Latest Chrome and webkits Fix\\n      if (window.WebKitCSSMatrix) {\\n        curTransform = transformMatrix.m41;\\n      } // Crazy IE10 Matrix\\n      else if (matrix.length === 16) {\\n        curTransform = parseFloat(matrix[12]);\\n      } // Normal Browsers\\n      else {\\n        curTransform = parseFloat(matrix[4]);\\n      }\\n    }\\n\\n    if (axis === 'y') {\\n      // Latest Chrome and webkits Fix\\n      if (window.WebKitCSSMatrix) {\\n        curTransform = transformMatrix.m42;\\n      } // Crazy IE10 Matrix\\n      else if (matrix.length === 16) {\\n        curTransform = parseFloat(matrix[13]);\\n      } // Normal Browsers\\n      else {\\n        curTransform = parseFloat(matrix[5]);\\n      }\\n    }\\n\\n    return curTransform || 0;\\n  }\\n\\n  function isObject(o) {\\n    return _typeof(o) === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\\n  }\\n\\n  function isNode(node) {\\n    // eslint-disable-next-line\\n    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\\n      return node instanceof HTMLElement;\\n    }\\n\\n    return node && (node.nodeType === 1 || node.nodeType === 11);\\n  }\\n\\n  function extend() {\\n    var to = Object(arguments.length <= 0 ? undefined : arguments[0]);\\n    var noExtend = ['__proto__', 'constructor', 'prototype'];\\n\\n    for (var i = 1; i < arguments.length; i += 1) {\\n      var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\\n\\n      if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\\n        var keysArray = Object.keys(Object(nextSource)).filter(function (key) {\\n          return noExtend.indexOf(key) < 0;\\n        });\\n\\n        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\\n          var nextKey = keysArray[nextIndex];\\n          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\\n\\n          if (desc !== undefined && desc.enumerable) {\\n            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\\n              if (nextSource[nextKey].__swiper__) {\\n                to[nextKey] = nextSource[nextKey];\\n              } else {\\n                extend(to[nextKey], nextSource[nextKey]);\\n              }\\n            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\\n              to[nextKey] = {};\\n\\n              if (nextSource[nextKey].__swiper__) {\\n                to[nextKey] = nextSource[nextKey];\\n              } else {\\n                extend(to[nextKey], nextSource[nextKey]);\\n              }\\n            } else {\\n              to[nextKey] = nextSource[nextKey];\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return to;\\n  }\\n\\n  function setCSSProperty(el, varName, varValue) {\\n    el.style.setProperty(varName, varValue);\\n  }\\n\\n  function animateCSSModeScroll(_ref) {\\n    var swiper = _ref.swiper,\\n        targetPosition = _ref.targetPosition,\\n        side = _ref.side;\\n    var window = getWindow();\\n    var startPosition = -swiper.translate;\\n    var startTime = null;\\n    var time;\\n    var duration = swiper.params.speed;\\n    swiper.wrapperEl.style.scrollSnapType = 'none';\\n    window.cancelAnimationFrame(swiper.cssModeFrameID);\\n    var dir = targetPosition > startPosition ? 'next' : 'prev';\\n\\n    var isOutOfBound = function isOutOfBound(current, target) {\\n      return dir === 'next' && current >= target || dir === 'prev' && current <= target;\\n    };\\n\\n    var animate = function animate() {\\n      time = new Date().getTime();\\n\\n      if (startTime === null) {\\n        startTime = time;\\n      }\\n\\n      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\\n      var easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\\n      var currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\\n\\n      if (isOutOfBound(currentPosition, targetPosition)) {\\n        currentPosition = targetPosition;\\n      }\\n\\n      swiper.wrapperEl.scrollTo(_defineProperty({}, side, currentPosition));\\n\\n      if (isOutOfBound(currentPosition, targetPosition)) {\\n        swiper.wrapperEl.style.overflow = 'hidden';\\n        swiper.wrapperEl.style.scrollSnapType = '';\\n        setTimeout(function () {\\n          swiper.wrapperEl.style.overflow = '';\\n          swiper.wrapperEl.scrollTo(_defineProperty({}, side, currentPosition));\\n        });\\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\\n        return;\\n      }\\n\\n      swiper.cssModeFrameID = window.requestAnimationFrame(animate);\\n    };\\n\\n    animate();\\n  }\\n\\n  var support;\\n\\n  function calcSupport() {\\n    var window = getWindow();\\n    var document = getDocument();\\n    return {\\n      smoothScroll: document.documentElement && 'scrollBehavior' in document.documentElement.style,\\n      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),\\n      passiveListener: function checkPassiveListener() {\\n        var supportsPassive = false;\\n\\n        try {\\n          var opts = Object.defineProperty({}, 'passive', {\\n            // eslint-disable-next-line\\n            get: function get() {\\n              supportsPassive = true;\\n            }\\n          });\\n          window.addEventListener('testPassiveListener', null, opts);\\n        } catch (e) {// No support\\n        }\\n\\n        return supportsPassive;\\n      }(),\\n      gestures: function checkGestures() {\\n        return 'ongesturestart' in window;\\n      }()\\n    };\\n  }\\n\\n  function getSupport() {\\n    if (!support) {\\n      support = calcSupport();\\n    }\\n\\n    return support;\\n  }\\n\\n  var deviceCached;\\n\\n  function calcDevice() {\\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\\n        userAgent = _ref2.userAgent;\\n\\n    var support = getSupport();\\n    var window = getWindow();\\n    var platform = window.navigator.platform;\\n    var ua = userAgent || window.navigator.userAgent;\\n    var device = {\\n      ios: false,\\n      android: false\\n    };\\n    var screenWidth = window.screen.width;\\n    var screenHeight = window.screen.height;\\n    var android = ua.match(/(Android);?[\\\\s\\\\/]+([\\\\d.]+)?/); // eslint-disable-line\\n\\n    var ipad = ua.match(/(iPad).*OS\\\\s([\\\\d_]+)/);\\n    var ipod = ua.match(/(iPod)(.*OS\\\\s([\\\\d_]+))?/);\\n    var iphone = !ipad && ua.match(/(iPhone\\\\sOS|iOS)\\\\s([\\\\d_]+)/);\\n    var windows = platform === 'Win32';\\n    var macos = platform === 'MacIntel'; // iPadOs 13 fix\\n\\n    var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\\n\\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(\\\"\\\".concat(screenWidth, \\\"x\\\").concat(screenHeight)) >= 0) {\\n      ipad = ua.match(/(Version)\\\\/([\\\\d.]+)/);\\n\\n      if (!ipad) {\\n        ipad = [0, 1, '13_0_0'];\\n      }\\n\\n      macos = false;\\n    } // Android\\n\\n\\n    if (android && !windows) {\\n      device.os = 'android';\\n      device.android = true;\\n    }\\n\\n    if (ipad || iphone || ipod) {\\n      device.os = 'ios';\\n      device.ios = true;\\n    } // Export object\\n\\n\\n    return device;\\n  }\\n\\n  function getDevice() {\\n    var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n    if (!deviceCached) {\\n      deviceCached = calcDevice(overrides);\\n    }\\n\\n    return deviceCached;\\n  }\\n\\n  var browser;\\n\\n  function calcBrowser() {\\n    var window = getWindow();\\n\\n    function isSafari() {\\n      var ua = window.navigator.userAgent.toLowerCase();\\n      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\\n    }\\n\\n    return {\\n      isSafari: isSafari(),\\n      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\\n    };\\n  }\\n\\n  function getBrowser() {\\n    if (!browser) {\\n      browser = calcBrowser();\\n    }\\n\\n    return browser;\\n  }\\n\\n  function Resize(_ref3) {\\n    var swiper = _ref3.swiper,\\n        on = _ref3.on,\\n        emit = _ref3.emit;\\n    var window = getWindow();\\n    var observer = null;\\n\\n    var resizeHandler = function resizeHandler() {\\n      if (!swiper || swiper.destroyed || !swiper.initialized) {\\n        return;\\n      }\\n\\n      emit('beforeResize');\\n      emit('resize');\\n    };\\n\\n    var createObserver = function createObserver() {\\n      if (!swiper || swiper.destroyed || !swiper.initialized) {\\n        return;\\n      }\\n\\n      observer = new ResizeObserver(function (entries) {\\n        var width = swiper.width,\\n            height = swiper.height;\\n        var newWidth = width;\\n        var newHeight = height;\\n        entries.forEach(function (_ref4) {\\n          var contentBoxSize = _ref4.contentBoxSize,\\n              contentRect = _ref4.contentRect,\\n              target = _ref4.target;\\n\\n          if (target && target !== swiper.el) {\\n            return;\\n          }\\n\\n          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\\n          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\\n        });\\n\\n        if (newWidth !== width || newHeight !== height) {\\n          resizeHandler();\\n        }\\n      });\\n      observer.observe(swiper.el);\\n    };\\n\\n    var removeObserver = function removeObserver() {\\n      if (observer && observer.unobserve && swiper.el) {\\n        observer.unobserve(swiper.el);\\n        observer = null;\\n      }\\n    };\\n\\n    var orientationChangeHandler = function orientationChangeHandler() {\\n      if (!swiper || swiper.destroyed || !swiper.initialized) {\\n        return;\\n      }\\n\\n      emit('orientationchange');\\n    };\\n\\n    on('init', function () {\\n      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\\n        createObserver();\\n        return;\\n      }\\n\\n      window.addEventListener('resize', resizeHandler);\\n      window.addEventListener('orientationchange', orientationChangeHandler);\\n    });\\n    on('destroy', function () {\\n      removeObserver();\\n      window.removeEventListener('resize', resizeHandler);\\n      window.removeEventListener('orientationchange', orientationChangeHandler);\\n    });\\n  }\\n\\n  function Observer(_ref5) {\\n    var swiper = _ref5.swiper,\\n        extendParams = _ref5.extendParams,\\n        on = _ref5.on,\\n        emit = _ref5.emit;\\n    var observers = [];\\n    var window = getWindow();\\n\\n    var attach = function attach(target) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n      var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\\n      var observer = new ObserverFunc(function (mutations) {\\n        // The observerUpdate event should only be triggered\\n        // once despite the number of mutations.  Additional\\n        // triggers are redundant and are very costly\\n        if (mutations.length === 1) {\\n          emit('observerUpdate', mutations[0]);\\n          return;\\n        }\\n\\n        var observerUpdate = function observerUpdate() {\\n          emit('observerUpdate', mutations[0]);\\n        };\\n\\n        if (window.requestAnimationFrame) {\\n          window.requestAnimationFrame(observerUpdate);\\n        } else {\\n          window.setTimeout(observerUpdate, 0);\\n        }\\n      });\\n      observer.observe(target, {\\n        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\\n        childList: typeof options.childList === 'undefined' ? true : options.childList,\\n        characterData: typeof options.characterData === 'undefined' ? true : options.characterData\\n      });\\n      observers.push(observer);\\n    };\\n\\n    var init = function init() {\\n      if (!swiper.params.observer) {\\n        return;\\n      }\\n\\n      if (swiper.params.observeParents) {\\n        var containerParents = swiper.$el.parents();\\n\\n        for (var i = 0; i < containerParents.length; i += 1) {\\n          attach(containerParents[i]);\\n        }\\n      } // Observe container\\n\\n\\n      attach(swiper.$el[0], {\\n        childList: swiper.params.observeSlideChildren\\n      }); // Observe wrapper\\n\\n      attach(swiper.$wrapperEl[0], {\\n        attributes: false\\n      });\\n    };\\n\\n    var destroy = function destroy() {\\n      observers.forEach(function (observer) {\\n        observer.disconnect();\\n      });\\n      observers.splice(0, observers.length);\\n    };\\n\\n    extendParams({\\n      observer: false,\\n      observeParents: false,\\n      observeSlideChildren: false\\n    });\\n    on('init', init);\\n    on('destroy', destroy);\\n  }\\n  /* eslint-disable no-underscore-dangle */\\n\\n\\n  var eventsEmitter = {\\n    on: function on(events, handler, priority) {\\n      var self = this;\\n\\n      if (typeof handler !== 'function') {\\n        return self;\\n      }\\n\\n      var method = priority ? 'unshift' : 'push';\\n      events.split(' ').forEach(function (event) {\\n        if (!self.eventsListeners[event]) {\\n          self.eventsListeners[event] = [];\\n        }\\n\\n        self.eventsListeners[event][method](handler);\\n      });\\n      return self;\\n    },\\n    once: function once(events, handler, priority) {\\n      var self = this;\\n\\n      if (typeof handler !== 'function') {\\n        return self;\\n      }\\n\\n      function onceHandler() {\\n        self.off(events, onceHandler);\\n\\n        if (onceHandler.__emitterProxy) {\\n          delete onceHandler.__emitterProxy;\\n        }\\n\\n        for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\\n          args[_key8] = arguments[_key8];\\n        }\\n\\n        handler.apply(self, args);\\n      }\\n\\n      onceHandler.__emitterProxy = handler;\\n      return self.on(events, onceHandler, priority);\\n    },\\n    onAny: function onAny(handler, priority) {\\n      var self = this;\\n\\n      if (typeof handler !== 'function') {\\n        return self;\\n      }\\n\\n      var method = priority ? 'unshift' : 'push';\\n\\n      if (self.eventsAnyListeners.indexOf(handler) < 0) {\\n        self.eventsAnyListeners[method](handler);\\n      }\\n\\n      return self;\\n    },\\n    offAny: function offAny(handler) {\\n      var self = this;\\n\\n      if (!self.eventsAnyListeners) {\\n        return self;\\n      }\\n\\n      var index = self.eventsAnyListeners.indexOf(handler);\\n\\n      if (index >= 0) {\\n        self.eventsAnyListeners.splice(index, 1);\\n      }\\n\\n      return self;\\n    },\\n    off: function off(events, handler) {\\n      var self = this;\\n\\n      if (!self.eventsListeners) {\\n        return self;\\n      }\\n\\n      events.split(' ').forEach(function (event) {\\n        if (typeof handler === 'undefined') {\\n          self.eventsListeners[event] = [];\\n        } else if (self.eventsListeners[event]) {\\n          self.eventsListeners[event].forEach(function (eventHandler, index) {\\n            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\\n              self.eventsListeners[event].splice(index, 1);\\n            }\\n          });\\n        }\\n      });\\n      return self;\\n    },\\n    emit: function emit() {\\n      var self = this;\\n\\n      if (!self.eventsListeners) {\\n        return self;\\n      }\\n\\n      var events;\\n      var data;\\n      var context;\\n\\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\\n        args[_key9] = arguments[_key9];\\n      }\\n\\n      if (typeof args[0] === 'string' || Array.isArray(args[0])) {\\n        events = args[0];\\n        data = args.slice(1, args.length);\\n        context = self;\\n      } else {\\n        events = args[0].events;\\n        data = args[0].data;\\n        context = args[0].context || self;\\n      }\\n\\n      data.unshift(context);\\n      var eventsArray = Array.isArray(events) ? events : events.split(' ');\\n      eventsArray.forEach(function (event) {\\n        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\\n          self.eventsAnyListeners.forEach(function (eventHandler) {\\n            eventHandler.apply(context, [event].concat(_toConsumableArray(data)));\\n          });\\n        }\\n\\n        if (self.eventsListeners && self.eventsListeners[event]) {\\n          self.eventsListeners[event].forEach(function (eventHandler) {\\n            eventHandler.apply(context, data);\\n          });\\n        }\\n      });\\n      return self;\\n    }\\n  };\\n\\n  function updateSize() {\\n    var swiper = this;\\n    var width;\\n    var height;\\n    var $el = swiper.$el;\\n\\n    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\\n      width = swiper.params.width;\\n    } else {\\n      width = $el[0].clientWidth;\\n    }\\n\\n    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\\n      height = swiper.params.height;\\n    } else {\\n      height = $el[0].clientHeight;\\n    }\\n\\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\\n      return;\\n    } // Subtract paddings\\n\\n\\n    width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);\\n    height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);\\n\\n    if (Number.isNaN(width)) {\\n      width = 0;\\n    }\\n\\n    if (Number.isNaN(height)) {\\n      height = 0;\\n    }\\n\\n    Object.assign(swiper, {\\n      width: width,\\n      height: height,\\n      size: swiper.isHorizontal() ? width : height\\n    });\\n  }\\n\\n  function updateSlides() {\\n    var swiper = this;\\n\\n    function getDirectionLabel(property) {\\n      if (swiper.isHorizontal()) {\\n        return property;\\n      } // prettier-ignore\\n\\n\\n      return {\\n        'width': 'height',\\n        'margin-top': 'margin-left',\\n        'margin-bottom ': 'margin-right',\\n        'margin-left': 'margin-top',\\n        'margin-right': 'margin-bottom',\\n        'padding-left': 'padding-top',\\n        'padding-right': 'padding-bottom',\\n        'marginRight': 'marginBottom'\\n      }[property];\\n    }\\n\\n    function getDirectionPropertyValue(node, label) {\\n      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\\n    }\\n\\n    var params = swiper.params;\\n    var $wrapperEl = swiper.$wrapperEl,\\n        swiperSize = swiper.size,\\n        rtl = swiper.rtlTranslate,\\n        wrongRTL = swiper.wrongRTL;\\n    var isVirtual = swiper.virtual && params.virtual.enabled;\\n    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\\n    var slides = $wrapperEl.children(\\\".\\\".concat(swiper.params.slideClass));\\n    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\\n    var snapGrid = [];\\n    var slidesGrid = [];\\n    var slidesSizesGrid = [];\\n    var offsetBefore = params.slidesOffsetBefore;\\n\\n    if (typeof offsetBefore === 'function') {\\n      offsetBefore = params.slidesOffsetBefore.call(swiper);\\n    }\\n\\n    var offsetAfter = params.slidesOffsetAfter;\\n\\n    if (typeof offsetAfter === 'function') {\\n      offsetAfter = params.slidesOffsetAfter.call(swiper);\\n    }\\n\\n    var previousSnapGridLength = swiper.snapGrid.length;\\n    var previousSlidesGridLength = swiper.slidesGrid.length;\\n    var spaceBetween = params.spaceBetween;\\n    var slidePosition = -offsetBefore;\\n    var prevSlideSize = 0;\\n    var index = 0;\\n\\n    if (typeof swiperSize === 'undefined') {\\n      return;\\n    }\\n\\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\\n    }\\n\\n    swiper.virtualSize = -spaceBetween; // reset margins\\n\\n    if (rtl) {\\n      slides.css({\\n        marginLeft: '',\\n        marginBottom: '',\\n        marginTop: ''\\n      });\\n    } else {\\n      slides.css({\\n        marginRight: '',\\n        marginBottom: '',\\n        marginTop: ''\\n      });\\n    } // reset cssMode offsets\\n\\n\\n    if (params.centeredSlides && params.cssMode) {\\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', '');\\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', '');\\n    }\\n\\n    var gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\\n\\n    if (gridEnabled) {\\n      swiper.grid.initSlides(slidesLength);\\n    } // Calc slides\\n\\n\\n    var slideSize;\\n    var shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(function (key) {\\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\\n    }).length > 0;\\n\\n    for (var i = 0; i < slidesLength; i += 1) {\\n      slideSize = 0;\\n\\n      var _slide = slides.eq(i);\\n\\n      if (gridEnabled) {\\n        swiper.grid.updateSlide(i, _slide, slidesLength, getDirectionLabel);\\n      }\\n\\n      if (_slide.css('display') === 'none') continue; // eslint-disable-line\\n\\n      if (params.slidesPerView === 'auto') {\\n        if (shouldResetSlideSize) {\\n          slides[i].style[getDirectionLabel('width')] = '';\\n        }\\n\\n        var slideStyles = getComputedStyle(_slide[0]);\\n        var currentTransform = _slide[0].style.transform;\\n        var currentWebKitTransform = _slide[0].style.webkitTransform;\\n\\n        if (currentTransform) {\\n          _slide[0].style.transform = 'none';\\n        }\\n\\n        if (currentWebKitTransform) {\\n          _slide[0].style.webkitTransform = 'none';\\n        }\\n\\n        if (params.roundLengths) {\\n          slideSize = swiper.isHorizontal() ? _slide.outerWidth(true) : _slide.outerHeight(true);\\n        } else {\\n          // eslint-disable-next-line\\n          var width = getDirectionPropertyValue(slideStyles, 'width');\\n          var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\\n          var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\\n          var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\\n          var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\\n          var boxSizing = slideStyles.getPropertyValue('box-sizing');\\n\\n          if (boxSizing && boxSizing === 'border-box') {\\n            slideSize = width + marginLeft + marginRight;\\n          } else {\\n            var _slide$ = _slide[0],\\n                clientWidth = _slide$.clientWidth,\\n                offsetWidth = _slide$.offsetWidth;\\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\\n          }\\n        }\\n\\n        if (currentTransform) {\\n          _slide[0].style.transform = currentTransform;\\n        }\\n\\n        if (currentWebKitTransform) {\\n          _slide[0].style.webkitTransform = currentWebKitTransform;\\n        }\\n\\n        if (params.roundLengths) {\\n          slideSize = Math.floor(slideSize);\\n        }\\n      } else {\\n        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\\n\\n        if (params.roundLengths) {\\n          slideSize = Math.floor(slideSize);\\n        }\\n\\n        if (slides[i]) {\\n          slides[i].style[getDirectionLabel('width')] = \\\"\\\".concat(slideSize, \\\"px\\\");\\n        }\\n      }\\n\\n      if (slides[i]) {\\n        slides[i].swiperSlideSize = slideSize;\\n      }\\n\\n      slidesSizesGrid.push(slideSize);\\n\\n      if (params.centeredSlides) {\\n        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\\n\\n        if (prevSlideSize === 0 && i !== 0) {\\n          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\\n        }\\n\\n        if (i === 0) {\\n          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\\n        }\\n\\n        if (Math.abs(slidePosition) < 1 / 1000) {\\n          slidePosition = 0;\\n        }\\n\\n        if (params.roundLengths) {\\n          slidePosition = Math.floor(slidePosition);\\n        }\\n\\n        if (index % params.slidesPerGroup === 0) {\\n          snapGrid.push(slidePosition);\\n        }\\n\\n        slidesGrid.push(slidePosition);\\n      } else {\\n        if (params.roundLengths) {\\n          slidePosition = Math.floor(slidePosition);\\n        }\\n\\n        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) {\\n          snapGrid.push(slidePosition);\\n        }\\n\\n        slidesGrid.push(slidePosition);\\n        slidePosition = slidePosition + slideSize + spaceBetween;\\n      }\\n\\n      swiper.virtualSize += slideSize + spaceBetween;\\n      prevSlideSize = slideSize;\\n      index += 1;\\n    }\\n\\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\\n\\n    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\\n      $wrapperEl.css({\\n        width: \\\"\\\".concat(swiper.virtualSize + params.spaceBetween, \\\"px\\\")\\n      });\\n    }\\n\\n    if (params.setWrapperSize) {\\n      $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), \\\"\\\".concat(swiper.virtualSize + params.spaceBetween, \\\"px\\\")));\\n    }\\n\\n    if (gridEnabled) {\\n      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\\n    } // Remove last grid elements depending on width\\n\\n\\n    if (!params.centeredSlides) {\\n      var newSlidesGrid = [];\\n\\n      for (var _i = 0; _i < snapGrid.length; _i += 1) {\\n        var slidesGridItem = snapGrid[_i];\\n\\n        if (params.roundLengths) {\\n          slidesGridItem = Math.floor(slidesGridItem);\\n        }\\n\\n        if (snapGrid[_i] <= swiper.virtualSize - swiperSize) {\\n          newSlidesGrid.push(slidesGridItem);\\n        }\\n      }\\n\\n      snapGrid = newSlidesGrid;\\n\\n      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\\n        snapGrid.push(swiper.virtualSize - swiperSize);\\n      }\\n    }\\n\\n    if (snapGrid.length === 0) {\\n      snapGrid = [0];\\n    }\\n\\n    if (params.spaceBetween !== 0) {\\n      var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\\n      slides.filter(function (_, slideIndex) {\\n        if (!params.cssMode) {\\n          return true;\\n        }\\n\\n        if (slideIndex === slides.length - 1) {\\n          return false;\\n        }\\n\\n        return true;\\n      }).css(_defineProperty({}, key, \\\"\\\".concat(spaceBetween, \\\"px\\\")));\\n    }\\n\\n    if (params.centeredSlides && params.centeredSlidesBounds) {\\n      var allSlidesSize = 0;\\n      slidesSizesGrid.forEach(function (slideSizeValue) {\\n        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\\n      });\\n      allSlidesSize -= params.spaceBetween;\\n      var maxSnap = allSlidesSize - swiperSize;\\n      snapGrid = snapGrid.map(function (snap) {\\n        if (snap < 0) {\\n          return -offsetBefore;\\n        }\\n\\n        if (snap > maxSnap) {\\n          return maxSnap + offsetAfter;\\n        }\\n\\n        return snap;\\n      });\\n    }\\n\\n    if (params.centerInsufficientSlides) {\\n      var _allSlidesSize = 0;\\n      slidesSizesGrid.forEach(function (slideSizeValue) {\\n        _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);\\n      });\\n      _allSlidesSize -= params.spaceBetween;\\n\\n      if (_allSlidesSize < swiperSize) {\\n        var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;\\n        snapGrid.forEach(function (snap, snapIndex) {\\n          snapGrid[snapIndex] = snap - allSlidesOffset;\\n        });\\n        slidesGrid.forEach(function (snap, snapIndex) {\\n          slidesGrid[snapIndex] = snap + allSlidesOffset;\\n        });\\n      }\\n    }\\n\\n    Object.assign(swiper, {\\n      slides: slides,\\n      snapGrid: snapGrid,\\n      slidesGrid: slidesGrid,\\n      slidesSizesGrid: slidesSizesGrid\\n    });\\n\\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-before', \\\"\\\".concat(-snapGrid[0], \\\"px\\\"));\\n      setCSSProperty(swiper.wrapperEl, '--swiper-centered-offset-after', \\\"\\\".concat(swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2, \\\"px\\\"));\\n      var addToSnapGrid = -swiper.snapGrid[0];\\n      var addToSlidesGrid = -swiper.slidesGrid[0];\\n      swiper.snapGrid = swiper.snapGrid.map(function (v) {\\n        return v + addToSnapGrid;\\n      });\\n      swiper.slidesGrid = swiper.slidesGrid.map(function (v) {\\n        return v + addToSlidesGrid;\\n      });\\n    }\\n\\n    if (slidesLength !== previousSlidesLength) {\\n      swiper.emit('slidesLengthChange');\\n    }\\n\\n    if (snapGrid.length !== previousSnapGridLength) {\\n      if (swiper.params.watchOverflow) {\\n        swiper.checkOverflow();\\n      }\\n\\n      swiper.emit('snapGridLengthChange');\\n    }\\n\\n    if (slidesGrid.length !== previousSlidesGridLength) {\\n      swiper.emit('slidesGridLengthChange');\\n    }\\n\\n    if (params.watchSlidesProgress) {\\n      swiper.updateSlidesOffset();\\n    }\\n  }\\n\\n  function updateAutoHeight(speed) {\\n    var swiper = this;\\n    var activeSlides = [];\\n    var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n    var newHeight = 0;\\n    var i;\\n\\n    if (typeof speed === 'number') {\\n      swiper.setTransition(speed);\\n    } else if (speed === true) {\\n      swiper.setTransition(swiper.params.speed);\\n    }\\n\\n    var getSlideByIndex = function getSlideByIndex(index) {\\n      if (isVirtual) {\\n        return swiper.slides.filter(function (el) {\\n          return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;\\n        })[0];\\n      }\\n\\n      return swiper.slides.eq(index)[0];\\n    }; // Find slides currently in view\\n\\n\\n    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\\n      if (swiper.params.centeredSlides) {\\n        swiper.visibleSlides.each(function (slide) {\\n          activeSlides.push(slide);\\n        });\\n      } else {\\n        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\\n          var _index = swiper.activeIndex + i;\\n\\n          if (_index > swiper.slides.length && !isVirtual) {\\n            break;\\n          }\\n\\n          activeSlides.push(getSlideByIndex(_index));\\n        }\\n      }\\n    } else {\\n      activeSlides.push(getSlideByIndex(swiper.activeIndex));\\n    } // Find new height from highest slide in view\\n\\n\\n    for (i = 0; i < activeSlides.length; i += 1) {\\n      if (typeof activeSlides[i] !== 'undefined') {\\n        var height = activeSlides[i].offsetHeight;\\n        newHeight = height > newHeight ? height : newHeight;\\n      }\\n    } // Update Height\\n\\n\\n    if (newHeight) {\\n      swiper.$wrapperEl.css('height', \\\"\\\".concat(newHeight, \\\"px\\\"));\\n    }\\n  }\\n\\n  function updateSlidesOffset() {\\n    var swiper = this;\\n    var slides = swiper.slides;\\n\\n    for (var i = 0; i < slides.length; i += 1) {\\n      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;\\n    }\\n  }\\n\\n  function updateSlidesProgress() {\\n    var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;\\n    var swiper = this;\\n    var params = swiper.params;\\n    var slides = swiper.slides,\\n        rtl = swiper.rtlTranslate,\\n        snapGrid = swiper.snapGrid;\\n\\n    if (slides.length === 0) {\\n      return;\\n    }\\n\\n    if (typeof slides[0].swiperSlideOffset === 'undefined') {\\n      swiper.updateSlidesOffset();\\n    }\\n\\n    var offsetCenter = -translate;\\n\\n    if (rtl) {\\n      offsetCenter = translate;\\n    } // Visible Slides\\n\\n\\n    slides.removeClass(params.slideVisibleClass);\\n    swiper.visibleSlidesIndexes = [];\\n    swiper.visibleSlides = [];\\n\\n    for (var i = 0; i < slides.length; i += 1) {\\n      var _slide2 = slides[i];\\n      var slideOffset = _slide2.swiperSlideOffset;\\n\\n      if (params.cssMode && params.centeredSlides) {\\n        slideOffset -= slides[0].swiperSlideOffset;\\n      }\\n\\n      var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (_slide2.swiperSlideSize + params.spaceBetween);\\n      var originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (_slide2.swiperSlideSize + params.spaceBetween);\\n      var slideBefore = -(offsetCenter - slideOffset);\\n      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];\\n      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\\n\\n      if (isVisible) {\\n        swiper.visibleSlides.push(_slide2);\\n        swiper.visibleSlidesIndexes.push(i);\\n        slides.eq(i).addClass(params.slideVisibleClass);\\n      }\\n\\n      _slide2.progress = rtl ? -slideProgress : slideProgress;\\n      _slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\\n    }\\n\\n    swiper.visibleSlides = $(swiper.visibleSlides);\\n  }\\n\\n  function updateProgress(translate) {\\n    var swiper = this;\\n\\n    if (typeof translate === 'undefined') {\\n      var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line\\n\\n      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\\n    }\\n\\n    var params = swiper.params;\\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\\n    var progress = swiper.progress,\\n        isBeginning = swiper.isBeginning,\\n        isEnd = swiper.isEnd;\\n    var wasBeginning = isBeginning;\\n    var wasEnd = isEnd;\\n\\n    if (translatesDiff === 0) {\\n      progress = 0;\\n      isBeginning = true;\\n      isEnd = true;\\n    } else {\\n      progress = (translate - swiper.minTranslate()) / translatesDiff;\\n      isBeginning = progress <= 0;\\n      isEnd = progress >= 1;\\n    }\\n\\n    Object.assign(swiper, {\\n      progress: progress,\\n      isBeginning: isBeginning,\\n      isEnd: isEnd\\n    });\\n\\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) {\\n      swiper.updateSlidesProgress(translate);\\n    }\\n\\n    if (isBeginning && !wasBeginning) {\\n      swiper.emit('reachBeginning toEdge');\\n    }\\n\\n    if (isEnd && !wasEnd) {\\n      swiper.emit('reachEnd toEdge');\\n    }\\n\\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\\n      swiper.emit('fromEdge');\\n    }\\n\\n    swiper.emit('progress', progress);\\n  }\\n\\n  function updateSlidesClasses() {\\n    var swiper = this;\\n    var slides = swiper.slides,\\n        params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl,\\n        activeIndex = swiper.activeIndex,\\n        realIndex = swiper.realIndex;\\n    var isVirtual = swiper.virtual && params.virtual.enabled;\\n    slides.removeClass(\\\"\\\".concat(params.slideActiveClass, \\\" \\\").concat(params.slideNextClass, \\\" \\\").concat(params.slidePrevClass, \\\" \\\").concat(params.slideDuplicateActiveClass, \\\" \\\").concat(params.slideDuplicateNextClass, \\\" \\\").concat(params.slideDuplicatePrevClass));\\n    var activeSlide;\\n\\n    if (isVirtual) {\\n      activeSlide = swiper.$wrapperEl.find(\\\".\\\".concat(params.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(activeIndex, \\\"\\\\\\\"]\\\"));\\n    } else {\\n      activeSlide = slides.eq(activeIndex);\\n    } // Active classes\\n\\n\\n    activeSlide.addClass(params.slideActiveClass);\\n\\n    if (params.loop) {\\n      // Duplicate to all looped slides\\n      if (activeSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\":not(.\\\").concat(params.slideDuplicateClass, \\\")[data-swiper-slide-index=\\\\\\\"\\\").concat(realIndex, \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicateActiveClass);\\n      } else {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\".\\\").concat(params.slideDuplicateClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(realIndex, \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicateActiveClass);\\n      }\\n    } // Next Slide\\n\\n\\n    var nextSlide = activeSlide.nextAll(\\\".\\\".concat(params.slideClass)).eq(0).addClass(params.slideNextClass);\\n\\n    if (params.loop && nextSlide.length === 0) {\\n      nextSlide = slides.eq(0);\\n      nextSlide.addClass(params.slideNextClass);\\n    } // Prev Slide\\n\\n\\n    var prevSlide = activeSlide.prevAll(\\\".\\\".concat(params.slideClass)).eq(0).addClass(params.slidePrevClass);\\n\\n    if (params.loop && prevSlide.length === 0) {\\n      prevSlide = slides.eq(-1);\\n      prevSlide.addClass(params.slidePrevClass);\\n    }\\n\\n    if (params.loop) {\\n      // Duplicate to all looped slides\\n      if (nextSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\":not(.\\\").concat(params.slideDuplicateClass, \\\")[data-swiper-slide-index=\\\\\\\"\\\").concat(nextSlide.attr('data-swiper-slide-index'), \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicateNextClass);\\n      } else {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\".\\\").concat(params.slideDuplicateClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(nextSlide.attr('data-swiper-slide-index'), \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicateNextClass);\\n      }\\n\\n      if (prevSlide.hasClass(params.slideDuplicateClass)) {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\":not(.\\\").concat(params.slideDuplicateClass, \\\")[data-swiper-slide-index=\\\\\\\"\\\").concat(prevSlide.attr('data-swiper-slide-index'), \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicatePrevClass);\\n      } else {\\n        $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\".\\\").concat(params.slideDuplicateClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(prevSlide.attr('data-swiper-slide-index'), \\\"\\\\\\\"]\\\")).addClass(params.slideDuplicatePrevClass);\\n      }\\n    }\\n\\n    swiper.emitSlidesClasses();\\n  }\\n\\n  function updateActiveIndex(newActiveIndex) {\\n    var swiper = this;\\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\\n    var slidesGrid = swiper.slidesGrid,\\n        snapGrid = swiper.snapGrid,\\n        params = swiper.params,\\n        previousIndex = swiper.activeIndex,\\n        previousRealIndex = swiper.realIndex,\\n        previousSnapIndex = swiper.snapIndex;\\n    var activeIndex = newActiveIndex;\\n    var snapIndex;\\n\\n    if (typeof activeIndex === 'undefined') {\\n      for (var i = 0; i < slidesGrid.length; i += 1) {\\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\\n          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\\n            activeIndex = i;\\n          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\\n            activeIndex = i + 1;\\n          }\\n        } else if (translate >= slidesGrid[i]) {\\n          activeIndex = i;\\n        }\\n      } // Normalize slideIndex\\n\\n\\n      if (params.normalizeSlideIndex) {\\n        if (activeIndex < 0 || typeof activeIndex === 'undefined') {\\n          activeIndex = 0;\\n        }\\n      }\\n    }\\n\\n    if (snapGrid.indexOf(translate) >= 0) {\\n      snapIndex = snapGrid.indexOf(translate);\\n    } else {\\n      var skip = Math.min(params.slidesPerGroupSkip, activeIndex);\\n      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\\n    }\\n\\n    if (snapIndex >= snapGrid.length) {\\n      snapIndex = snapGrid.length - 1;\\n    }\\n\\n    if (activeIndex === previousIndex) {\\n      if (snapIndex !== previousSnapIndex) {\\n        swiper.snapIndex = snapIndex;\\n        swiper.emit('snapIndexChange');\\n      }\\n\\n      return;\\n    } // Get real index\\n\\n\\n    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);\\n    Object.assign(swiper, {\\n      snapIndex: snapIndex,\\n      realIndex: realIndex,\\n      previousIndex: previousIndex,\\n      activeIndex: activeIndex\\n    });\\n    swiper.emit('activeIndexChange');\\n    swiper.emit('snapIndexChange');\\n\\n    if (previousRealIndex !== realIndex) {\\n      swiper.emit('realIndexChange');\\n    }\\n\\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\\n      swiper.emit('slideChange');\\n    }\\n  }\\n\\n  function updateClickedSlide(e) {\\n    var swiper = this;\\n    var params = swiper.params;\\n    var slide = $(e).closest(\\\".\\\".concat(params.slideClass))[0];\\n    var slideFound = false;\\n    var slideIndex;\\n\\n    if (slide) {\\n      for (var i = 0; i < swiper.slides.length; i += 1) {\\n        if (swiper.slides[i] === slide) {\\n          slideFound = true;\\n          slideIndex = i;\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (slide && slideFound) {\\n      swiper.clickedSlide = slide;\\n\\n      if (swiper.virtual && swiper.params.virtual.enabled) {\\n        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);\\n      } else {\\n        swiper.clickedIndex = slideIndex;\\n      }\\n    } else {\\n      swiper.clickedSlide = undefined;\\n      swiper.clickedIndex = undefined;\\n      return;\\n    }\\n\\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\\n      swiper.slideToClickedSlide();\\n    }\\n  }\\n\\n  var update = {\\n    updateSize: updateSize,\\n    updateSlides: updateSlides,\\n    updateAutoHeight: updateAutoHeight,\\n    updateSlidesOffset: updateSlidesOffset,\\n    updateSlidesProgress: updateSlidesProgress,\\n    updateProgress: updateProgress,\\n    updateSlidesClasses: updateSlidesClasses,\\n    updateActiveIndex: updateActiveIndex,\\n    updateClickedSlide: updateClickedSlide\\n  };\\n\\n  function getSwiperTranslate() {\\n    var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isHorizontal() ? 'x' : 'y';\\n    var swiper = this;\\n    var params = swiper.params,\\n        rtl = swiper.rtlTranslate,\\n        translate = swiper.translate,\\n        $wrapperEl = swiper.$wrapperEl;\\n\\n    if (params.virtualTranslate) {\\n      return rtl ? -translate : translate;\\n    }\\n\\n    if (params.cssMode) {\\n      return translate;\\n    }\\n\\n    var currentTranslate = getTranslate($wrapperEl[0], axis);\\n\\n    if (rtl) {\\n      currentTranslate = -currentTranslate;\\n    }\\n\\n    return currentTranslate || 0;\\n  }\\n\\n  function setTranslate(translate, byController) {\\n    var swiper = this;\\n    var rtl = swiper.rtlTranslate,\\n        params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl,\\n        wrapperEl = swiper.wrapperEl,\\n        progress = swiper.progress;\\n    var x = 0;\\n    var y = 0;\\n    var z = 0;\\n\\n    if (swiper.isHorizontal()) {\\n      x = rtl ? -translate : translate;\\n    } else {\\n      y = translate;\\n    }\\n\\n    if (params.roundLengths) {\\n      x = Math.floor(x);\\n      y = Math.floor(y);\\n    }\\n\\n    if (params.cssMode) {\\n      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\\n    } else if (!params.virtualTranslate) {\\n      $wrapperEl.transform(\\\"translate3d(\\\".concat(x, \\\"px, \\\").concat(y, \\\"px, \\\").concat(z, \\\"px)\\\"));\\n    }\\n\\n    swiper.previousTranslate = swiper.translate;\\n    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress\\n\\n    var newProgress;\\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\\n\\n    if (translatesDiff === 0) {\\n      newProgress = 0;\\n    } else {\\n      newProgress = (translate - swiper.minTranslate()) / translatesDiff;\\n    }\\n\\n    if (newProgress !== progress) {\\n      swiper.updateProgress(translate);\\n    }\\n\\n    swiper.emit('setTranslate', swiper.translate, byController);\\n  }\\n\\n  function minTranslate() {\\n    return -this.snapGrid[0];\\n  }\\n\\n  function maxTranslate() {\\n    return -this.snapGrid[this.snapGrid.length - 1];\\n  }\\n\\n  function translateTo() {\\n    var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n    var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;\\n    var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n    var translateBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\\n    var internal = arguments.length > 4 ? arguments[4] : undefined;\\n    var swiper = this;\\n    var params = swiper.params,\\n        wrapperEl = swiper.wrapperEl;\\n\\n    if (swiper.animating && params.preventInteractionOnTransition) {\\n      return false;\\n    }\\n\\n    var minTranslate = swiper.minTranslate();\\n    var maxTranslate = swiper.maxTranslate();\\n    var newTranslate;\\n\\n    if (translateBounds && translate > minTranslate) {\\n      newTranslate = minTranslate;\\n    } else if (translateBounds && translate < maxTranslate) {\\n      newTranslate = maxTranslate;\\n    } else {\\n      newTranslate = translate;\\n    } // Update progress\\n\\n\\n    swiper.updateProgress(newTranslate);\\n\\n    if (params.cssMode) {\\n      var isH = swiper.isHorizontal();\\n\\n      if (speed === 0) {\\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\\n      } else {\\n        var _wrapperEl$scrollTo;\\n\\n        if (!swiper.support.smoothScroll) {\\n          animateCSSModeScroll({\\n            swiper: swiper,\\n            targetPosition: -newTranslate,\\n            side: isH ? 'left' : 'top'\\n          });\\n          return true;\\n        }\\n\\n        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', -newTranslate), _defineProperty(_wrapperEl$scrollTo, \\\"behavior\\\", 'smooth'), _wrapperEl$scrollTo));\\n      }\\n\\n      return true;\\n    }\\n\\n    if (speed === 0) {\\n      swiper.setTransition(0);\\n      swiper.setTranslate(newTranslate);\\n\\n      if (runCallbacks) {\\n        swiper.emit('beforeTransitionStart', speed, internal);\\n        swiper.emit('transitionEnd');\\n      }\\n    } else {\\n      swiper.setTransition(speed);\\n      swiper.setTranslate(newTranslate);\\n\\n      if (runCallbacks) {\\n        swiper.emit('beforeTransitionStart', speed, internal);\\n        swiper.emit('transitionStart');\\n      }\\n\\n      if (!swiper.animating) {\\n        swiper.animating = true;\\n\\n        if (!swiper.onTranslateToWrapperTransitionEnd) {\\n          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\\n            if (!swiper || swiper.destroyed) {\\n              return;\\n            }\\n\\n            if (e.target !== this) {\\n              return;\\n            }\\n\\n            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\\n            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\\n            swiper.onTranslateToWrapperTransitionEnd = null;\\n            delete swiper.onTranslateToWrapperTransitionEnd;\\n\\n            if (runCallbacks) {\\n              swiper.emit('transitionEnd');\\n            }\\n          };\\n        }\\n\\n        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\\n        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  var translate = {\\n    getTranslate: getSwiperTranslate,\\n    setTranslate: setTranslate,\\n    minTranslate: minTranslate,\\n    maxTranslate: maxTranslate,\\n    translateTo: translateTo\\n  };\\n\\n  function setTransition(duration, byController) {\\n    var swiper = this;\\n\\n    if (!swiper.params.cssMode) {\\n      swiper.$wrapperEl.transition(duration);\\n    }\\n\\n    swiper.emit('setTransition', duration, byController);\\n  }\\n\\n  function transitionEmit(_ref6) {\\n    var swiper = _ref6.swiper,\\n        runCallbacks = _ref6.runCallbacks,\\n        direction = _ref6.direction,\\n        step = _ref6.step;\\n    var activeIndex = swiper.activeIndex,\\n        previousIndex = swiper.previousIndex;\\n    var dir = direction;\\n\\n    if (!dir) {\\n      if (activeIndex > previousIndex) {\\n        dir = 'next';\\n      } else if (activeIndex < previousIndex) {\\n        dir = 'prev';\\n      } else {\\n        dir = 'reset';\\n      }\\n    }\\n\\n    swiper.emit(\\\"transition\\\".concat(step));\\n\\n    if (runCallbacks && activeIndex !== previousIndex) {\\n      if (dir === 'reset') {\\n        swiper.emit(\\\"slideResetTransition\\\".concat(step));\\n        return;\\n      }\\n\\n      swiper.emit(\\\"slideChangeTransition\\\".concat(step));\\n\\n      if (dir === 'next') {\\n        swiper.emit(\\\"slideNextTransition\\\".concat(step));\\n      } else {\\n        swiper.emit(\\\"slidePrevTransition\\\".concat(step));\\n      }\\n    }\\n  }\\n\\n  function transitionStart() {\\n    var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n    var direction = arguments.length > 1 ? arguments[1] : undefined;\\n    var swiper = this;\\n    var params = swiper.params;\\n\\n    if (params.cssMode) {\\n      return;\\n    }\\n\\n    if (params.autoHeight) {\\n      swiper.updateAutoHeight();\\n    }\\n\\n    transitionEmit({\\n      swiper: swiper,\\n      runCallbacks: runCallbacks,\\n      direction: direction,\\n      step: 'Start'\\n    });\\n  }\\n\\n  function transitionEnd() {\\n    var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n    var direction = arguments.length > 1 ? arguments[1] : undefined;\\n    var swiper = this;\\n    var params = swiper.params;\\n    swiper.animating = false;\\n\\n    if (params.cssMode) {\\n      return;\\n    }\\n\\n    swiper.setTransition(0);\\n    transitionEmit({\\n      swiper: swiper,\\n      runCallbacks: runCallbacks,\\n      direction: direction,\\n      step: 'End'\\n    });\\n  }\\n\\n  var transition = {\\n    setTransition: setTransition,\\n    transitionStart: transitionStart,\\n    transitionEnd: transitionEnd\\n  };\\n\\n  function slideTo() {\\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n    var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;\\n    var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n    var internal = arguments.length > 3 ? arguments[3] : undefined;\\n    var initial = arguments.length > 4 ? arguments[4] : undefined;\\n\\n    if (typeof index !== 'number' && typeof index !== 'string') {\\n      throw new Error(\\\"The 'index' argument cannot have type other than 'number' or 'string'. [\\\".concat(_typeof(index), \\\"] given.\\\"));\\n    }\\n\\n    if (typeof index === 'string') {\\n      /**\\n       * The `index` argument converted from `string` to `number`.\\n       * @type {number}\\n       */\\n      var indexAsNumber = parseInt(index, 10);\\n      /**\\n       * Determines whether the `index` argument is a valid `number`\\n       * after being converted from the `string` type.\\n       * @type {boolean}\\n       */\\n\\n      var isValidNumber = isFinite(indexAsNumber);\\n\\n      if (!isValidNumber) {\\n        throw new Error(\\\"The passed-in 'index' (string) couldn't be converted to 'number'. [\\\".concat(index, \\\"] given.\\\"));\\n      } // Knowing that the converted `index` is a valid number,\\n      // we can update the original argument's value.\\n\\n\\n      index = indexAsNumber;\\n    }\\n\\n    var swiper = this;\\n    var slideIndex = index;\\n\\n    if (slideIndex < 0) {\\n      slideIndex = 0;\\n    }\\n\\n    var params = swiper.params,\\n        snapGrid = swiper.snapGrid,\\n        slidesGrid = swiper.slidesGrid,\\n        previousIndex = swiper.previousIndex,\\n        activeIndex = swiper.activeIndex,\\n        rtl = swiper.rtlTranslate,\\n        wrapperEl = swiper.wrapperEl,\\n        enabled = swiper.enabled;\\n\\n    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\\n      return false;\\n    }\\n\\n    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\\n    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\\n\\n    if (snapIndex >= snapGrid.length) {\\n      snapIndex = snapGrid.length - 1;\\n    }\\n\\n    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\\n      swiper.emit('beforeSlideChangeStart');\\n    }\\n\\n    var translate = -snapGrid[snapIndex]; // Update progress\\n\\n    swiper.updateProgress(translate); // Normalize slideIndex\\n\\n    if (params.normalizeSlideIndex) {\\n      for (var i = 0; i < slidesGrid.length; i += 1) {\\n        var normalizedTranslate = -Math.floor(translate * 100);\\n        var normalizedGrid = Math.floor(slidesGrid[i] * 100);\\n        var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\\n\\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\\n          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\\n            slideIndex = i;\\n          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\\n            slideIndex = i + 1;\\n          }\\n        } else if (normalizedTranslate >= normalizedGrid) {\\n          slideIndex = i;\\n        }\\n      }\\n    } // Directions locks\\n\\n\\n    if (swiper.initialized && slideIndex !== activeIndex) {\\n      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\\n        return false;\\n      }\\n\\n      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\\n        if ((activeIndex || 0) !== slideIndex) {\\n          return false;\\n        }\\n      }\\n    }\\n\\n    var direction;\\n\\n    if (slideIndex > activeIndex) {\\n      direction = 'next';\\n    } else if (slideIndex < activeIndex) {\\n      direction = 'prev';\\n    } else {\\n      direction = 'reset';\\n    } // Update Index\\n\\n\\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\\n      swiper.updateActiveIndex(slideIndex); // Update Height\\n\\n      if (params.autoHeight) {\\n        swiper.updateAutoHeight();\\n      }\\n\\n      swiper.updateSlidesClasses();\\n\\n      if (params.effect !== 'slide') {\\n        swiper.setTranslate(translate);\\n      }\\n\\n      if (direction !== 'reset') {\\n        swiper.transitionStart(runCallbacks, direction);\\n        swiper.transitionEnd(runCallbacks, direction);\\n      }\\n\\n      return false;\\n    }\\n\\n    if (params.cssMode) {\\n      var isH = swiper.isHorizontal();\\n      var t = rtl ? translate : -translate;\\n\\n      if (speed === 0) {\\n        var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n\\n        if (isVirtual) {\\n          swiper.wrapperEl.style.scrollSnapType = 'none';\\n          swiper._immediateVirtual = true;\\n        }\\n\\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\\n\\n        if (isVirtual) {\\n          requestAnimationFrame(function () {\\n            swiper.wrapperEl.style.scrollSnapType = '';\\n            swiper._swiperImmediateVirtual = false;\\n          });\\n        }\\n      } else {\\n        var _wrapperEl$scrollTo2;\\n\\n        if (!swiper.support.smoothScroll) {\\n          animateCSSModeScroll({\\n            swiper: swiper,\\n            targetPosition: t,\\n            side: isH ? 'left' : 'top'\\n          });\\n          return true;\\n        }\\n\\n        wrapperEl.scrollTo((_wrapperEl$scrollTo2 = {}, _defineProperty(_wrapperEl$scrollTo2, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo2, \\\"behavior\\\", 'smooth'), _wrapperEl$scrollTo2));\\n      }\\n\\n      return true;\\n    }\\n\\n    if (speed === 0) {\\n      swiper.setTransition(0);\\n      swiper.setTranslate(translate);\\n      swiper.updateActiveIndex(slideIndex);\\n      swiper.updateSlidesClasses();\\n      swiper.emit('beforeTransitionStart', speed, internal);\\n      swiper.transitionStart(runCallbacks, direction);\\n      swiper.transitionEnd(runCallbacks, direction);\\n    } else {\\n      swiper.setTransition(speed);\\n      swiper.setTranslate(translate);\\n      swiper.updateActiveIndex(slideIndex);\\n      swiper.updateSlidesClasses();\\n      swiper.emit('beforeTransitionStart', speed, internal);\\n      swiper.transitionStart(runCallbacks, direction);\\n\\n      if (!swiper.animating) {\\n        swiper.animating = true;\\n\\n        if (!swiper.onSlideToWrapperTransitionEnd) {\\n          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\\n            if (!swiper || swiper.destroyed) {\\n              return;\\n            }\\n\\n            if (e.target !== this) {\\n              return;\\n            }\\n\\n            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\\n            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\\n            swiper.onSlideToWrapperTransitionEnd = null;\\n            delete swiper.onSlideToWrapperTransitionEnd;\\n            swiper.transitionEnd(runCallbacks, direction);\\n          };\\n        }\\n\\n        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\\n        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\\n      }\\n    }\\n\\n    return true;\\n  }\\n\\n  function slideToLoop() {\\n    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\\n    var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;\\n    var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\\n    var internal = arguments.length > 3 ? arguments[3] : undefined;\\n    var swiper = this;\\n    var newIndex = index;\\n\\n    if (swiper.params.loop) {\\n      newIndex += swiper.loopedSlides;\\n    }\\n\\n    return swiper.slideTo(newIndex, speed, runCallbacks, internal);\\n  }\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n\\n\\n  function slideNext() {\\n    var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;\\n    var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n    var internal = arguments.length > 2 ? arguments[2] : undefined;\\n    var swiper = this;\\n    var animating = swiper.animating,\\n        enabled = swiper.enabled,\\n        params = swiper.params;\\n\\n    if (!enabled) {\\n      return swiper;\\n    }\\n\\n    var perGroup = params.slidesPerGroup;\\n\\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\\n      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\\n    }\\n\\n    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\\n\\n    if (params.loop) {\\n      if (animating && params.loopPreventsSlide) {\\n        return false;\\n      }\\n\\n      swiper.loopFix(); // eslint-disable-next-line\\n\\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n    }\\n\\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\\n  }\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n\\n\\n  function slidePrev() {\\n    var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;\\n    var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n    var internal = arguments.length > 2 ? arguments[2] : undefined;\\n    var swiper = this;\\n    var params = swiper.params,\\n        animating = swiper.animating,\\n        snapGrid = swiper.snapGrid,\\n        slidesGrid = swiper.slidesGrid,\\n        rtlTranslate = swiper.rtlTranslate,\\n        enabled = swiper.enabled;\\n\\n    if (!enabled) {\\n      return swiper;\\n    }\\n\\n    if (params.loop) {\\n      if (animating && params.loopPreventsSlide) {\\n        return false;\\n      }\\n\\n      swiper.loopFix(); // eslint-disable-next-line\\n\\n      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n    }\\n\\n    var translate = rtlTranslate ? swiper.translate : -swiper.translate;\\n\\n    function normalize(val) {\\n      if (val < 0) {\\n        return -Math.floor(Math.abs(val));\\n      }\\n\\n      return Math.floor(val);\\n    }\\n\\n    var normalizedTranslate = normalize(translate);\\n    var normalizedSnapGrid = snapGrid.map(function (val) {\\n      return normalize(val);\\n    });\\n    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\\n\\n    if (typeof prevSnap === 'undefined' && params.cssMode) {\\n      var prevSnapIndex;\\n      snapGrid.forEach(function (snap, snapIndex) {\\n        if (normalizedTranslate >= snap) {\\n          // prevSnap = snap;\\n          prevSnapIndex = snapIndex;\\n        }\\n      });\\n\\n      if (typeof prevSnapIndex !== 'undefined') {\\n        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\\n      }\\n    }\\n\\n    var prevIndex = 0;\\n\\n    if (typeof prevSnap !== 'undefined') {\\n      prevIndex = slidesGrid.indexOf(prevSnap);\\n\\n      if (prevIndex < 0) {\\n        prevIndex = swiper.activeIndex - 1;\\n      }\\n\\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\\n        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\\n        prevIndex = Math.max(prevIndex, 0);\\n      }\\n    }\\n\\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\\n  }\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n\\n\\n  function slideReset() {\\n    var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;\\n    var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n    var internal = arguments.length > 2 ? arguments[2] : undefined;\\n    var swiper = this;\\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\\n  }\\n  /* eslint no-unused-vars: \\\"off\\\" */\\n\\n\\n  function slideToClosest() {\\n    var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;\\n    var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n    var internal = arguments.length > 2 ? arguments[2] : undefined;\\n    var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\\n    var swiper = this;\\n    var index = swiper.activeIndex;\\n    var skip = Math.min(swiper.params.slidesPerGroupSkip, index);\\n    var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\\n    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\\n\\n    if (translate >= swiper.snapGrid[snapIndex]) {\\n      // The current translate is on or after the current snap index, so the choice\\n      // is between the current index and the one after it.\\n      var currentSnap = swiper.snapGrid[snapIndex];\\n      var nextSnap = swiper.snapGrid[snapIndex + 1];\\n\\n      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\\n        index += swiper.params.slidesPerGroup;\\n      }\\n    } else {\\n      // The current translate is before the current snap index, so the choice\\n      // is between the current index and the one before it.\\n      var prevSnap = swiper.snapGrid[snapIndex - 1];\\n      var _currentSnap = swiper.snapGrid[snapIndex];\\n\\n      if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {\\n        index -= swiper.params.slidesPerGroup;\\n      }\\n    }\\n\\n    index = Math.max(index, 0);\\n    index = Math.min(index, swiper.slidesGrid.length - 1);\\n    return swiper.slideTo(index, speed, runCallbacks, internal);\\n  }\\n\\n  function slideToClickedSlide() {\\n    var swiper = this;\\n    var params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl;\\n    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\\n    var slideToIndex = swiper.clickedIndex;\\n    var realIndex;\\n\\n    if (params.loop) {\\n      if (swiper.animating) {\\n        return;\\n      }\\n\\n      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);\\n\\n      if (params.centeredSlides) {\\n        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\\n          swiper.loopFix();\\n          slideToIndex = $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(realIndex, \\\"\\\\\\\"]:not(.\\\").concat(params.slideDuplicateClass, \\\")\\\")).eq(0).index();\\n          nextTick(function () {\\n            swiper.slideTo(slideToIndex);\\n          });\\n        } else {\\n          swiper.slideTo(slideToIndex);\\n        }\\n      } else if (slideToIndex > swiper.slides.length - slidesPerView) {\\n        swiper.loopFix();\\n        slideToIndex = $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(realIndex, \\\"\\\\\\\"]:not(.\\\").concat(params.slideDuplicateClass, \\\")\\\")).eq(0).index();\\n        nextTick(function () {\\n          swiper.slideTo(slideToIndex);\\n        });\\n      } else {\\n        swiper.slideTo(slideToIndex);\\n      }\\n    } else {\\n      swiper.slideTo(slideToIndex);\\n    }\\n  }\\n\\n  var slide = {\\n    slideTo: slideTo,\\n    slideToLoop: slideToLoop,\\n    slideNext: slideNext,\\n    slidePrev: slidePrev,\\n    slideReset: slideReset,\\n    slideToClosest: slideToClosest,\\n    slideToClickedSlide: slideToClickedSlide\\n  };\\n\\n  function loopCreate() {\\n    var swiper = this;\\n    var document = getDocument();\\n    var params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides\\n\\n    var $selector = $wrapperEl.children().length > 0 ? $($wrapperEl.children()[0].parentNode) : $wrapperEl;\\n    $selector.children(\\\".\\\".concat(params.slideClass, \\\".\\\").concat(params.slideDuplicateClass)).remove();\\n    var slides = $selector.children(\\\".\\\".concat(params.slideClass));\\n\\n    if (params.loopFillGroupWithBlank) {\\n      var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;\\n\\n      if (blankSlidesNum !== params.slidesPerGroup) {\\n        for (var i = 0; i < blankSlidesNum; i += 1) {\\n          var blankNode = $(document.createElement('div')).addClass(\\\"\\\".concat(params.slideClass, \\\" \\\").concat(params.slideBlankClass));\\n          $selector.append(blankNode);\\n        }\\n\\n        slides = $selector.children(\\\".\\\".concat(params.slideClass));\\n      }\\n    }\\n\\n    if (params.slidesPerView === 'auto' && !params.loopedSlides) {\\n      params.loopedSlides = slides.length;\\n    }\\n\\n    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));\\n    swiper.loopedSlides += params.loopAdditionalSlides;\\n\\n    if (swiper.loopedSlides > slides.length) {\\n      swiper.loopedSlides = slides.length;\\n    }\\n\\n    var prependSlides = [];\\n    var appendSlides = [];\\n    slides.each(function (el, index) {\\n      var slide = $(el);\\n\\n      if (index < swiper.loopedSlides) {\\n        appendSlides.push(el);\\n      }\\n\\n      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {\\n        prependSlides.push(el);\\n      }\\n\\n      slide.attr('data-swiper-slide-index', index);\\n    });\\n\\n    for (var _i2 = 0; _i2 < appendSlides.length; _i2 += 1) {\\n      $selector.append($(appendSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));\\n    }\\n\\n    for (var _i3 = prependSlides.length - 1; _i3 >= 0; _i3 -= 1) {\\n      $selector.prepend($(prependSlides[_i3].cloneNode(true)).addClass(params.slideDuplicateClass));\\n    }\\n  }\\n\\n  function loopFix() {\\n    var swiper = this;\\n    swiper.emit('beforeLoopFix');\\n    var activeIndex = swiper.activeIndex,\\n        slides = swiper.slides,\\n        loopedSlides = swiper.loopedSlides,\\n        allowSlidePrev = swiper.allowSlidePrev,\\n        allowSlideNext = swiper.allowSlideNext,\\n        snapGrid = swiper.snapGrid,\\n        rtl = swiper.rtlTranslate;\\n    var newIndex;\\n    swiper.allowSlidePrev = true;\\n    swiper.allowSlideNext = true;\\n    var snapTranslate = -snapGrid[activeIndex];\\n    var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding\\n\\n    if (activeIndex < loopedSlides) {\\n      newIndex = slides.length - loopedSlides * 3 + activeIndex;\\n      newIndex += loopedSlides;\\n      var slideChanged = swiper.slideTo(newIndex, 0, false, true);\\n\\n      if (slideChanged && diff !== 0) {\\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\\n      }\\n    } else if (activeIndex >= slides.length - loopedSlides) {\\n      // Fix For Positive Oversliding\\n      newIndex = -slides.length + activeIndex + loopedSlides;\\n      newIndex += loopedSlides;\\n\\n      var _slideChanged = swiper.slideTo(newIndex, 0, false, true);\\n\\n      if (_slideChanged && diff !== 0) {\\n        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);\\n      }\\n    }\\n\\n    swiper.allowSlidePrev = allowSlidePrev;\\n    swiper.allowSlideNext = allowSlideNext;\\n    swiper.emit('loopFix');\\n  }\\n\\n  function loopDestroy() {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl,\\n        params = swiper.params,\\n        slides = swiper.slides;\\n    $wrapperEl.children(\\\".\\\".concat(params.slideClass, \\\".\\\").concat(params.slideDuplicateClass, \\\",.\\\").concat(params.slideClass, \\\".\\\").concat(params.slideBlankClass)).remove();\\n    slides.removeAttr('data-swiper-slide-index');\\n  }\\n\\n  var loop = {\\n    loopCreate: loopCreate,\\n    loopFix: loopFix,\\n    loopDestroy: loopDestroy\\n  };\\n\\n  function setGrabCursor(moving) {\\n    var swiper = this;\\n\\n    if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\\n      return;\\n    }\\n\\n    var el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\\n    el.style.cursor = 'move';\\n    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';\\n    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';\\n    el.style.cursor = moving ? 'grabbing' : 'grab';\\n  }\\n\\n  function unsetGrabCursor() {\\n    var swiper = this;\\n\\n    if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\\n      return;\\n    }\\n\\n    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\\n  }\\n\\n  var grabCursor = {\\n    setGrabCursor: setGrabCursor,\\n    unsetGrabCursor: unsetGrabCursor\\n  };\\n\\n  function closestElement(selector) {\\n    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this;\\n\\n    function __closestFrom(el) {\\n      if (!el || el === getDocument() || el === getWindow()) {\\n        return null;\\n      }\\n\\n      if (el.assignedSlot) {\\n        el = el.assignedSlot;\\n      }\\n\\n      var found = el.closest(selector);\\n      return found || __closestFrom(el.getRootNode().host);\\n    }\\n\\n    return __closestFrom(base);\\n  }\\n\\n  function onTouchStart(event) {\\n    var swiper = this;\\n    var document = getDocument();\\n    var window = getWindow();\\n    var data = swiper.touchEventsData;\\n    var params = swiper.params,\\n        touches = swiper.touches,\\n        enabled = swiper.enabled;\\n\\n    if (!enabled) {\\n      return;\\n    }\\n\\n    if (swiper.animating && params.preventInteractionOnTransition) {\\n      return;\\n    }\\n\\n    if (!swiper.animating && params.cssMode && params.loop) {\\n      swiper.loopFix();\\n    }\\n\\n    var e = event;\\n\\n    if (e.originalEvent) {\\n      e = e.originalEvent;\\n    }\\n\\n    var $targetEl = $(e.target);\\n\\n    if (params.touchEventsTarget === 'wrapper') {\\n      if (!$targetEl.closest(swiper.wrapperEl).length) {\\n        return;\\n      }\\n    }\\n\\n    data.isTouchEvent = e.type === 'touchstart';\\n\\n    if (!data.isTouchEvent && 'which' in e && e.which === 3) {\\n      return;\\n    }\\n\\n    if (!data.isTouchEvent && 'button' in e && e.button > 0) {\\n      return;\\n    }\\n\\n    if (data.isTouched && data.isMoved) {\\n      return;\\n    } // change target el for shadow root component\\n\\n\\n    var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\\n\\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {\\n      $targetEl = $(event.path[0]);\\n    }\\n\\n    var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : \\\".\\\".concat(params.noSwipingClass);\\n    var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element\\n\\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {\\n      swiper.allowClick = true;\\n      return;\\n    }\\n\\n    if (params.swipeHandler) {\\n      if (!$targetEl.closest(params.swipeHandler)[0]) {\\n        return;\\n      }\\n    }\\n\\n    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\\n    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\\n    var startX = touches.currentX;\\n    var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\\n\\n    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\\n    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\\n\\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\\n      if (edgeSwipeDetection === 'prevent') {\\n        event.preventDefault();\\n      } else {\\n        return;\\n      }\\n    }\\n\\n    Object.assign(data, {\\n      isTouched: true,\\n      isMoved: false,\\n      allowTouchCallbacks: true,\\n      isScrolling: undefined,\\n      startMoving: undefined\\n    });\\n    touches.startX = startX;\\n    touches.startY = startY;\\n    data.touchStartTime = now();\\n    swiper.allowClick = true;\\n    swiper.updateSize();\\n    swiper.swipeDirection = undefined;\\n\\n    if (params.threshold > 0) {\\n      data.allowThresholdMove = false;\\n    }\\n\\n    if (e.type !== 'touchstart') {\\n      var preventDefault = true;\\n\\n      if ($targetEl.is(data.focusableElements)) {\\n        preventDefault = false;\\n      }\\n\\n      if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {\\n        document.activeElement.blur();\\n      }\\n\\n      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\\n\\n      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {\\n        e.preventDefault();\\n      }\\n    }\\n\\n    swiper.emit('touchStart', e);\\n  }\\n\\n  function onTouchMove(event) {\\n    var document = getDocument();\\n    var swiper = this;\\n    var data = swiper.touchEventsData;\\n    var params = swiper.params,\\n        touches = swiper.touches,\\n        rtl = swiper.rtlTranslate,\\n        enabled = swiper.enabled;\\n\\n    if (!enabled) {\\n      return;\\n    }\\n\\n    var e = event;\\n\\n    if (e.originalEvent) {\\n      e = e.originalEvent;\\n    }\\n\\n    if (!data.isTouched) {\\n      if (data.startMoving && data.isScrolling) {\\n        swiper.emit('touchMoveOpposite', e);\\n      }\\n\\n      return;\\n    }\\n\\n    if (data.isTouchEvent && e.type !== 'touchmove') {\\n      return;\\n    }\\n\\n    var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);\\n    var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;\\n    var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;\\n\\n    if (e.preventedByNestedSwiper) {\\n      touches.startX = pageX;\\n      touches.startY = pageY;\\n      return;\\n    }\\n\\n    if (!swiper.allowTouchMove) {\\n      // isMoved = true;\\n      swiper.allowClick = false;\\n\\n      if (data.isTouched) {\\n        Object.assign(touches, {\\n          startX: pageX,\\n          startY: pageY,\\n          currentX: pageX,\\n          currentY: pageY\\n        });\\n        data.touchStartTime = now();\\n      }\\n\\n      return;\\n    }\\n\\n    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {\\n      if (swiper.isVertical()) {\\n        // Vertical\\n        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\\n          data.isTouched = false;\\n          data.isMoved = false;\\n          return;\\n        }\\n      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\\n        return;\\n      }\\n    }\\n\\n    if (data.isTouchEvent && document.activeElement) {\\n      if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {\\n        data.isMoved = true;\\n        swiper.allowClick = false;\\n        return;\\n      }\\n    }\\n\\n    if (data.allowTouchCallbacks) {\\n      swiper.emit('touchMove', e);\\n    }\\n\\n    if (e.targetTouches && e.targetTouches.length > 1) {\\n      return;\\n    }\\n\\n    touches.currentX = pageX;\\n    touches.currentY = pageY;\\n    var diffX = touches.currentX - touches.startX;\\n    var diffY = touches.currentY - touches.startY;\\n\\n    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) {\\n      return;\\n    }\\n\\n    if (typeof data.isScrolling === 'undefined') {\\n      var touchAngle;\\n\\n      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\\n        data.isScrolling = false;\\n      } else {\\n        // eslint-disable-next-line\\n        if (diffX * diffX + diffY * diffY >= 25) {\\n          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\\n          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\\n        }\\n      }\\n    }\\n\\n    if (data.isScrolling) {\\n      swiper.emit('touchMoveOpposite', e);\\n    }\\n\\n    if (typeof data.startMoving === 'undefined') {\\n      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\\n        data.startMoving = true;\\n      }\\n    }\\n\\n    if (data.isScrolling) {\\n      data.isTouched = false;\\n      return;\\n    }\\n\\n    if (!data.startMoving) {\\n      return;\\n    }\\n\\n    swiper.allowClick = false;\\n\\n    if (!params.cssMode && e.cancelable) {\\n      e.preventDefault();\\n    }\\n\\n    if (params.touchMoveStopPropagation && !params.nested) {\\n      e.stopPropagation();\\n    }\\n\\n    if (!data.isMoved) {\\n      if (params.loop && !params.cssMode) {\\n        swiper.loopFix();\\n      }\\n\\n      data.startTranslate = swiper.getTranslate();\\n      swiper.setTransition(0);\\n\\n      if (swiper.animating) {\\n        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');\\n      }\\n\\n      data.allowMomentumBounce = false; // Grab Cursor\\n\\n      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\\n        swiper.setGrabCursor(true);\\n      }\\n\\n      swiper.emit('sliderFirstMove', e);\\n    }\\n\\n    swiper.emit('sliderMove', e);\\n    data.isMoved = true;\\n    var diff = swiper.isHorizontal() ? diffX : diffY;\\n    touches.diff = diff;\\n    diff *= params.touchRatio;\\n\\n    if (rtl) {\\n      diff = -diff;\\n    }\\n\\n    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\\n    data.currentTranslate = diff + data.startTranslate;\\n    var disableParentSwiper = true;\\n    var resistanceRatio = params.resistanceRatio;\\n\\n    if (params.touchReleaseOnEdges) {\\n      resistanceRatio = 0;\\n    }\\n\\n    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {\\n      disableParentSwiper = false;\\n\\n      if (params.resistance) {\\n        data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);\\n      }\\n    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {\\n      disableParentSwiper = false;\\n\\n      if (params.resistance) {\\n        data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);\\n      }\\n    }\\n\\n    if (disableParentSwiper) {\\n      e.preventedByNestedSwiper = true;\\n    } // Directions locks\\n\\n\\n    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\\n      data.currentTranslate = data.startTranslate;\\n    }\\n\\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\\n      data.currentTranslate = data.startTranslate;\\n    }\\n\\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\\n      data.currentTranslate = data.startTranslate;\\n    } // Threshold\\n\\n\\n    if (params.threshold > 0) {\\n      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\\n        if (!data.allowThresholdMove) {\\n          data.allowThresholdMove = true;\\n          touches.startX = touches.currentX;\\n          touches.startY = touches.currentY;\\n          data.currentTranslate = data.startTranslate;\\n          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\\n          return;\\n        }\\n      } else {\\n        data.currentTranslate = data.startTranslate;\\n        return;\\n      }\\n    }\\n\\n    if (!params.followFinger || params.cssMode) {\\n      return;\\n    } // Update active index in free mode\\n\\n\\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\\n      swiper.updateActiveIndex();\\n      swiper.updateSlidesClasses();\\n    }\\n\\n    if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) {\\n      swiper.freeMode.onTouchMove();\\n    } // Update progress\\n\\n\\n    swiper.updateProgress(data.currentTranslate); // Update translate\\n\\n    swiper.setTranslate(data.currentTranslate);\\n  }\\n\\n  function onTouchEnd(event) {\\n    var swiper = this;\\n    var data = swiper.touchEventsData;\\n    var params = swiper.params,\\n        touches = swiper.touches,\\n        rtl = swiper.rtlTranslate,\\n        slidesGrid = swiper.slidesGrid,\\n        enabled = swiper.enabled;\\n\\n    if (!enabled) {\\n      return;\\n    }\\n\\n    var e = event;\\n\\n    if (e.originalEvent) {\\n      e = e.originalEvent;\\n    }\\n\\n    if (data.allowTouchCallbacks) {\\n      swiper.emit('touchEnd', e);\\n    }\\n\\n    data.allowTouchCallbacks = false;\\n\\n    if (!data.isTouched) {\\n      if (data.isMoved && params.grabCursor) {\\n        swiper.setGrabCursor(false);\\n      }\\n\\n      data.isMoved = false;\\n      data.startMoving = false;\\n      return;\\n    } // Return Grab Cursor\\n\\n\\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\\n      swiper.setGrabCursor(false);\\n    } // Time diff\\n\\n\\n    var touchEndTime = now();\\n    var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\\n\\n    if (swiper.allowClick) {\\n      var pathTree = e.path || e.composedPath && e.composedPath();\\n      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\\n      swiper.emit('tap click', e);\\n\\n      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\\n        swiper.emit('doubleTap doubleClick', e);\\n      }\\n    }\\n\\n    data.lastClickTime = now();\\n    nextTick(function () {\\n      if (!swiper.destroyed) {\\n        swiper.allowClick = true;\\n      }\\n    });\\n\\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\\n      data.isTouched = false;\\n      data.isMoved = false;\\n      data.startMoving = false;\\n      return;\\n    }\\n\\n    data.isTouched = false;\\n    data.isMoved = false;\\n    data.startMoving = false;\\n    var currentPos;\\n\\n    if (params.followFinger) {\\n      currentPos = rtl ? swiper.translate : -swiper.translate;\\n    } else {\\n      currentPos = -data.currentTranslate;\\n    }\\n\\n    if (params.cssMode) {\\n      return;\\n    }\\n\\n    if (swiper.params.freeMode && params.freeMode.enabled) {\\n      swiper.freeMode.onTouchEnd({\\n        currentPos: currentPos\\n      });\\n      return;\\n    } // Find current slide\\n\\n\\n    var stopIndex = 0;\\n    var groupSize = swiper.slidesSizesGrid[0];\\n\\n    for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\\n      var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\\n\\n      if (typeof slidesGrid[i + _increment] !== 'undefined') {\\n        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {\\n          stopIndex = i;\\n          groupSize = slidesGrid[i + _increment] - slidesGrid[i];\\n        }\\n      } else if (currentPos >= slidesGrid[i]) {\\n        stopIndex = i;\\n        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\\n      }\\n    } // Find current slide size\\n\\n\\n    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\\n    var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\\n\\n    if (timeDiff > params.longSwipesMs) {\\n      // Long touches\\n      if (!params.longSwipes) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n\\n      if (swiper.swipeDirection === 'next') {\\n        if (ratio >= params.longSwipesRatio) {\\n          swiper.slideTo(stopIndex + increment);\\n        } else {\\n          swiper.slideTo(stopIndex);\\n        }\\n      }\\n\\n      if (swiper.swipeDirection === 'prev') {\\n        if (ratio > 1 - params.longSwipesRatio) {\\n          swiper.slideTo(stopIndex + increment);\\n        } else {\\n          swiper.slideTo(stopIndex);\\n        }\\n      }\\n    } else {\\n      // Short swipes\\n      if (!params.shortSwipes) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n\\n      var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\\n\\n      if (!isNavButtonTarget) {\\n        if (swiper.swipeDirection === 'next') {\\n          swiper.slideTo(stopIndex + increment);\\n        }\\n\\n        if (swiper.swipeDirection === 'prev') {\\n          swiper.slideTo(stopIndex);\\n        }\\n      } else if (e.target === swiper.navigation.nextEl) {\\n        swiper.slideTo(stopIndex + increment);\\n      } else {\\n        swiper.slideTo(stopIndex);\\n      }\\n    }\\n  }\\n\\n  function onResize() {\\n    var swiper = this;\\n    var params = swiper.params,\\n        el = swiper.el;\\n\\n    if (el && el.offsetWidth === 0) {\\n      return;\\n    } // Breakpoints\\n\\n\\n    if (params.breakpoints) {\\n      swiper.setBreakpoint();\\n    } // Save locks\\n\\n\\n    var allowSlideNext = swiper.allowSlideNext,\\n        allowSlidePrev = swiper.allowSlidePrev,\\n        snapGrid = swiper.snapGrid; // Disable locks on resize\\n\\n    swiper.allowSlideNext = true;\\n    swiper.allowSlidePrev = true;\\n    swiper.updateSize();\\n    swiper.updateSlides();\\n    swiper.updateSlidesClasses();\\n\\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {\\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\\n    } else {\\n      swiper.slideTo(swiper.activeIndex, 0, false, true);\\n    }\\n\\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\\n      swiper.autoplay.run();\\n    } // Return locks after resize\\n\\n\\n    swiper.allowSlidePrev = allowSlidePrev;\\n    swiper.allowSlideNext = allowSlideNext;\\n\\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\\n      swiper.checkOverflow();\\n    }\\n  }\\n\\n  function onClick(e) {\\n    var swiper = this;\\n\\n    if (!swiper.enabled) {\\n      return;\\n    }\\n\\n    if (!swiper.allowClick) {\\n      if (swiper.params.preventClicks) {\\n        e.preventDefault();\\n      }\\n\\n      if (swiper.params.preventClicksPropagation && swiper.animating) {\\n        e.stopPropagation();\\n        e.stopImmediatePropagation();\\n      }\\n    }\\n  }\\n\\n  function onScroll() {\\n    var swiper = this;\\n    var wrapperEl = swiper.wrapperEl,\\n        rtlTranslate = swiper.rtlTranslate,\\n        enabled = swiper.enabled;\\n\\n    if (!enabled) {\\n      return;\\n    }\\n\\n    swiper.previousTranslate = swiper.translate;\\n\\n    if (swiper.isHorizontal()) {\\n      swiper.translate = -wrapperEl.scrollLeft;\\n    } else {\\n      swiper.translate = -wrapperEl.scrollTop;\\n    } // eslint-disable-next-line\\n\\n\\n    if (swiper.translate === -0) {\\n      swiper.translate = 0;\\n    }\\n\\n    swiper.updateActiveIndex();\\n    swiper.updateSlidesClasses();\\n    var newProgress;\\n    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\\n\\n    if (translatesDiff === 0) {\\n      newProgress = 0;\\n    } else {\\n      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\\n    }\\n\\n    if (newProgress !== swiper.progress) {\\n      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\\n    }\\n\\n    swiper.emit('setTranslate', swiper.translate, false);\\n  }\\n\\n  var dummyEventAttached = false;\\n\\n  function dummyEventListener() {}\\n\\n  var events = function events(swiper, method) {\\n    var document = getDocument();\\n    var params = swiper.params,\\n        touchEvents = swiper.touchEvents,\\n        el = swiper.el,\\n        wrapperEl = swiper.wrapperEl,\\n        device = swiper.device,\\n        support = swiper.support;\\n    var capture = !!params.nested;\\n    var domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\\n    var swiperMethod = method; // Touch Events\\n\\n    if (!support.touch) {\\n      el[domMethod](touchEvents.start, swiper.onTouchStart, false);\\n      document[domMethod](touchEvents.move, swiper.onTouchMove, capture);\\n      document[domMethod](touchEvents.end, swiper.onTouchEnd, false);\\n    } else {\\n      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {\\n        passive: true,\\n        capture: false\\n      } : false;\\n      el[domMethod](touchEvents.start, swiper.onTouchStart, passiveListener);\\n      el[domMethod](touchEvents.move, swiper.onTouchMove, support.passiveListener ? {\\n        passive: false,\\n        capture: capture\\n      } : capture);\\n      el[domMethod](touchEvents.end, swiper.onTouchEnd, passiveListener);\\n\\n      if (touchEvents.cancel) {\\n        el[domMethod](touchEvents.cancel, swiper.onTouchEnd, passiveListener);\\n      }\\n    } // Prevent Links Clicks\\n\\n\\n    if (params.preventClicks || params.preventClicksPropagation) {\\n      el[domMethod]('click', swiper.onClick, true);\\n    }\\n\\n    if (params.cssMode) {\\n      wrapperEl[domMethod]('scroll', swiper.onScroll);\\n    } // Resize handler\\n\\n\\n    if (params.updateOnWindowResize) {\\n      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\\n    } else {\\n      swiper[swiperMethod]('observerUpdate', onResize, true);\\n    }\\n  };\\n\\n  function attachEvents() {\\n    var swiper = this;\\n    var document = getDocument();\\n    var params = swiper.params,\\n        support = swiper.support;\\n    swiper.onTouchStart = onTouchStart.bind(swiper);\\n    swiper.onTouchMove = onTouchMove.bind(swiper);\\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\\n\\n    if (params.cssMode) {\\n      swiper.onScroll = onScroll.bind(swiper);\\n    }\\n\\n    swiper.onClick = onClick.bind(swiper);\\n\\n    if (support.touch && !dummyEventAttached) {\\n      document.addEventListener('touchstart', dummyEventListener);\\n      dummyEventAttached = true;\\n    }\\n\\n    events(swiper, 'on');\\n  }\\n\\n  function detachEvents() {\\n    var swiper = this;\\n    events(swiper, 'off');\\n  }\\n\\n  var events$1 = {\\n    attachEvents: attachEvents,\\n    detachEvents: detachEvents\\n  };\\n\\n  var isGridEnabled = function isGridEnabled(swiper, params) {\\n    return swiper.grid && params.grid && params.grid.rows > 1;\\n  };\\n\\n  function setBreakpoint() {\\n    var swiper = this;\\n    var activeIndex = swiper.activeIndex,\\n        initialized = swiper.initialized,\\n        _swiper$loopedSlides = swiper.loopedSlides,\\n        loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,\\n        params = swiper.params,\\n        $el = swiper.$el;\\n    var breakpoints = params.breakpoints;\\n\\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) {\\n      return;\\n    } // Get breakpoint for window width and update parameters\\n\\n\\n    var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\\n\\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) {\\n      return;\\n    }\\n\\n    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\\n    var breakpointParams = breakpointOnlyParams || swiper.originalParams;\\n    var wasMultiRow = isGridEnabled(swiper, params);\\n    var isMultiRow = isGridEnabled(swiper, breakpointParams);\\n    var wasEnabled = params.enabled;\\n\\n    if (wasMultiRow && !isMultiRow) {\\n      $el.removeClass(\\\"\\\".concat(params.containerModifierClass, \\\"grid \\\").concat(params.containerModifierClass, \\\"grid-column\\\"));\\n      swiper.emitContainerClasses();\\n    } else if (!wasMultiRow && isMultiRow) {\\n      $el.addClass(\\\"\\\".concat(params.containerModifierClass, \\\"grid\\\"));\\n\\n      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\\n        $el.addClass(\\\"\\\".concat(params.containerModifierClass, \\\"grid-column\\\"));\\n      }\\n\\n      swiper.emitContainerClasses();\\n    }\\n\\n    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\\n    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\\n\\n    if (directionChanged && initialized) {\\n      swiper.changeDirection();\\n    }\\n\\n    extend(swiper.params, breakpointParams);\\n    var isEnabled = swiper.params.enabled;\\n    Object.assign(swiper, {\\n      allowTouchMove: swiper.params.allowTouchMove,\\n      allowSlideNext: swiper.params.allowSlideNext,\\n      allowSlidePrev: swiper.params.allowSlidePrev\\n    });\\n\\n    if (wasEnabled && !isEnabled) {\\n      swiper.disable();\\n    } else if (!wasEnabled && isEnabled) {\\n      swiper.enable();\\n    }\\n\\n    swiper.currentBreakpoint = breakpoint;\\n    swiper.emit('_beforeBreakpoint', breakpointParams);\\n\\n    if (needsReLoop && initialized) {\\n      swiper.loopDestroy();\\n      swiper.loopCreate();\\n      swiper.updateSlides();\\n      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);\\n    }\\n\\n    swiper.emit('breakpoint', breakpointParams);\\n  }\\n\\n  function getBreakpoint(breakpoints) {\\n    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'window';\\n    var containerEl = arguments.length > 2 ? arguments[2] : undefined;\\n\\n    if (!breakpoints || base === 'container' && !containerEl) {\\n      return undefined;\\n    }\\n\\n    var breakpoint = false;\\n    var window = getWindow();\\n    var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\\n    var points = Object.keys(breakpoints).map(function (point) {\\n      if (typeof point === 'string' && point.indexOf('@') === 0) {\\n        var minRatio = parseFloat(point.substr(1));\\n        var value = currentHeight * minRatio;\\n        return {\\n          value: value,\\n          point: point\\n        };\\n      }\\n\\n      return {\\n        value: point,\\n        point: point\\n      };\\n    });\\n    points.sort(function (a, b) {\\n      return parseInt(a.value, 10) - parseInt(b.value, 10);\\n    });\\n\\n    for (var i = 0; i < points.length; i += 1) {\\n      var _points$i = points[i],\\n          point = _points$i.point,\\n          value = _points$i.value;\\n\\n      if (base === 'window') {\\n        if (window.matchMedia(\\\"(min-width: \\\".concat(value, \\\"px)\\\")).matches) {\\n          breakpoint = point;\\n        }\\n      } else if (value <= containerEl.clientWidth) {\\n        breakpoint = point;\\n      }\\n    }\\n\\n    return breakpoint || 'max';\\n  }\\n\\n  var breakpoints = {\\n    setBreakpoint: setBreakpoint,\\n    getBreakpoint: getBreakpoint\\n  };\\n\\n  function prepareClasses(entries, prefix) {\\n    var resultClasses = [];\\n    entries.forEach(function (item) {\\n      if (_typeof(item) === 'object') {\\n        Object.keys(item).forEach(function (classNames) {\\n          if (item[classNames]) {\\n            resultClasses.push(prefix + classNames);\\n          }\\n        });\\n      } else if (typeof item === 'string') {\\n        resultClasses.push(prefix + item);\\n      }\\n    });\\n    return resultClasses;\\n  }\\n\\n  function addClasses() {\\n    var swiper = this;\\n    var classNames = swiper.classNames,\\n        params = swiper.params,\\n        rtl = swiper.rtl,\\n        $el = swiper.$el,\\n        device = swiper.device,\\n        support = swiper.support; // prettier-ignore\\n\\n    var suffixes = prepareClasses(['initialized', params.direction, {\\n      'pointer-events': !support.touch\\n    }, {\\n      'free-mode': swiper.params.freeMode && params.freeMode.enabled\\n    }, {\\n      'autoheight': params.autoHeight\\n    }, {\\n      'rtl': rtl\\n    }, {\\n      'grid': params.grid && params.grid.rows > 1\\n    }, {\\n      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\\n    }, {\\n      'android': device.android\\n    }, {\\n      'ios': device.ios\\n    }, {\\n      'css-mode': params.cssMode\\n    }, {\\n      'centered': params.cssMode && params.centeredSlides\\n    }], params.containerModifierClass);\\n    classNames.push.apply(classNames, _toConsumableArray(suffixes));\\n    $el.addClass(_toConsumableArray(classNames).join(' '));\\n    swiper.emitContainerClasses();\\n  }\\n\\n  function removeClasses() {\\n    var swiper = this;\\n    var $el = swiper.$el,\\n        classNames = swiper.classNames;\\n    $el.removeClass(classNames.join(' '));\\n    swiper.emitContainerClasses();\\n  }\\n\\n  var classes = {\\n    addClasses: addClasses,\\n    removeClasses: removeClasses\\n  };\\n\\n  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {\\n    var window = getWindow();\\n    var image;\\n\\n    function onReady() {\\n      if (callback) {\\n        callback();\\n      }\\n    }\\n\\n    var isPicture = $(imageEl).parent('picture')[0];\\n\\n    if (!isPicture && (!imageEl.complete || !checkForComplete)) {\\n      if (src) {\\n        image = new window.Image();\\n        image.onload = onReady;\\n        image.onerror = onReady;\\n\\n        if (sizes) {\\n          image.sizes = sizes;\\n        }\\n\\n        if (srcset) {\\n          image.srcset = srcset;\\n        }\\n\\n        if (src) {\\n          image.src = src;\\n        }\\n      } else {\\n        onReady();\\n      }\\n    } else {\\n      // image already loaded...\\n      onReady();\\n    }\\n  }\\n\\n  function preloadImages() {\\n    var swiper = this;\\n    swiper.imagesToLoad = swiper.$el.find('img');\\n\\n    function onReady() {\\n      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) {\\n        return;\\n      }\\n\\n      if (swiper.imagesLoaded !== undefined) {\\n        swiper.imagesLoaded += 1;\\n      }\\n\\n      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {\\n        if (swiper.params.updateOnImagesReady) {\\n          swiper.update();\\n        }\\n\\n        swiper.emit('imagesReady');\\n      }\\n    }\\n\\n    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {\\n      var imageEl = swiper.imagesToLoad[i];\\n      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);\\n    }\\n  }\\n\\n  var images = {\\n    loadImage: loadImage,\\n    preloadImages: preloadImages\\n  };\\n\\n  function checkOverflow() {\\n    var swiper = this;\\n    var wasLocked = swiper.isLocked,\\n        params = swiper.params;\\n    var slidesOffsetBefore = params.slidesOffsetBefore;\\n\\n    if (slidesOffsetBefore) {\\n      var lastSlideIndex = swiper.slides.length - 1;\\n      var lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\\n      swiper.isLocked = swiper.size > lastSlideRightEdge;\\n    } else {\\n      swiper.isLocked = swiper.snapGrid.length === 1;\\n    }\\n\\n    if (params.allowSlideNext === true) {\\n      swiper.allowSlideNext = !swiper.isLocked;\\n    }\\n\\n    if (params.allowSlidePrev === true) {\\n      swiper.allowSlidePrev = !swiper.isLocked;\\n    }\\n\\n    if (wasLocked && wasLocked !== swiper.isLocked) {\\n      swiper.isEnd = false;\\n    }\\n\\n    if (wasLocked !== swiper.isLocked) {\\n      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\\n    }\\n  }\\n\\n  var checkOverflow$1 = {\\n    checkOverflow: checkOverflow\\n  };\\n  var defaults = {\\n    init: true,\\n    direction: 'horizontal',\\n    touchEventsTarget: 'wrapper',\\n    initialSlide: 0,\\n    speed: 300,\\n    cssMode: false,\\n    updateOnWindowResize: true,\\n    resizeObserver: true,\\n    nested: false,\\n    createElements: false,\\n    enabled: true,\\n    focusableElements: 'input, select, option, textarea, button, video, label',\\n    // Overrides\\n    width: null,\\n    height: null,\\n    //\\n    preventInteractionOnTransition: false,\\n    // ssr\\n    userAgent: null,\\n    url: null,\\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\\n    edgeSwipeDetection: false,\\n    edgeSwipeThreshold: 20,\\n    // Autoheight\\n    autoHeight: false,\\n    // Set wrapper width\\n    setWrapperSize: false,\\n    // Virtual Translate\\n    virtualTranslate: false,\\n    // Effects\\n    effect: 'slide',\\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\\n    // Breakpoints\\n    breakpoints: undefined,\\n    breakpointsBase: 'window',\\n    // Slides grid\\n    spaceBetween: 0,\\n    slidesPerView: 1,\\n    slidesPerGroup: 1,\\n    slidesPerGroupSkip: 0,\\n    slidesPerGroupAuto: false,\\n    centeredSlides: false,\\n    centeredSlidesBounds: false,\\n    slidesOffsetBefore: 0,\\n    // in px\\n    slidesOffsetAfter: 0,\\n    // in px\\n    normalizeSlideIndex: true,\\n    centerInsufficientSlides: false,\\n    // Disable swiper and hide navigation when container not overflow\\n    watchOverflow: true,\\n    // Round length\\n    roundLengths: false,\\n    // Touches\\n    touchRatio: 1,\\n    touchAngle: 45,\\n    simulateTouch: true,\\n    shortSwipes: true,\\n    longSwipes: true,\\n    longSwipesRatio: 0.5,\\n    longSwipesMs: 300,\\n    followFinger: true,\\n    allowTouchMove: true,\\n    threshold: 0,\\n    touchMoveStopPropagation: false,\\n    touchStartPreventDefault: true,\\n    touchStartForcePreventDefault: false,\\n    touchReleaseOnEdges: false,\\n    // Unique Navigation Elements\\n    uniqueNavElements: true,\\n    // Resistance\\n    resistance: true,\\n    resistanceRatio: 0.85,\\n    // Progress\\n    watchSlidesProgress: false,\\n    // Cursor\\n    grabCursor: false,\\n    // Clicks\\n    preventClicks: true,\\n    preventClicksPropagation: true,\\n    slideToClickedSlide: false,\\n    // Images\\n    preloadImages: true,\\n    updateOnImagesReady: true,\\n    // loop\\n    loop: false,\\n    loopAdditionalSlides: 0,\\n    loopedSlides: null,\\n    loopFillGroupWithBlank: false,\\n    loopPreventsSlide: true,\\n    // Swiping/no swiping\\n    allowSlidePrev: true,\\n    allowSlideNext: true,\\n    swipeHandler: null,\\n    // '.swipe-handler',\\n    noSwiping: true,\\n    noSwipingClass: 'swiper-no-swiping',\\n    noSwipingSelector: null,\\n    // Passive Listeners\\n    passiveListeners: true,\\n    // NS\\n    containerModifierClass: 'swiper-',\\n    // NEW\\n    slideClass: 'swiper-slide',\\n    slideBlankClass: 'swiper-slide-invisible-blank',\\n    slideActiveClass: 'swiper-slide-active',\\n    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',\\n    slideVisibleClass: 'swiper-slide-visible',\\n    slideDuplicateClass: 'swiper-slide-duplicate',\\n    slideNextClass: 'swiper-slide-next',\\n    slideDuplicateNextClass: 'swiper-slide-duplicate-next',\\n    slidePrevClass: 'swiper-slide-prev',\\n    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',\\n    wrapperClass: 'swiper-wrapper',\\n    // Callbacks\\n    runCallbacksOnInit: true,\\n    // Internals\\n    _emitClasses: false\\n  };\\n\\n  function moduleExtendParams(params, allModulesParams) {\\n    return function extendParams() {\\n      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var moduleParamName = Object.keys(obj)[0];\\n      var moduleParams = obj[moduleParamName];\\n\\n      if (_typeof(moduleParams) !== 'object' || moduleParams === null) {\\n        extend(allModulesParams, obj);\\n        return;\\n      }\\n\\n      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\\n        params[moduleParamName] = {\\n          auto: true\\n        };\\n      }\\n\\n      if (!(moduleParamName in params && 'enabled' in moduleParams)) {\\n        extend(allModulesParams, obj);\\n        return;\\n      }\\n\\n      if (params[moduleParamName] === true) {\\n        params[moduleParamName] = {\\n          enabled: true\\n        };\\n      }\\n\\n      if (_typeof(params[moduleParamName]) === 'object' && !('enabled' in params[moduleParamName])) {\\n        params[moduleParamName].enabled = true;\\n      }\\n\\n      if (!params[moduleParamName]) {\\n        params[moduleParamName] = {\\n          enabled: false\\n        };\\n      }\\n\\n      extend(allModulesParams, obj);\\n    };\\n  }\\n  /* eslint no-param-reassign: \\\"off\\\" */\\n\\n\\n  var prototypes = {\\n    eventsEmitter: eventsEmitter,\\n    update: update,\\n    translate: translate,\\n    transition: transition,\\n    slide: slide,\\n    loop: loop,\\n    grabCursor: grabCursor,\\n    events: events$1,\\n    breakpoints: breakpoints,\\n    checkOverflow: checkOverflow$1,\\n    classes: classes,\\n    images: images\\n  };\\n  var extendedDefaults = {};\\n\\n  var Swiper = /*#__PURE__*/function () {\\n    function Swiper() {\\n      _classCallCheck(this, Swiper);\\n\\n      var el;\\n      var params;\\n\\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\\n        args[_key10] = arguments[_key10];\\n      }\\n\\n      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\\n        params = args[0];\\n      } else {\\n        el = args[0];\\n        params = args[1];\\n      }\\n\\n      if (!params) {\\n        params = {};\\n      }\\n\\n      params = extend({}, params);\\n\\n      if (el && !params.el) {\\n        params.el = el;\\n      }\\n\\n      if (params.el && $(params.el).length > 1) {\\n        var swipers = [];\\n        $(params.el).each(function (containerEl) {\\n          var newParams = extend({}, params, {\\n            el: containerEl\\n          });\\n          swipers.push(new Swiper(newParams));\\n        });\\n        return swipers;\\n      } // Swiper Instance\\n\\n\\n      var swiper = this;\\n      swiper.__swiper__ = true;\\n      swiper.support = getSupport();\\n      swiper.device = getDevice({\\n        userAgent: params.userAgent\\n      });\\n      swiper.browser = getBrowser();\\n      swiper.eventsListeners = {};\\n      swiper.eventsAnyListeners = [];\\n      swiper.modules = _toConsumableArray(swiper.__modules__);\\n\\n      if (params.modules && Array.isArray(params.modules)) {\\n        var _swiper$modules;\\n\\n        (_swiper$modules = swiper.modules).push.apply(_swiper$modules, _toConsumableArray(params.modules));\\n      }\\n\\n      var allModulesParams = {};\\n      swiper.modules.forEach(function (mod) {\\n        mod({\\n          swiper: swiper,\\n          extendParams: moduleExtendParams(params, allModulesParams),\\n          on: swiper.on.bind(swiper),\\n          once: swiper.once.bind(swiper),\\n          off: swiper.off.bind(swiper),\\n          emit: swiper.emit.bind(swiper)\\n        });\\n      }); // Extend defaults with modules params\\n\\n      var swiperParams = extend({}, defaults, allModulesParams); // Extend defaults with passed params\\n\\n      swiper.params = extend({}, swiperParams, extendedDefaults, params);\\n      swiper.originalParams = extend({}, swiper.params);\\n      swiper.passedParams = extend({}, params); // add event listeners\\n\\n      if (swiper.params && swiper.params.on) {\\n        Object.keys(swiper.params.on).forEach(function (eventName) {\\n          swiper.on(eventName, swiper.params.on[eventName]);\\n        });\\n      }\\n\\n      if (swiper.params && swiper.params.onAny) {\\n        swiper.onAny(swiper.params.onAny);\\n      } // Save Dom lib\\n\\n\\n      swiper.$ = $; // Extend Swiper\\n\\n      Object.assign(swiper, {\\n        enabled: swiper.params.enabled,\\n        el: el,\\n        // Classes\\n        classNames: [],\\n        // Slides\\n        slides: $(),\\n        slidesGrid: [],\\n        snapGrid: [],\\n        slidesSizesGrid: [],\\n        // isDirection\\n        isHorizontal: function isHorizontal() {\\n          return swiper.params.direction === 'horizontal';\\n        },\\n        isVertical: function isVertical() {\\n          return swiper.params.direction === 'vertical';\\n        },\\n        // Indexes\\n        activeIndex: 0,\\n        realIndex: 0,\\n        //\\n        isBeginning: true,\\n        isEnd: false,\\n        // Props\\n        translate: 0,\\n        previousTranslate: 0,\\n        progress: 0,\\n        velocity: 0,\\n        animating: false,\\n        // Locks\\n        allowSlideNext: swiper.params.allowSlideNext,\\n        allowSlidePrev: swiper.params.allowSlidePrev,\\n        // Touch Events\\n        touchEvents: function touchEvents() {\\n          var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\\n          var desktop = ['pointerdown', 'pointermove', 'pointerup'];\\n          swiper.touchEventsTouch = {\\n            start: touch[0],\\n            move: touch[1],\\n            end: touch[2],\\n            cancel: touch[3]\\n          };\\n          swiper.touchEventsDesktop = {\\n            start: desktop[0],\\n            move: desktop[1],\\n            end: desktop[2]\\n          };\\n          return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;\\n        }(),\\n        touchEventsData: {\\n          isTouched: undefined,\\n          isMoved: undefined,\\n          allowTouchCallbacks: undefined,\\n          touchStartTime: undefined,\\n          isScrolling: undefined,\\n          currentTranslate: undefined,\\n          startTranslate: undefined,\\n          allowThresholdMove: undefined,\\n          // Form elements to match\\n          focusableElements: swiper.params.focusableElements,\\n          // Last click time\\n          lastClickTime: now(),\\n          clickTimeout: undefined,\\n          // Velocities\\n          velocities: [],\\n          allowMomentumBounce: undefined,\\n          isTouchEvent: undefined,\\n          startMoving: undefined\\n        },\\n        // Clicks\\n        allowClick: true,\\n        // Touches\\n        allowTouchMove: swiper.params.allowTouchMove,\\n        touches: {\\n          startX: 0,\\n          startY: 0,\\n          currentX: 0,\\n          currentY: 0,\\n          diff: 0\\n        },\\n        // Images\\n        imagesToLoad: [],\\n        imagesLoaded: 0\\n      });\\n      swiper.emit('_swiper'); // Init\\n\\n      if (swiper.params.init) {\\n        swiper.init();\\n      } // Return app instance\\n\\n\\n      return swiper;\\n    }\\n\\n    _createClass(Swiper, [{\\n      key: \\\"enable\\\",\\n      value: function enable() {\\n        var swiper = this;\\n\\n        if (swiper.enabled) {\\n          return;\\n        }\\n\\n        swiper.enabled = true;\\n\\n        if (swiper.params.grabCursor) {\\n          swiper.setGrabCursor();\\n        }\\n\\n        swiper.emit('enable');\\n      }\\n    }, {\\n      key: \\\"disable\\\",\\n      value: function disable() {\\n        var swiper = this;\\n\\n        if (!swiper.enabled) {\\n          return;\\n        }\\n\\n        swiper.enabled = false;\\n\\n        if (swiper.params.grabCursor) {\\n          swiper.unsetGrabCursor();\\n        }\\n\\n        swiper.emit('disable');\\n      }\\n    }, {\\n      key: \\\"setProgress\\\",\\n      value: function setProgress(progress, speed) {\\n        var swiper = this;\\n        progress = Math.min(Math.max(progress, 0), 1);\\n        var min = swiper.minTranslate();\\n        var max = swiper.maxTranslate();\\n        var current = (max - min) * progress + min;\\n        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      }\\n    }, {\\n      key: \\\"emitContainerClasses\\\",\\n      value: function emitContainerClasses() {\\n        var swiper = this;\\n\\n        if (!swiper.params._emitClasses || !swiper.el) {\\n          return;\\n        }\\n\\n        var cls = swiper.el.className.split(' ').filter(function (className) {\\n          return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\\n        });\\n        swiper.emit('_containerClasses', cls.join(' '));\\n      }\\n    }, {\\n      key: \\\"getSlideClasses\\\",\\n      value: function getSlideClasses(slideEl) {\\n        var swiper = this;\\n        return slideEl.className.split(' ').filter(function (className) {\\n          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\\n        }).join(' ');\\n      }\\n    }, {\\n      key: \\\"emitSlidesClasses\\\",\\n      value: function emitSlidesClasses() {\\n        var swiper = this;\\n\\n        if (!swiper.params._emitClasses || !swiper.el) {\\n          return;\\n        }\\n\\n        var updates = [];\\n        swiper.slides.each(function (slideEl) {\\n          var classNames = swiper.getSlideClasses(slideEl);\\n          updates.push({\\n            slideEl: slideEl,\\n            classNames: classNames\\n          });\\n          swiper.emit('_slideClass', slideEl, classNames);\\n        });\\n        swiper.emit('_slideClasses', updates);\\n      }\\n    }, {\\n      key: \\\"slidesPerViewDynamic\\\",\\n      value: function slidesPerViewDynamic() {\\n        var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'current';\\n        var exact = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\\n        var swiper = this;\\n        var params = swiper.params,\\n            slides = swiper.slides,\\n            slidesGrid = swiper.slidesGrid,\\n            slidesSizesGrid = swiper.slidesSizesGrid,\\n            swiperSize = swiper.size,\\n            activeIndex = swiper.activeIndex;\\n        var spv = 1;\\n\\n        if (params.centeredSlides) {\\n          var slideSize = slides[activeIndex].swiperSlideSize;\\n          var breakLoop;\\n\\n          for (var i = activeIndex + 1; i < slides.length; i += 1) {\\n            if (slides[i] && !breakLoop) {\\n              slideSize += slides[i].swiperSlideSize;\\n              spv += 1;\\n\\n              if (slideSize > swiperSize) {\\n                breakLoop = true;\\n              }\\n            }\\n          }\\n\\n          for (var _i4 = activeIndex - 1; _i4 >= 0; _i4 -= 1) {\\n            if (slides[_i4] && !breakLoop) {\\n              slideSize += slides[_i4].swiperSlideSize;\\n              spv += 1;\\n\\n              if (slideSize > swiperSize) {\\n                breakLoop = true;\\n              }\\n            }\\n          }\\n        } else {\\n          // eslint-disable-next-line\\n          if (view === 'current') {\\n            for (var _i5 = activeIndex + 1; _i5 < slides.length; _i5 += 1) {\\n              var slideInView = exact ? slidesGrid[_i5] + slidesSizesGrid[_i5] - slidesGrid[activeIndex] < swiperSize : slidesGrid[_i5] - slidesGrid[activeIndex] < swiperSize;\\n\\n              if (slideInView) {\\n                spv += 1;\\n              }\\n            }\\n          } else {\\n            // previous\\n            for (var _i6 = activeIndex - 1; _i6 >= 0; _i6 -= 1) {\\n              var _slideInView = slidesGrid[activeIndex] - slidesGrid[_i6] < swiperSize;\\n\\n              if (_slideInView) {\\n                spv += 1;\\n              }\\n            }\\n          }\\n        }\\n\\n        return spv;\\n      }\\n    }, {\\n      key: \\\"update\\\",\\n      value: function update() {\\n        var swiper = this;\\n\\n        if (!swiper || swiper.destroyed) {\\n          return;\\n        }\\n\\n        var snapGrid = swiper.snapGrid,\\n            params = swiper.params; // Breakpoints\\n\\n        if (params.breakpoints) {\\n          swiper.setBreakpoint();\\n        }\\n\\n        swiper.updateSize();\\n        swiper.updateSlides();\\n        swiper.updateProgress();\\n        swiper.updateSlidesClasses();\\n\\n        function setTranslate() {\\n          var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\\n          var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\\n          swiper.setTranslate(newTranslate);\\n          swiper.updateActiveIndex();\\n          swiper.updateSlidesClasses();\\n        }\\n\\n        var translated;\\n\\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled) {\\n          setTranslate();\\n\\n          if (swiper.params.autoHeight) {\\n            swiper.updateAutoHeight();\\n          }\\n        } else {\\n          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {\\n            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);\\n          } else {\\n            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\\n          }\\n\\n          if (!translated) {\\n            setTranslate();\\n          }\\n        }\\n\\n        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\\n          swiper.checkOverflow();\\n        }\\n\\n        swiper.emit('update');\\n      }\\n    }, {\\n      key: \\\"changeDirection\\\",\\n      value: function changeDirection(newDirection) {\\n        var needUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n        var swiper = this;\\n        var currentDirection = swiper.params.direction;\\n\\n        if (!newDirection) {\\n          // eslint-disable-next-line\\n          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\\n        }\\n\\n        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\\n          return swiper;\\n        }\\n\\n        swiper.$el.removeClass(\\\"\\\".concat(swiper.params.containerModifierClass).concat(currentDirection)).addClass(\\\"\\\".concat(swiper.params.containerModifierClass).concat(newDirection));\\n        swiper.emitContainerClasses();\\n        swiper.params.direction = newDirection;\\n        swiper.slides.each(function (slideEl) {\\n          if (newDirection === 'vertical') {\\n            slideEl.style.width = '';\\n          } else {\\n            slideEl.style.height = '';\\n          }\\n        });\\n        swiper.emit('changeDirection');\\n\\n        if (needUpdate) {\\n          swiper.update();\\n        }\\n\\n        return swiper;\\n      }\\n    }, {\\n      key: \\\"mount\\\",\\n      value: function mount(el) {\\n        var swiper = this;\\n\\n        if (swiper.mounted) {\\n          return true;\\n        } // Find el\\n\\n\\n        var $el = $(el || swiper.params.el);\\n        el = $el[0];\\n\\n        if (!el) {\\n          return false;\\n        }\\n\\n        el.swiper = swiper;\\n\\n        var getWrapperSelector = function getWrapperSelector() {\\n          return \\\".\\\".concat((swiper.params.wrapperClass || '').trim().split(' ').join('.'));\\n        };\\n\\n        var getWrapper = function getWrapper() {\\n          if (el && el.shadowRoot && el.shadowRoot.querySelector) {\\n            var res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items\\n\\n            res.children = function (options) {\\n              return $el.children(options);\\n            };\\n\\n            return res;\\n          }\\n\\n          return $el.children(getWrapperSelector());\\n        }; // Find Wrapper\\n\\n\\n        var $wrapperEl = getWrapper();\\n\\n        if ($wrapperEl.length === 0 && swiper.params.createElements) {\\n          var _document2 = getDocument();\\n\\n          var wrapper = _document2.createElement('div');\\n\\n          $wrapperEl = $(wrapper);\\n          wrapper.className = swiper.params.wrapperClass;\\n          $el.append(wrapper);\\n          $el.children(\\\".\\\".concat(swiper.params.slideClass)).each(function (slideEl) {\\n            $wrapperEl.append(slideEl);\\n          });\\n        }\\n\\n        Object.assign(swiper, {\\n          $el: $el,\\n          el: el,\\n          $wrapperEl: $wrapperEl,\\n          wrapperEl: $wrapperEl[0],\\n          mounted: true,\\n          // RTL\\n          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',\\n          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),\\n          wrongRTL: $wrapperEl.css('display') === '-webkit-box'\\n        });\\n        return true;\\n      }\\n    }, {\\n      key: \\\"init\\\",\\n      value: function init(el) {\\n        var swiper = this;\\n\\n        if (swiper.initialized) {\\n          return swiper;\\n        }\\n\\n        var mounted = swiper.mount(el);\\n\\n        if (mounted === false) {\\n          return swiper;\\n        }\\n\\n        swiper.emit('beforeInit'); // Set breakpoint\\n\\n        if (swiper.params.breakpoints) {\\n          swiper.setBreakpoint();\\n        } // Add Classes\\n\\n\\n        swiper.addClasses(); // Create loop\\n\\n        if (swiper.params.loop) {\\n          swiper.loopCreate();\\n        } // Update size\\n\\n\\n        swiper.updateSize(); // Update slides\\n\\n        swiper.updateSlides();\\n\\n        if (swiper.params.watchOverflow) {\\n          swiper.checkOverflow();\\n        } // Set Grab Cursor\\n\\n\\n        if (swiper.params.grabCursor && swiper.enabled) {\\n          swiper.setGrabCursor();\\n        }\\n\\n        if (swiper.params.preloadImages) {\\n          swiper.preloadImages();\\n        } // Slide To Initial Slide\\n\\n\\n        if (swiper.params.loop) {\\n          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);\\n        } else {\\n          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\\n        } // Attach events\\n\\n\\n        swiper.attachEvents(); // Init Flag\\n\\n        swiper.initialized = true; // Emit\\n\\n        swiper.emit('init');\\n        swiper.emit('afterInit');\\n        return swiper;\\n      }\\n    }, {\\n      key: \\\"destroy\\\",\\n      value: function destroy() {\\n        var deleteInstance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\\n        var cleanStyles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n        var swiper = this;\\n        var params = swiper.params,\\n            $el = swiper.$el,\\n            $wrapperEl = swiper.$wrapperEl,\\n            slides = swiper.slides;\\n\\n        if (typeof swiper.params === 'undefined' || swiper.destroyed) {\\n          return null;\\n        }\\n\\n        swiper.emit('beforeDestroy'); // Init Flag\\n\\n        swiper.initialized = false; // Detach events\\n\\n        swiper.detachEvents(); // Destroy loop\\n\\n        if (params.loop) {\\n          swiper.loopDestroy();\\n        } // Cleanup styles\\n\\n\\n        if (cleanStyles) {\\n          swiper.removeClasses();\\n          $el.removeAttr('style');\\n          $wrapperEl.removeAttr('style');\\n\\n          if (slides && slides.length) {\\n            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');\\n          }\\n        }\\n\\n        swiper.emit('destroy'); // Detach emitter events\\n\\n        Object.keys(swiper.eventsListeners).forEach(function (eventName) {\\n          swiper.off(eventName);\\n        });\\n\\n        if (deleteInstance !== false) {\\n          swiper.$el[0].swiper = null;\\n          deleteProps(swiper);\\n        }\\n\\n        swiper.destroyed = true;\\n        return null;\\n      }\\n    }], [{\\n      key: \\\"extendDefaults\\\",\\n      value: function extendDefaults(newDefaults) {\\n        extend(extendedDefaults, newDefaults);\\n      }\\n    }, {\\n      key: \\\"extendedDefaults\\\",\\n      get: function get() {\\n        return extendedDefaults;\\n      }\\n    }, {\\n      key: \\\"defaults\\\",\\n      get: function get() {\\n        return defaults;\\n      }\\n    }, {\\n      key: \\\"installModule\\\",\\n      value: function installModule(mod) {\\n        if (!Swiper.prototype.__modules__) {\\n          Swiper.prototype.__modules__ = [];\\n        }\\n\\n        var modules = Swiper.prototype.__modules__;\\n\\n        if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\\n          modules.push(mod);\\n        }\\n      }\\n    }, {\\n      key: \\\"use\\\",\\n      value: function use(module) {\\n        if (Array.isArray(module)) {\\n          module.forEach(function (m) {\\n            return Swiper.installModule(m);\\n          });\\n          return Swiper;\\n        }\\n\\n        Swiper.installModule(module);\\n        return Swiper;\\n      }\\n    }]);\\n\\n    return Swiper;\\n  }();\\n\\n  Object.keys(prototypes).forEach(function (prototypeGroup) {\\n    Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {\\n      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\\n    });\\n  });\\n  Swiper.use([Resize, Observer]);\\n\\n  function Virtual(_ref7) {\\n    var swiper = _ref7.swiper,\\n        extendParams = _ref7.extendParams,\\n        on = _ref7.on;\\n    extendParams({\\n      virtual: {\\n        enabled: false,\\n        slides: [],\\n        cache: true,\\n        renderSlide: null,\\n        renderExternal: null,\\n        renderExternalUpdate: true,\\n        addSlidesBefore: 0,\\n        addSlidesAfter: 0\\n      }\\n    });\\n    var cssModeTimeout;\\n    swiper.virtual = {\\n      cache: {},\\n      from: undefined,\\n      to: undefined,\\n      slides: [],\\n      offset: 0,\\n      slidesGrid: []\\n    };\\n\\n    function renderSlide(slide, index) {\\n      var params = swiper.params.virtual;\\n\\n      if (params.cache && swiper.virtual.cache[index]) {\\n        return swiper.virtual.cache[index];\\n      }\\n\\n      var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $(\\\"<div class=\\\\\\\"\\\".concat(swiper.params.slideClass, \\\"\\\\\\\" data-swiper-slide-index=\\\\\\\"\\\").concat(index, \\\"\\\\\\\">\\\").concat(slide, \\\"</div>\\\"));\\n\\n      if (!$slideEl.attr('data-swiper-slide-index')) {\\n        $slideEl.attr('data-swiper-slide-index', index);\\n      }\\n\\n      if (params.cache) {\\n        swiper.virtual.cache[index] = $slideEl;\\n      }\\n\\n      return $slideEl;\\n    }\\n\\n    function update(force) {\\n      var _swiper$params = swiper.params,\\n          slidesPerView = _swiper$params.slidesPerView,\\n          slidesPerGroup = _swiper$params.slidesPerGroup,\\n          centeredSlides = _swiper$params.centeredSlides;\\n      var _swiper$params$virtua = swiper.params.virtual,\\n          addSlidesBefore = _swiper$params$virtua.addSlidesBefore,\\n          addSlidesAfter = _swiper$params$virtua.addSlidesAfter;\\n      var _swiper$virtual = swiper.virtual,\\n          previousFrom = _swiper$virtual.from,\\n          previousTo = _swiper$virtual.to,\\n          slides = _swiper$virtual.slides,\\n          previousSlidesGrid = _swiper$virtual.slidesGrid,\\n          previousOffset = _swiper$virtual.offset;\\n\\n      if (!swiper.params.cssMode) {\\n        swiper.updateActiveIndex();\\n      }\\n\\n      var activeIndex = swiper.activeIndex || 0;\\n      var offsetProp;\\n\\n      if (swiper.rtlTranslate) {\\n        offsetProp = 'right';\\n      } else {\\n        offsetProp = swiper.isHorizontal() ? 'left' : 'top';\\n      }\\n\\n      var slidesAfter;\\n      var slidesBefore;\\n\\n      if (centeredSlides) {\\n        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\\n        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\\n      } else {\\n        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\\n        slidesBefore = slidesPerGroup + addSlidesBefore;\\n      }\\n\\n      var from = Math.max((activeIndex || 0) - slidesBefore, 0);\\n      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);\\n      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\\n      Object.assign(swiper.virtual, {\\n        from: from,\\n        to: to,\\n        offset: offset,\\n        slidesGrid: swiper.slidesGrid\\n      });\\n\\n      function onRendered() {\\n        swiper.updateSlides();\\n        swiper.updateProgress();\\n        swiper.updateSlidesClasses();\\n\\n        if (swiper.lazy && swiper.params.lazy.enabled) {\\n          swiper.lazy.load();\\n        }\\n      }\\n\\n      if (previousFrom === from && previousTo === to && !force) {\\n        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\\n          swiper.slides.css(offsetProp, \\\"\\\".concat(offset, \\\"px\\\"));\\n        }\\n\\n        swiper.updateProgress();\\n        return;\\n      }\\n\\n      if (swiper.params.virtual.renderExternal) {\\n        swiper.params.virtual.renderExternal.call(swiper, {\\n          offset: offset,\\n          from: from,\\n          to: to,\\n          slides: function getSlides() {\\n            var slidesToRender = [];\\n\\n            for (var i = from; i <= to; i += 1) {\\n              slidesToRender.push(slides[i]);\\n            }\\n\\n            return slidesToRender;\\n          }()\\n        });\\n\\n        if (swiper.params.virtual.renderExternalUpdate) {\\n          onRendered();\\n        }\\n\\n        return;\\n      }\\n\\n      var prependIndexes = [];\\n      var appendIndexes = [];\\n\\n      if (force) {\\n        swiper.$wrapperEl.find(\\\".\\\".concat(swiper.params.slideClass)).remove();\\n      } else {\\n        for (var i = previousFrom; i <= previousTo; i += 1) {\\n          if (i < from || i > to) {\\n            swiper.$wrapperEl.find(\\\".\\\".concat(swiper.params.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(i, \\\"\\\\\\\"]\\\")).remove();\\n          }\\n        }\\n      }\\n\\n      for (var _i7 = 0; _i7 < slides.length; _i7 += 1) {\\n        if (_i7 >= from && _i7 <= to) {\\n          if (typeof previousTo === 'undefined' || force) {\\n            appendIndexes.push(_i7);\\n          } else {\\n            if (_i7 > previousTo) {\\n              appendIndexes.push(_i7);\\n            }\\n\\n            if (_i7 < previousFrom) {\\n              prependIndexes.push(_i7);\\n            }\\n          }\\n        }\\n      }\\n\\n      appendIndexes.forEach(function (index) {\\n        swiper.$wrapperEl.append(renderSlide(slides[index], index));\\n      });\\n      prependIndexes.sort(function (a, b) {\\n        return b - a;\\n      }).forEach(function (index) {\\n        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));\\n      });\\n      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, \\\"\\\".concat(offset, \\\"px\\\"));\\n      onRendered();\\n    }\\n\\n    function appendSlide(slides) {\\n      if (_typeof(slides) === 'object' && 'length' in slides) {\\n        for (var i = 0; i < slides.length; i += 1) {\\n          if (slides[i]) {\\n            swiper.virtual.slides.push(slides[i]);\\n          }\\n        }\\n      } else {\\n        swiper.virtual.slides.push(slides);\\n      }\\n\\n      update(true);\\n    }\\n\\n    function prependSlide(slides) {\\n      var activeIndex = swiper.activeIndex;\\n      var newActiveIndex = activeIndex + 1;\\n      var numberOfNewSlides = 1;\\n\\n      if (Array.isArray(slides)) {\\n        for (var i = 0; i < slides.length; i += 1) {\\n          if (slides[i]) {\\n            swiper.virtual.slides.unshift(slides[i]);\\n          }\\n        }\\n\\n        newActiveIndex = activeIndex + slides.length;\\n        numberOfNewSlides = slides.length;\\n      } else {\\n        swiper.virtual.slides.unshift(slides);\\n      }\\n\\n      if (swiper.params.virtual.cache) {\\n        var cache = swiper.virtual.cache;\\n        var newCache = {};\\n        Object.keys(cache).forEach(function (cachedIndex) {\\n          var $cachedEl = cache[cachedIndex];\\n          var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');\\n\\n          if (cachedElIndex) {\\n            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\\n          }\\n\\n          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;\\n        });\\n        swiper.virtual.cache = newCache;\\n      }\\n\\n      update(true);\\n      swiper.slideTo(newActiveIndex, 0);\\n    }\\n\\n    function removeSlide(slidesIndexes) {\\n      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) {\\n        return;\\n      }\\n\\n      var activeIndex = swiper.activeIndex;\\n\\n      if (Array.isArray(slidesIndexes)) {\\n        for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {\\n          swiper.virtual.slides.splice(slidesIndexes[i], 1);\\n\\n          if (swiper.params.virtual.cache) {\\n            delete swiper.virtual.cache[slidesIndexes[i]];\\n          }\\n\\n          if (slidesIndexes[i] < activeIndex) {\\n            activeIndex -= 1;\\n          }\\n\\n          activeIndex = Math.max(activeIndex, 0);\\n        }\\n      } else {\\n        swiper.virtual.slides.splice(slidesIndexes, 1);\\n\\n        if (swiper.params.virtual.cache) {\\n          delete swiper.virtual.cache[slidesIndexes];\\n        }\\n\\n        if (slidesIndexes < activeIndex) {\\n          activeIndex -= 1;\\n        }\\n\\n        activeIndex = Math.max(activeIndex, 0);\\n      }\\n\\n      update(true);\\n      swiper.slideTo(activeIndex, 0);\\n    }\\n\\n    function removeAllSlides() {\\n      swiper.virtual.slides = [];\\n\\n      if (swiper.params.virtual.cache) {\\n        swiper.virtual.cache = {};\\n      }\\n\\n      update(true);\\n      swiper.slideTo(0, 0);\\n    }\\n\\n    on('beforeInit', function () {\\n      if (!swiper.params.virtual.enabled) {\\n        return;\\n      }\\n\\n      swiper.virtual.slides = swiper.params.virtual.slides;\\n      swiper.classNames.push(\\\"\\\".concat(swiper.params.containerModifierClass, \\\"virtual\\\"));\\n      swiper.params.watchSlidesProgress = true;\\n      swiper.originalParams.watchSlidesProgress = true;\\n\\n      if (!swiper.params.initialSlide) {\\n        update();\\n      }\\n    });\\n    on('setTranslate', function () {\\n      if (!swiper.params.virtual.enabled) {\\n        return;\\n      }\\n\\n      if (swiper.params.cssMode && !swiper._immediateVirtual) {\\n        clearTimeout(cssModeTimeout);\\n        cssModeTimeout = setTimeout(function () {\\n          update();\\n        }, 100);\\n      } else {\\n        update();\\n      }\\n    });\\n    on('init update resize', function () {\\n      if (!swiper.params.virtual.enabled) {\\n        return;\\n      }\\n\\n      if (swiper.params.cssMode) {\\n        setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', \\\"\\\".concat(swiper.virtualSize, \\\"px\\\"));\\n      }\\n    });\\n    Object.assign(swiper.virtual, {\\n      appendSlide: appendSlide,\\n      prependSlide: prependSlide,\\n      removeSlide: removeSlide,\\n      removeAllSlides: removeAllSlides,\\n      update: update\\n    });\\n  }\\n  /* eslint-disable consistent-return */\\n\\n\\n  function Keyboard(_ref8) {\\n    var swiper = _ref8.swiper,\\n        extendParams = _ref8.extendParams,\\n        on = _ref8.on,\\n        emit = _ref8.emit;\\n    var document = getDocument();\\n    var window = getWindow();\\n    swiper.keyboard = {\\n      enabled: false\\n    };\\n    extendParams({\\n      keyboard: {\\n        enabled: false,\\n        onlyInViewport: true,\\n        pageUpDown: true\\n      }\\n    });\\n\\n    function handle(event) {\\n      if (!swiper.enabled) {\\n        return;\\n      }\\n\\n      var rtl = swiper.rtlTranslate;\\n      var e = event;\\n\\n      if (e.originalEvent) {\\n        e = e.originalEvent;\\n      } // jquery fix\\n\\n\\n      var kc = e.keyCode || e.charCode;\\n      var pageUpDown = swiper.params.keyboard.pageUpDown;\\n      var isPageUp = pageUpDown && kc === 33;\\n      var isPageDown = pageUpDown && kc === 34;\\n      var isArrowLeft = kc === 37;\\n      var isArrowRight = kc === 39;\\n      var isArrowUp = kc === 38;\\n      var isArrowDown = kc === 40; // Directions locks\\n\\n      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\\n        return false;\\n      }\\n\\n      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\\n        return false;\\n      }\\n\\n      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\\n        return undefined;\\n      }\\n\\n      if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\\n        return undefined;\\n      }\\n\\n      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\\n        var inView = false; // Check that swiper should be inside of visible area of window\\n\\n        if (swiper.$el.parents(\\\".\\\".concat(swiper.params.slideClass)).length > 0 && swiper.$el.parents(\\\".\\\".concat(swiper.params.slideActiveClass)).length === 0) {\\n          return undefined;\\n        }\\n\\n        var $el = swiper.$el;\\n        var swiperWidth = $el[0].clientWidth;\\n        var swiperHeight = $el[0].clientHeight;\\n        var windowWidth = window.innerWidth;\\n        var windowHeight = window.innerHeight;\\n        var swiperOffset = swiper.$el.offset();\\n\\n        if (rtl) {\\n          swiperOffset.left -= swiper.$el[0].scrollLeft;\\n        }\\n\\n        var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\\n\\n        for (var i = 0; i < swiperCoord.length; i += 1) {\\n          var point = swiperCoord[i];\\n\\n          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\\n            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\\n\\n            inView = true;\\n          }\\n        }\\n\\n        if (!inView) {\\n          return undefined;\\n        }\\n      }\\n\\n      if (swiper.isHorizontal()) {\\n        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\\n          if (e.preventDefault) {\\n            e.preventDefault();\\n          } else {\\n            e.returnValue = false;\\n          }\\n        }\\n\\n        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) {\\n          swiper.slideNext();\\n        }\\n\\n        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) {\\n          swiper.slidePrev();\\n        }\\n      } else {\\n        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\\n          if (e.preventDefault) {\\n            e.preventDefault();\\n          } else {\\n            e.returnValue = false;\\n          }\\n        }\\n\\n        if (isPageDown || isArrowDown) {\\n          swiper.slideNext();\\n        }\\n\\n        if (isPageUp || isArrowUp) {\\n          swiper.slidePrev();\\n        }\\n      }\\n\\n      emit('keyPress', kc);\\n      return undefined;\\n    }\\n\\n    function enable() {\\n      if (swiper.keyboard.enabled) {\\n        return;\\n      }\\n\\n      $(document).on('keydown', handle);\\n      swiper.keyboard.enabled = true;\\n    }\\n\\n    function disable() {\\n      if (!swiper.keyboard.enabled) {\\n        return;\\n      }\\n\\n      $(document).off('keydown', handle);\\n      swiper.keyboard.enabled = false;\\n    }\\n\\n    on('init', function () {\\n      if (swiper.params.keyboard.enabled) {\\n        enable();\\n      }\\n    });\\n    on('destroy', function () {\\n      if (swiper.keyboard.enabled) {\\n        disable();\\n      }\\n    });\\n    Object.assign(swiper.keyboard, {\\n      enable: enable,\\n      disable: disable\\n    });\\n  }\\n  /* eslint-disable consistent-return */\\n\\n\\n  function Mousewheel(_ref9) {\\n    var swiper = _ref9.swiper,\\n        extendParams = _ref9.extendParams,\\n        on = _ref9.on,\\n        emit = _ref9.emit;\\n    var window = getWindow();\\n    extendParams({\\n      mousewheel: {\\n        enabled: false,\\n        releaseOnEdges: false,\\n        invert: false,\\n        forceToAxis: false,\\n        sensitivity: 1,\\n        eventsTarget: 'container',\\n        thresholdDelta: null,\\n        thresholdTime: null\\n      }\\n    });\\n    swiper.mousewheel = {\\n      enabled: false\\n    };\\n    var timeout;\\n    var lastScrollTime = now();\\n    var lastEventBeforeSnap;\\n    var recentWheelEvents = [];\\n\\n    function normalize(e) {\\n      // Reasonable defaults\\n      var PIXEL_STEP = 10;\\n      var LINE_HEIGHT = 40;\\n      var PAGE_HEIGHT = 800;\\n      var sX = 0;\\n      var sY = 0; // spinX, spinY\\n\\n      var pX = 0;\\n      var pY = 0; // pixelX, pixelY\\n      // Legacy\\n\\n      if ('detail' in e) {\\n        sY = e.detail;\\n      }\\n\\n      if ('wheelDelta' in e) {\\n        sY = -e.wheelDelta / 120;\\n      }\\n\\n      if ('wheelDeltaY' in e) {\\n        sY = -e.wheelDeltaY / 120;\\n      }\\n\\n      if ('wheelDeltaX' in e) {\\n        sX = -e.wheelDeltaX / 120;\\n      } // side scrolling on FF with DOMMouseScroll\\n\\n\\n      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\\n        sX = sY;\\n        sY = 0;\\n      }\\n\\n      pX = sX * PIXEL_STEP;\\n      pY = sY * PIXEL_STEP;\\n\\n      if ('deltaY' in e) {\\n        pY = e.deltaY;\\n      }\\n\\n      if ('deltaX' in e) {\\n        pX = e.deltaX;\\n      }\\n\\n      if (e.shiftKey && !pX) {\\n        // if user scrolls with shift he wants horizontal scroll\\n        pX = pY;\\n        pY = 0;\\n      }\\n\\n      if ((pX || pY) && e.deltaMode) {\\n        if (e.deltaMode === 1) {\\n          // delta in LINE units\\n          pX *= LINE_HEIGHT;\\n          pY *= LINE_HEIGHT;\\n        } else {\\n          // delta in PAGE units\\n          pX *= PAGE_HEIGHT;\\n          pY *= PAGE_HEIGHT;\\n        }\\n      } // Fall-back if spin cannot be determined\\n\\n\\n      if (pX && !sX) {\\n        sX = pX < 1 ? -1 : 1;\\n      }\\n\\n      if (pY && !sY) {\\n        sY = pY < 1 ? -1 : 1;\\n      }\\n\\n      return {\\n        spinX: sX,\\n        spinY: sY,\\n        pixelX: pX,\\n        pixelY: pY\\n      };\\n    }\\n\\n    function handleMouseEnter() {\\n      if (!swiper.enabled) {\\n        return;\\n      }\\n\\n      swiper.mouseEntered = true;\\n    }\\n\\n    function handleMouseLeave() {\\n      if (!swiper.enabled) {\\n        return;\\n      }\\n\\n      swiper.mouseEntered = false;\\n    }\\n\\n    function animateSlider(newEvent) {\\n      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\\n        // Prevent if delta of wheel scroll delta is below configured threshold\\n        return false;\\n      }\\n\\n      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\\n        // Prevent if time between scrolls is below configured threshold\\n        return false;\\n      } // If the movement is NOT big enough and\\n      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\\n      //   Don't go any further (avoid insignificant scroll movement).\\n\\n\\n      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\\n        // Return false as a default\\n        return true;\\n      } // If user is scrolling towards the end:\\n      //   If the slider hasn't hit the latest slide or\\n      //   if the slider is a loop and\\n      //   if the slider isn't moving right now:\\n      //     Go to next slide and\\n      //     emit a scroll event.\\n      // Else (the user is scrolling towards the beginning) and\\n      // if the slider hasn't hit the first slide or\\n      // if the slider is a loop and\\n      // if the slider isn't moving right now:\\n      //   Go to prev slide and\\n      //   emit a scroll event.\\n\\n\\n      if (newEvent.direction < 0) {\\n        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\\n          swiper.slideNext();\\n          emit('scroll', newEvent.raw);\\n        }\\n      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\\n        swiper.slidePrev();\\n        emit('scroll', newEvent.raw);\\n      } // If you got here is because an animation has been triggered so store the current time\\n\\n\\n      lastScrollTime = new window.Date().getTime(); // Return false as a default\\n\\n      return false;\\n    }\\n\\n    function releaseScroll(newEvent) {\\n      var params = swiper.params.mousewheel;\\n\\n      if (newEvent.direction < 0) {\\n        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\\n          // Return true to animate scroll on edges\\n          return true;\\n        }\\n      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\\n        // Return true to animate scroll on edges\\n        return true;\\n      }\\n\\n      return false;\\n    }\\n\\n    function handle(event) {\\n      var e = event;\\n      var disableParentSwiper = true;\\n\\n      if (!swiper.enabled) {\\n        return;\\n      }\\n\\n      var params = swiper.params.mousewheel;\\n\\n      if (swiper.params.cssMode) {\\n        e.preventDefault();\\n      }\\n\\n      var target = swiper.$el;\\n\\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\\n        target = $(swiper.params.mousewheel.eventsTarget);\\n      }\\n\\n      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) {\\n        return true;\\n      }\\n\\n      if (e.originalEvent) {\\n        e = e.originalEvent;\\n      } // jquery fix\\n\\n\\n      var delta = 0;\\n      var rtlFactor = swiper.rtlTranslate ? -1 : 1;\\n      var data = normalize(e);\\n\\n      if (params.forceToAxis) {\\n        if (swiper.isHorizontal()) {\\n          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {\\n            delta = -data.pixelX * rtlFactor;\\n          } else {\\n            return true;\\n          }\\n        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {\\n          delta = -data.pixelY;\\n        } else {\\n          return true;\\n        }\\n      } else {\\n        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\\n      }\\n\\n      if (delta === 0) {\\n        return true;\\n      }\\n\\n      if (params.invert) {\\n        delta = -delta;\\n      } // Get the scroll positions\\n\\n\\n      var positions = swiper.getTranslate() + delta * params.sensitivity;\\n\\n      if (positions >= swiper.minTranslate()) {\\n        positions = swiper.minTranslate();\\n      }\\n\\n      if (positions <= swiper.maxTranslate()) {\\n        positions = swiper.maxTranslate();\\n      } // When loop is true:\\n      //     the disableParentSwiper will be true.\\n      // When loop is false:\\n      //     if the scroll positions is not on edge,\\n      //     then the disableParentSwiper will be true.\\n      //     if the scroll on edge positions,\\n      //     then the disableParentSwiper will be false.\\n\\n\\n      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\\n\\n      if (disableParentSwiper && swiper.params.nested) {\\n        e.stopPropagation();\\n      }\\n\\n      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\\n        // Register the new event in a variable which stores the relevant data\\n        var newEvent = {\\n          time: now(),\\n          delta: Math.abs(delta),\\n          direction: Math.sign(delta),\\n          raw: event\\n        }; // Keep the most recent events\\n\\n        if (recentWheelEvents.length >= 2) {\\n          recentWheelEvents.shift(); // only store the last N events\\n        }\\n\\n        var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\\n        recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\\n        //   If direction has changed or\\n        //   if the scroll is quicker than the previous one:\\n        //     Animate the slider.\\n        // Else (this is the first time the wheel is moved):\\n        //     Animate the slider.\\n\\n        if (prevEvent) {\\n          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\\n            animateSlider(newEvent);\\n          }\\n        } else {\\n          animateSlider(newEvent);\\n        } // If it's time to release the scroll:\\n        //   Return now so you don't hit the preventDefault.\\n\\n\\n        if (releaseScroll(newEvent)) {\\n          return true;\\n        }\\n      } else {\\n        // Freemode or scrollContainer:\\n        // If we recently snapped after a momentum scroll, then ignore wheel events\\n        // to give time for the deceleration to finish. Stop ignoring after 500 msecs\\n        // or if it's a new scroll (larger delta or inverse sign as last event before\\n        // an end-of-momentum snap).\\n        var _newEvent = {\\n          time: now(),\\n          delta: Math.abs(delta),\\n          direction: Math.sign(delta)\\n        };\\n        var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\\n\\n        if (!ignoreWheelEvents) {\\n          lastEventBeforeSnap = undefined;\\n\\n          if (swiper.params.loop) {\\n            swiper.loopFix();\\n          }\\n\\n          var position = swiper.getTranslate() + delta * params.sensitivity;\\n          var wasBeginning = swiper.isBeginning;\\n          var wasEnd = swiper.isEnd;\\n\\n          if (position >= swiper.minTranslate()) {\\n            position = swiper.minTranslate();\\n          }\\n\\n          if (position <= swiper.maxTranslate()) {\\n            position = swiper.maxTranslate();\\n          }\\n\\n          swiper.setTransition(0);\\n          swiper.setTranslate(position);\\n          swiper.updateProgress();\\n          swiper.updateActiveIndex();\\n          swiper.updateSlidesClasses();\\n\\n          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\\n            swiper.updateSlidesClasses();\\n          }\\n\\n          if (swiper.params.freeMode.sticky) {\\n            // When wheel scrolling starts with sticky (aka snap) enabled, then detect\\n            // the end of a momentum scroll by storing recent (N=15?) wheel events.\\n            // 1. do all N events have decreasing or same (absolute value) delta?\\n            // 2. did all N events arrive in the last M (M=500?) msecs?\\n            // 3. does the earliest event have an (absolute value) delta that's\\n            //    at least P (P=1?) larger than the most recent event's delta?\\n            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\\n            // If 1-4 are \\\"yes\\\" then we're near the end of a momentum scroll deceleration.\\n            // Snap immediately and ignore remaining wheel events in this scroll.\\n            // See comment above for \\\"remaining wheel events in this scroll\\\" determination.\\n            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\\n            clearTimeout(timeout);\\n            timeout = undefined;\\n\\n            if (recentWheelEvents.length >= 15) {\\n              recentWheelEvents.shift(); // only store the last N events\\n            }\\n\\n            var _prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\\n\\n            var firstEvent = recentWheelEvents[0];\\n            recentWheelEvents.push(_newEvent);\\n\\n            if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\\n              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\\n              recentWheelEvents.splice(0);\\n            } else if (recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\\n              // We're at the end of the deceleration of a momentum scroll, so there's no need\\n              // to wait for more events. Snap ASAP on the next tick.\\n              // Also, because there's some remaining momentum we'll bias the snap in the\\n              // direction of the ongoing scroll because it's better UX for the scroll to snap\\n              // in the same direction as the scroll instead of reversing to snap.  Therefore,\\n              // if it's already scrolled more than 20% in the current direction, keep going.\\n              var snapToThreshold = delta > 0 ? 0.8 : 0.2;\\n              lastEventBeforeSnap = _newEvent;\\n              recentWheelEvents.splice(0);\\n              timeout = nextTick(function () {\\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\\n              }, 0); // no delay; move on next tick\\n            }\\n\\n            if (!timeout) {\\n              // if we get here, then we haven't detected the end of a momentum scroll, so\\n              // we'll consider a scroll \\\"complete\\\" when there haven't been any wheel events\\n              // for 500ms.\\n              timeout = nextTick(function () {\\n                var snapToThreshold = 0.5;\\n                lastEventBeforeSnap = _newEvent;\\n                recentWheelEvents.splice(0);\\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\\n              }, 500);\\n            }\\n          } // Emit event\\n\\n\\n          if (!ignoreWheelEvents) {\\n            emit('scroll', e);\\n          } // Stop autoplay\\n\\n\\n          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {\\n            swiper.autoplay.stop();\\n          } // Return page scroll on edge positions\\n\\n\\n          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      if (e.preventDefault) {\\n        e.preventDefault();\\n      } else {\\n        e.returnValue = false;\\n      }\\n\\n      return false;\\n    }\\n\\n    function events(method) {\\n      var target = swiper.$el;\\n\\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\\n        target = $(swiper.params.mousewheel.eventsTarget);\\n      }\\n\\n      target[method]('mouseenter', handleMouseEnter);\\n      target[method]('mouseleave', handleMouseLeave);\\n      target[method]('wheel', handle);\\n    }\\n\\n    function enable() {\\n      if (swiper.params.cssMode) {\\n        swiper.wrapperEl.removeEventListener('wheel', handle);\\n        return true;\\n      }\\n\\n      if (swiper.mousewheel.enabled) {\\n        return false;\\n      }\\n\\n      events('on');\\n      swiper.mousewheel.enabled = true;\\n      return true;\\n    }\\n\\n    function disable() {\\n      if (swiper.params.cssMode) {\\n        swiper.wrapperEl.addEventListener(event, handle);\\n        return true;\\n      }\\n\\n      if (!swiper.mousewheel.enabled) {\\n        return false;\\n      }\\n\\n      events('off');\\n      swiper.mousewheel.enabled = false;\\n      return true;\\n    }\\n\\n    on('init', function () {\\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\\n        disable();\\n      }\\n\\n      if (swiper.params.mousewheel.enabled) {\\n        enable();\\n      }\\n    });\\n    on('destroy', function () {\\n      if (swiper.params.cssMode) {\\n        enable();\\n      }\\n\\n      if (swiper.mousewheel.enabled) {\\n        disable();\\n      }\\n    });\\n    Object.assign(swiper.mousewheel, {\\n      enable: enable,\\n      disable: disable\\n    });\\n  }\\n\\n  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\\n    var document = getDocument();\\n\\n    if (swiper.params.createElements) {\\n      Object.keys(checkProps).forEach(function (key) {\\n        if (!params[key] && params.auto === true) {\\n          var element = swiper.$el.children(\\\".\\\".concat(checkProps[key]))[0];\\n\\n          if (!element) {\\n            element = document.createElement('div');\\n            element.className = checkProps[key];\\n            swiper.$el.append(element);\\n          }\\n\\n          params[key] = element;\\n          originalParams[key] = element;\\n        }\\n      });\\n    }\\n\\n    return params;\\n  }\\n\\n  function Navigation(_ref10) {\\n    var swiper = _ref10.swiper,\\n        extendParams = _ref10.extendParams,\\n        on = _ref10.on,\\n        emit = _ref10.emit;\\n    extendParams({\\n      navigation: {\\n        nextEl: null,\\n        prevEl: null,\\n        hideOnClick: false,\\n        disabledClass: 'swiper-button-disabled',\\n        hiddenClass: 'swiper-button-hidden',\\n        lockClass: 'swiper-button-lock'\\n      }\\n    });\\n    swiper.navigation = {\\n      nextEl: null,\\n      $nextEl: null,\\n      prevEl: null,\\n      $prevEl: null\\n    };\\n\\n    function getEl(el) {\\n      var $el;\\n\\n      if (el) {\\n        $el = $(el);\\n\\n        if (swiper.params.uniqueNavElements && typeof el === 'string' && $el.length > 1 && swiper.$el.find(el).length === 1) {\\n          $el = swiper.$el.find(el);\\n        }\\n      }\\n\\n      return $el;\\n    }\\n\\n    function toggleEl($el, disabled) {\\n      var params = swiper.params.navigation;\\n\\n      if ($el && $el.length > 0) {\\n        $el[disabled ? 'addClass' : 'removeClass'](params.disabledClass);\\n\\n        if ($el[0] && $el[0].tagName === 'BUTTON') {\\n          $el[0].disabled = disabled;\\n        }\\n\\n        if (swiper.params.watchOverflow && swiper.enabled) {\\n          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\\n        }\\n      }\\n    }\\n\\n    function update() {\\n      // Update Navigation Buttons\\n      if (swiper.params.loop) {\\n        return;\\n      }\\n\\n      var _swiper$navigation = swiper.navigation,\\n          $nextEl = _swiper$navigation.$nextEl,\\n          $prevEl = _swiper$navigation.$prevEl;\\n      toggleEl($prevEl, swiper.isBeginning);\\n      toggleEl($nextEl, swiper.isEnd);\\n    }\\n\\n    function onPrevClick(e) {\\n      e.preventDefault();\\n\\n      if (swiper.isBeginning && !swiper.params.loop) {\\n        return;\\n      }\\n\\n      swiper.slidePrev();\\n    }\\n\\n    function onNextClick(e) {\\n      e.preventDefault();\\n\\n      if (swiper.isEnd && !swiper.params.loop) {\\n        return;\\n      }\\n\\n      swiper.slideNext();\\n    }\\n\\n    function init() {\\n      var params = swiper.params.navigation;\\n      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\\n        nextEl: 'swiper-button-next',\\n        prevEl: 'swiper-button-prev'\\n      });\\n\\n      if (!(params.nextEl || params.prevEl)) {\\n        return;\\n      }\\n\\n      var $nextEl = getEl(params.nextEl);\\n      var $prevEl = getEl(params.prevEl);\\n\\n      if ($nextEl && $nextEl.length > 0) {\\n        $nextEl.on('click', onNextClick);\\n      }\\n\\n      if ($prevEl && $prevEl.length > 0) {\\n        $prevEl.on('click', onPrevClick);\\n      }\\n\\n      Object.assign(swiper.navigation, {\\n        $nextEl: $nextEl,\\n        nextEl: $nextEl && $nextEl[0],\\n        $prevEl: $prevEl,\\n        prevEl: $prevEl && $prevEl[0]\\n      });\\n\\n      if (!swiper.enabled) {\\n        if ($nextEl) {\\n          $nextEl.addClass(params.lockClass);\\n        }\\n\\n        if ($prevEl) {\\n          $prevEl.addClass(params.lockClass);\\n        }\\n      }\\n    }\\n\\n    function destroy() {\\n      var _swiper$navigation2 = swiper.navigation,\\n          $nextEl = _swiper$navigation2.$nextEl,\\n          $prevEl = _swiper$navigation2.$prevEl;\\n\\n      if ($nextEl && $nextEl.length) {\\n        $nextEl.off('click', onNextClick);\\n        $nextEl.removeClass(swiper.params.navigation.disabledClass);\\n      }\\n\\n      if ($prevEl && $prevEl.length) {\\n        $prevEl.off('click', onPrevClick);\\n        $prevEl.removeClass(swiper.params.navigation.disabledClass);\\n      }\\n    }\\n\\n    on('init', function () {\\n      init();\\n      update();\\n    });\\n    on('toEdge fromEdge lock unlock', function () {\\n      update();\\n    });\\n    on('destroy', function () {\\n      destroy();\\n    });\\n    on('enable disable', function () {\\n      var _swiper$navigation3 = swiper.navigation,\\n          $nextEl = _swiper$navigation3.$nextEl,\\n          $prevEl = _swiper$navigation3.$prevEl;\\n\\n      if ($nextEl) {\\n        $nextEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\\n      }\\n\\n      if ($prevEl) {\\n        $prevEl[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.navigation.lockClass);\\n      }\\n    });\\n    on('click', function (_s, e) {\\n      var _swiper$navigation4 = swiper.navigation,\\n          $nextEl = _swiper$navigation4.$nextEl,\\n          $prevEl = _swiper$navigation4.$prevEl;\\n      var targetEl = e.target;\\n\\n      if (swiper.params.navigation.hideOnClick && !$(targetEl).is($prevEl) && !$(targetEl).is($nextEl)) {\\n        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) {\\n          return;\\n        }\\n\\n        var isHidden;\\n\\n        if ($nextEl) {\\n          isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);\\n        } else if ($prevEl) {\\n          isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);\\n        }\\n\\n        if (isHidden === true) {\\n          emit('navigationShow');\\n        } else {\\n          emit('navigationHide');\\n        }\\n\\n        if ($nextEl) {\\n          $nextEl.toggleClass(swiper.params.navigation.hiddenClass);\\n        }\\n\\n        if ($prevEl) {\\n          $prevEl.toggleClass(swiper.params.navigation.hiddenClass);\\n        }\\n      }\\n    });\\n    Object.assign(swiper.navigation, {\\n      update: update,\\n      init: init,\\n      destroy: destroy\\n    });\\n  }\\n\\n  function classesToSelector() {\\n    var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\\n    return \\\".\\\".concat(classes.trim().replace(/([\\\\.:!\\\\/])/g, '\\\\\\\\$1') // eslint-disable-line\\n    .replace(/ /g, '.'));\\n  }\\n\\n  function Pagination(_ref11) {\\n    var swiper = _ref11.swiper,\\n        extendParams = _ref11.extendParams,\\n        on = _ref11.on,\\n        emit = _ref11.emit;\\n    var pfx = 'swiper-pagination';\\n    extendParams({\\n      pagination: {\\n        el: null,\\n        bulletElement: 'span',\\n        clickable: false,\\n        hideOnClick: false,\\n        renderBullet: null,\\n        renderProgressbar: null,\\n        renderFraction: null,\\n        renderCustom: null,\\n        progressbarOpposite: false,\\n        type: 'bullets',\\n        // 'bullets' or 'progressbar' or 'fraction' or 'custom'\\n        dynamicBullets: false,\\n        dynamicMainBullets: 1,\\n        formatFractionCurrent: function formatFractionCurrent(number) {\\n          return number;\\n        },\\n        formatFractionTotal: function formatFractionTotal(number) {\\n          return number;\\n        },\\n        bulletClass: \\\"\\\".concat(pfx, \\\"-bullet\\\"),\\n        bulletActiveClass: \\\"\\\".concat(pfx, \\\"-bullet-active\\\"),\\n        modifierClass: \\\"\\\".concat(pfx, \\\"-\\\"),\\n        currentClass: \\\"\\\".concat(pfx, \\\"-current\\\"),\\n        totalClass: \\\"\\\".concat(pfx, \\\"-total\\\"),\\n        hiddenClass: \\\"\\\".concat(pfx, \\\"-hidden\\\"),\\n        progressbarFillClass: \\\"\\\".concat(pfx, \\\"-progressbar-fill\\\"),\\n        progressbarOppositeClass: \\\"\\\".concat(pfx, \\\"-progressbar-opposite\\\"),\\n        clickableClass: \\\"\\\".concat(pfx, \\\"-clickable\\\"),\\n        lockClass: \\\"\\\".concat(pfx, \\\"-lock\\\"),\\n        horizontalClass: \\\"\\\".concat(pfx, \\\"-horizontal\\\"),\\n        verticalClass: \\\"\\\".concat(pfx, \\\"-vertical\\\")\\n      }\\n    });\\n    swiper.pagination = {\\n      el: null,\\n      $el: null,\\n      bullets: []\\n    };\\n    var bulletSize;\\n    var dynamicBulletIndex = 0;\\n\\n    function isPaginationDisabled() {\\n      return !swiper.params.pagination.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0;\\n    }\\n\\n    function setSideBullets($bulletEl, position) {\\n      var bulletActiveClass = swiper.params.pagination.bulletActiveClass;\\n      $bulletEl[position]().addClass(\\\"\\\".concat(bulletActiveClass, \\\"-\\\").concat(position))[position]().addClass(\\\"\\\".concat(bulletActiveClass, \\\"-\\\").concat(position, \\\"-\\\").concat(position));\\n    }\\n\\n    function update() {\\n      // Render || Update Pagination bullets/items\\n      var rtl = swiper.rtl;\\n      var params = swiper.params.pagination;\\n\\n      if (isPaginationDisabled()) {\\n        return;\\n      }\\n\\n      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\\n      var $el = swiper.pagination.$el; // Current/Total\\n\\n      var current;\\n      var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\\n\\n      if (swiper.params.loop) {\\n        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);\\n\\n        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {\\n          current -= slidesLength - swiper.loopedSlides * 2;\\n        }\\n\\n        if (current > total - 1) {\\n          current -= total;\\n        }\\n\\n        if (current < 0 && swiper.params.paginationType !== 'bullets') {\\n          current = total + current;\\n        }\\n      } else if (typeof swiper.snapIndex !== 'undefined') {\\n        current = swiper.snapIndex;\\n      } else {\\n        current = swiper.activeIndex || 0;\\n      } // Types\\n\\n\\n      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\\n        var bullets = swiper.pagination.bullets;\\n        var firstIndex;\\n        var lastIndex;\\n        var midIndex;\\n\\n        if (params.dynamicBullets) {\\n          bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);\\n          $el.css(swiper.isHorizontal() ? 'width' : 'height', \\\"\\\".concat(bulletSize * (params.dynamicMainBullets + 4), \\\"px\\\"));\\n\\n          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {\\n            dynamicBulletIndex += current - swiper.previousIndex;\\n\\n            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\\n              dynamicBulletIndex = params.dynamicMainBullets - 1;\\n            } else if (dynamicBulletIndex < 0) {\\n              dynamicBulletIndex = 0;\\n            }\\n          }\\n\\n          firstIndex = current - dynamicBulletIndex;\\n          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\\n          midIndex = (lastIndex + firstIndex) / 2;\\n        }\\n\\n        bullets.removeClass(['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(function (suffix) {\\n          return \\\"\\\".concat(params.bulletActiveClass).concat(suffix);\\n        }).join(' '));\\n\\n        if ($el.length > 1) {\\n          bullets.each(function (bullet) {\\n            var $bullet = $(bullet);\\n            var bulletIndex = $bullet.index();\\n\\n            if (bulletIndex === current) {\\n              $bullet.addClass(params.bulletActiveClass);\\n            }\\n\\n            if (params.dynamicBullets) {\\n              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\\n                $bullet.addClass(\\\"\\\".concat(params.bulletActiveClass, \\\"-main\\\"));\\n              }\\n\\n              if (bulletIndex === firstIndex) {\\n                setSideBullets($bullet, 'prev');\\n              }\\n\\n              if (bulletIndex === lastIndex) {\\n                setSideBullets($bullet, 'next');\\n              }\\n            }\\n          });\\n        } else {\\n          var $bullet = bullets.eq(current);\\n          var bulletIndex = $bullet.index();\\n          $bullet.addClass(params.bulletActiveClass);\\n\\n          if (params.dynamicBullets) {\\n            var $firstDisplayedBullet = bullets.eq(firstIndex);\\n            var $lastDisplayedBullet = bullets.eq(lastIndex);\\n\\n            for (var i = firstIndex; i <= lastIndex; i += 1) {\\n              bullets.eq(i).addClass(\\\"\\\".concat(params.bulletActiveClass, \\\"-main\\\"));\\n            }\\n\\n            if (swiper.params.loop) {\\n              if (bulletIndex >= bullets.length - params.dynamicMainBullets) {\\n                for (var _i8 = params.dynamicMainBullets; _i8 >= 0; _i8 -= 1) {\\n                  bullets.eq(bullets.length - _i8).addClass(\\\"\\\".concat(params.bulletActiveClass, \\\"-main\\\"));\\n                }\\n\\n                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(\\\"\\\".concat(params.bulletActiveClass, \\\"-prev\\\"));\\n              } else {\\n                setSideBullets($firstDisplayedBullet, 'prev');\\n                setSideBullets($lastDisplayedBullet, 'next');\\n              }\\n            } else {\\n              setSideBullets($firstDisplayedBullet, 'prev');\\n              setSideBullets($lastDisplayedBullet, 'next');\\n            }\\n          }\\n        }\\n\\n        if (params.dynamicBullets) {\\n          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\\n          var bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\\n          var offsetProp = rtl ? 'right' : 'left';\\n          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', \\\"\\\".concat(bulletsOffset, \\\"px\\\"));\\n        }\\n      }\\n\\n      if (params.type === 'fraction') {\\n        $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));\\n        $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));\\n      }\\n\\n      if (params.type === 'progressbar') {\\n        var progressbarDirection;\\n\\n        if (params.progressbarOpposite) {\\n          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\\n        } else {\\n          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\\n        }\\n\\n        var scale = (current + 1) / total;\\n        var scaleX = 1;\\n        var scaleY = 1;\\n\\n        if (progressbarDirection === 'horizontal') {\\n          scaleX = scale;\\n        } else {\\n          scaleY = scale;\\n        }\\n\\n        $el.find(classesToSelector(params.progressbarFillClass)).transform(\\\"translate3d(0,0,0) scaleX(\\\".concat(scaleX, \\\") scaleY(\\\").concat(scaleY, \\\")\\\")).transition(swiper.params.speed);\\n      }\\n\\n      if (params.type === 'custom' && params.renderCustom) {\\n        $el.html(params.renderCustom(swiper, current + 1, total));\\n        emit('paginationRender', $el[0]);\\n      } else {\\n        emit('paginationUpdate', $el[0]);\\n      }\\n\\n      if (swiper.params.watchOverflow && swiper.enabled) {\\n        $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);\\n      }\\n    }\\n\\n    function render() {\\n      // Render Container\\n      var params = swiper.params.pagination;\\n\\n      if (isPaginationDisabled()) {\\n        return;\\n      }\\n\\n      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\\n      var $el = swiper.pagination.$el;\\n      var paginationHTML = '';\\n\\n      if (params.type === 'bullets') {\\n        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\\n\\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.loop && numberOfBullets > slidesLength) {\\n          numberOfBullets = slidesLength;\\n        }\\n\\n        for (var i = 0; i < numberOfBullets; i += 1) {\\n          if (params.renderBullet) {\\n            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\\n          } else {\\n            paginationHTML += \\\"<\\\".concat(params.bulletElement, \\\" class=\\\\\\\"\\\").concat(params.bulletClass, \\\"\\\\\\\"></\\\").concat(params.bulletElement, \\\">\\\");\\n          }\\n        }\\n\\n        $el.html(paginationHTML);\\n        swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));\\n      }\\n\\n      if (params.type === 'fraction') {\\n        if (params.renderFraction) {\\n          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\\n        } else {\\n          paginationHTML = \\\"<span class=\\\\\\\"\\\".concat(params.currentClass, \\\"\\\\\\\"></span>\\\") + ' / ' + \\\"<span class=\\\\\\\"\\\".concat(params.totalClass, \\\"\\\\\\\"></span>\\\");\\n        }\\n\\n        $el.html(paginationHTML);\\n      }\\n\\n      if (params.type === 'progressbar') {\\n        if (params.renderProgressbar) {\\n          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\\n        } else {\\n          paginationHTML = \\\"<span class=\\\\\\\"\\\".concat(params.progressbarFillClass, \\\"\\\\\\\"></span>\\\");\\n        }\\n\\n        $el.html(paginationHTML);\\n      }\\n\\n      if (params.type !== 'custom') {\\n        emit('paginationRender', swiper.pagination.$el[0]);\\n      }\\n    }\\n\\n    function init() {\\n      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\\n        el: 'swiper-pagination'\\n      });\\n      var params = swiper.params.pagination;\\n\\n      if (!params.el) {\\n        return;\\n      }\\n\\n      var $el = $(params.el);\\n\\n      if ($el.length === 0) {\\n        return;\\n      }\\n\\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {\\n        $el = swiper.$el.find(params.el); // check if it belongs to another nested Swiper\\n\\n        if ($el.length > 1) {\\n          $el = $el.filter(function (el) {\\n            if ($(el).parents('.swiper')[0] !== swiper.el) {\\n              return false;\\n            }\\n\\n            return true;\\n          });\\n        }\\n      }\\n\\n      if (params.type === 'bullets' && params.clickable) {\\n        $el.addClass(params.clickableClass);\\n      }\\n\\n      $el.addClass(params.modifierClass + params.type);\\n      $el.addClass(params.modifierClass + swiper.params.direction);\\n\\n      if (params.type === 'bullets' && params.dynamicBullets) {\\n        $el.addClass(\\\"\\\".concat(params.modifierClass).concat(params.type, \\\"-dynamic\\\"));\\n        dynamicBulletIndex = 0;\\n\\n        if (params.dynamicMainBullets < 1) {\\n          params.dynamicMainBullets = 1;\\n        }\\n      }\\n\\n      if (params.type === 'progressbar' && params.progressbarOpposite) {\\n        $el.addClass(params.progressbarOppositeClass);\\n      }\\n\\n      if (params.clickable) {\\n        $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {\\n          e.preventDefault();\\n          var index = $(this).index() * swiper.params.slidesPerGroup;\\n\\n          if (swiper.params.loop) {\\n            index += swiper.loopedSlides;\\n          }\\n\\n          swiper.slideTo(index);\\n        });\\n      }\\n\\n      Object.assign(swiper.pagination, {\\n        $el: $el,\\n        el: $el[0]\\n      });\\n\\n      if (!swiper.enabled) {\\n        $el.addClass(params.lockClass);\\n      }\\n    }\\n\\n    function destroy() {\\n      var params = swiper.params.pagination;\\n\\n      if (isPaginationDisabled()) {\\n        return;\\n      }\\n\\n      var $el = swiper.pagination.$el;\\n      $el.removeClass(params.hiddenClass);\\n      $el.removeClass(params.modifierClass + params.type);\\n      $el.removeClass(params.modifierClass + swiper.params.direction);\\n\\n      if (swiper.pagination.bullets && swiper.pagination.bullets.removeClass) {\\n        swiper.pagination.bullets.removeClass(params.bulletActiveClass);\\n      }\\n\\n      if (params.clickable) {\\n        $el.off('click', classesToSelector(params.bulletClass));\\n      }\\n    }\\n\\n    on('init', function () {\\n      init();\\n      render();\\n      update();\\n    });\\n    on('activeIndexChange', function () {\\n      if (swiper.params.loop) {\\n        update();\\n      } else if (typeof swiper.snapIndex === 'undefined') {\\n        update();\\n      }\\n    });\\n    on('snapIndexChange', function () {\\n      if (!swiper.params.loop) {\\n        update();\\n      }\\n    });\\n    on('slidesLengthChange', function () {\\n      if (swiper.params.loop) {\\n        render();\\n        update();\\n      }\\n    });\\n    on('snapGridLengthChange', function () {\\n      if (!swiper.params.loop) {\\n        render();\\n        update();\\n      }\\n    });\\n    on('destroy', function () {\\n      destroy();\\n    });\\n    on('enable disable', function () {\\n      var $el = swiper.pagination.$el;\\n\\n      if ($el) {\\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);\\n      }\\n    });\\n    on('lock unlock', function () {\\n      update();\\n    });\\n    on('click', function (_s, e) {\\n      var targetEl = e.target;\\n      var $el = swiper.pagination.$el;\\n\\n      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && $el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {\\n        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) {\\n          return;\\n        }\\n\\n        var isHidden = $el.hasClass(swiper.params.pagination.hiddenClass);\\n\\n        if (isHidden === true) {\\n          emit('paginationShow');\\n        } else {\\n          emit('paginationHide');\\n        }\\n\\n        $el.toggleClass(swiper.params.pagination.hiddenClass);\\n      }\\n    });\\n    Object.assign(swiper.pagination, {\\n      render: render,\\n      update: update,\\n      init: init,\\n      destroy: destroy\\n    });\\n  }\\n\\n  function Scrollbar(_ref12) {\\n    var swiper = _ref12.swiper,\\n        extendParams = _ref12.extendParams,\\n        on = _ref12.on,\\n        emit = _ref12.emit;\\n    var document = getDocument();\\n    var isTouched = false;\\n    var timeout = null;\\n    var dragTimeout = null;\\n    var dragStartPos;\\n    var dragSize;\\n    var trackSize;\\n    var divider;\\n    extendParams({\\n      scrollbar: {\\n        el: null,\\n        dragSize: 'auto',\\n        hide: false,\\n        draggable: false,\\n        snapOnRelease: true,\\n        lockClass: 'swiper-scrollbar-lock',\\n        dragClass: 'swiper-scrollbar-drag'\\n      }\\n    });\\n    swiper.scrollbar = {\\n      el: null,\\n      dragEl: null,\\n      $el: null,\\n      $dragEl: null\\n    };\\n\\n    function setTranslate() {\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {\\n        return;\\n      }\\n\\n      var scrollbar = swiper.scrollbar,\\n          rtl = swiper.rtlTranslate,\\n          progress = swiper.progress;\\n      var $dragEl = scrollbar.$dragEl,\\n          $el = scrollbar.$el;\\n      var params = swiper.params.scrollbar;\\n      var newSize = dragSize;\\n      var newPos = (trackSize - dragSize) * progress;\\n\\n      if (rtl) {\\n        newPos = -newPos;\\n\\n        if (newPos > 0) {\\n          newSize = dragSize - newPos;\\n          newPos = 0;\\n        } else if (-newPos + dragSize > trackSize) {\\n          newSize = trackSize + newPos;\\n        }\\n      } else if (newPos < 0) {\\n        newSize = dragSize + newPos;\\n        newPos = 0;\\n      } else if (newPos + dragSize > trackSize) {\\n        newSize = trackSize - newPos;\\n      }\\n\\n      if (swiper.isHorizontal()) {\\n        $dragEl.transform(\\\"translate3d(\\\".concat(newPos, \\\"px, 0, 0)\\\"));\\n        $dragEl[0].style.width = \\\"\\\".concat(newSize, \\\"px\\\");\\n      } else {\\n        $dragEl.transform(\\\"translate3d(0px, \\\".concat(newPos, \\\"px, 0)\\\"));\\n        $dragEl[0].style.height = \\\"\\\".concat(newSize, \\\"px\\\");\\n      }\\n\\n      if (params.hide) {\\n        clearTimeout(timeout);\\n        $el[0].style.opacity = 1;\\n        timeout = setTimeout(function () {\\n          $el[0].style.opacity = 0;\\n          $el.transition(400);\\n        }, 1000);\\n      }\\n    }\\n\\n    function setTransition(duration) {\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {\\n        return;\\n      }\\n\\n      swiper.scrollbar.$dragEl.transition(duration);\\n    }\\n\\n    function updateSize() {\\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {\\n        return;\\n      }\\n\\n      var scrollbar = swiper.scrollbar;\\n      var $dragEl = scrollbar.$dragEl,\\n          $el = scrollbar.$el;\\n      $dragEl[0].style.width = '';\\n      $dragEl[0].style.height = '';\\n      trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;\\n      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\\n\\n      if (swiper.params.scrollbar.dragSize === 'auto') {\\n        dragSize = trackSize * divider;\\n      } else {\\n        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\\n      }\\n\\n      if (swiper.isHorizontal()) {\\n        $dragEl[0].style.width = \\\"\\\".concat(dragSize, \\\"px\\\");\\n      } else {\\n        $dragEl[0].style.height = \\\"\\\".concat(dragSize, \\\"px\\\");\\n      }\\n\\n      if (divider >= 1) {\\n        $el[0].style.display = 'none';\\n      } else {\\n        $el[0].style.display = '';\\n      }\\n\\n      if (swiper.params.scrollbar.hide) {\\n        $el[0].style.opacity = 0;\\n      }\\n\\n      if (swiper.params.watchOverflow && swiper.enabled) {\\n        scrollbar.$el[swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);\\n      }\\n    }\\n\\n    function getPointerPosition(e) {\\n      if (swiper.isHorizontal()) {\\n        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;\\n      }\\n\\n      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;\\n    }\\n\\n    function setDragPosition(e) {\\n      var scrollbar = swiper.scrollbar,\\n          rtl = swiper.rtlTranslate;\\n      var $el = scrollbar.$el;\\n      var positionRatio;\\n      positionRatio = (getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\\n      positionRatio = Math.max(Math.min(positionRatio, 1), 0);\\n\\n      if (rtl) {\\n        positionRatio = 1 - positionRatio;\\n      }\\n\\n      var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\\n      swiper.updateProgress(position);\\n      swiper.setTranslate(position);\\n      swiper.updateActiveIndex();\\n      swiper.updateSlidesClasses();\\n    }\\n\\n    function onDragStart(e) {\\n      var params = swiper.params.scrollbar;\\n      var scrollbar = swiper.scrollbar,\\n          $wrapperEl = swiper.$wrapperEl;\\n      var $el = scrollbar.$el,\\n          $dragEl = scrollbar.$dragEl;\\n      isTouched = true;\\n      dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\\n      e.preventDefault();\\n      e.stopPropagation();\\n      $wrapperEl.transition(100);\\n      $dragEl.transition(100);\\n      setDragPosition(e);\\n      clearTimeout(dragTimeout);\\n      $el.transition(0);\\n\\n      if (params.hide) {\\n        $el.css('opacity', 1);\\n      }\\n\\n      if (swiper.params.cssMode) {\\n        swiper.$wrapperEl.css('scroll-snap-type', 'none');\\n      }\\n\\n      emit('scrollbarDragStart', e);\\n    }\\n\\n    function onDragMove(e) {\\n      var scrollbar = swiper.scrollbar,\\n          $wrapperEl = swiper.$wrapperEl;\\n      var $el = scrollbar.$el,\\n          $dragEl = scrollbar.$dragEl;\\n\\n      if (!isTouched) {\\n        return;\\n      }\\n\\n      if (e.preventDefault) {\\n        e.preventDefault();\\n      } else {\\n        e.returnValue = false;\\n      }\\n\\n      setDragPosition(e);\\n      $wrapperEl.transition(0);\\n      $el.transition(0);\\n      $dragEl.transition(0);\\n      emit('scrollbarDragMove', e);\\n    }\\n\\n    function onDragEnd(e) {\\n      var params = swiper.params.scrollbar;\\n      var scrollbar = swiper.scrollbar,\\n          $wrapperEl = swiper.$wrapperEl;\\n      var $el = scrollbar.$el;\\n\\n      if (!isTouched) {\\n        return;\\n      }\\n\\n      isTouched = false;\\n\\n      if (swiper.params.cssMode) {\\n        swiper.$wrapperEl.css('scroll-snap-type', '');\\n        $wrapperEl.transition('');\\n      }\\n\\n      if (params.hide) {\\n        clearTimeout(dragTimeout);\\n        dragTimeout = nextTick(function () {\\n          $el.css('opacity', 0);\\n          $el.transition(400);\\n        }, 1000);\\n      }\\n\\n      emit('scrollbarDragEnd', e);\\n\\n      if (params.snapOnRelease) {\\n        swiper.slideToClosest();\\n      }\\n    }\\n\\n    function events(method) {\\n      var scrollbar = swiper.scrollbar,\\n          touchEventsTouch = swiper.touchEventsTouch,\\n          touchEventsDesktop = swiper.touchEventsDesktop,\\n          params = swiper.params,\\n          support = swiper.support;\\n      var $el = scrollbar.$el;\\n      var target = $el[0];\\n      var activeListener = support.passiveListener && params.passiveListeners ? {\\n        passive: false,\\n        capture: false\\n      } : false;\\n      var passiveListener = support.passiveListener && params.passiveListeners ? {\\n        passive: true,\\n        capture: false\\n      } : false;\\n\\n      if (!target) {\\n        return;\\n      }\\n\\n      var eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\\n\\n      if (!support.touch) {\\n        target[eventMethod](touchEventsDesktop.start, onDragStart, activeListener);\\n        document[eventMethod](touchEventsDesktop.move, onDragMove, activeListener);\\n        document[eventMethod](touchEventsDesktop.end, onDragEnd, passiveListener);\\n      } else {\\n        target[eventMethod](touchEventsTouch.start, onDragStart, activeListener);\\n        target[eventMethod](touchEventsTouch.move, onDragMove, activeListener);\\n        target[eventMethod](touchEventsTouch.end, onDragEnd, passiveListener);\\n      }\\n    }\\n\\n    function enableDraggable() {\\n      if (!swiper.params.scrollbar.el) {\\n        return;\\n      }\\n\\n      events('on');\\n    }\\n\\n    function disableDraggable() {\\n      if (!swiper.params.scrollbar.el) {\\n        return;\\n      }\\n\\n      events('off');\\n    }\\n\\n    function init() {\\n      var scrollbar = swiper.scrollbar,\\n          $swiperEl = swiper.$el;\\n      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\\n        el: 'swiper-scrollbar'\\n      });\\n      var params = swiper.params.scrollbar;\\n\\n      if (!params.el) {\\n        return;\\n      }\\n\\n      var $el = $(params.el);\\n\\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {\\n        $el = $swiperEl.find(params.el);\\n      }\\n\\n      var $dragEl = $el.find(\\\".\\\".concat(swiper.params.scrollbar.dragClass));\\n\\n      if ($dragEl.length === 0) {\\n        $dragEl = $(\\\"<div class=\\\\\\\"\\\".concat(swiper.params.scrollbar.dragClass, \\\"\\\\\\\"></div>\\\"));\\n        $el.append($dragEl);\\n      }\\n\\n      Object.assign(scrollbar, {\\n        $el: $el,\\n        el: $el[0],\\n        $dragEl: $dragEl,\\n        dragEl: $dragEl[0]\\n      });\\n\\n      if (params.draggable) {\\n        enableDraggable();\\n      }\\n\\n      if ($el) {\\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\\n      }\\n    }\\n\\n    function destroy() {\\n      disableDraggable();\\n    }\\n\\n    on('init', function () {\\n      init();\\n      updateSize();\\n      setTranslate();\\n    });\\n    on('update resize observerUpdate lock unlock', function () {\\n      updateSize();\\n    });\\n    on('setTranslate', function () {\\n      setTranslate();\\n    });\\n    on('setTransition', function (_s, duration) {\\n      setTransition(duration);\\n    });\\n    on('enable disable', function () {\\n      var $el = swiper.scrollbar.$el;\\n\\n      if ($el) {\\n        $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.scrollbar.lockClass);\\n      }\\n    });\\n    on('destroy', function () {\\n      destroy();\\n    });\\n    Object.assign(swiper.scrollbar, {\\n      updateSize: updateSize,\\n      setTranslate: setTranslate,\\n      init: init,\\n      destroy: destroy\\n    });\\n  }\\n\\n  function Parallax(_ref13) {\\n    var swiper = _ref13.swiper,\\n        extendParams = _ref13.extendParams,\\n        on = _ref13.on;\\n    extendParams({\\n      parallax: {\\n        enabled: false\\n      }\\n    });\\n\\n    var setTransform = function setTransform(el, progress) {\\n      var rtl = swiper.rtl;\\n      var $el = $(el);\\n      var rtlFactor = rtl ? -1 : 1;\\n      var p = $el.attr('data-swiper-parallax') || '0';\\n      var x = $el.attr('data-swiper-parallax-x');\\n      var y = $el.attr('data-swiper-parallax-y');\\n      var scale = $el.attr('data-swiper-parallax-scale');\\n      var opacity = $el.attr('data-swiper-parallax-opacity');\\n\\n      if (x || y) {\\n        x = x || '0';\\n        y = y || '0';\\n      } else if (swiper.isHorizontal()) {\\n        x = p;\\n        y = '0';\\n      } else {\\n        y = p;\\n        x = '0';\\n      }\\n\\n      if (x.indexOf('%') >= 0) {\\n        x = \\\"\\\".concat(parseInt(x, 10) * progress * rtlFactor, \\\"%\\\");\\n      } else {\\n        x = \\\"\\\".concat(x * progress * rtlFactor, \\\"px\\\");\\n      }\\n\\n      if (y.indexOf('%') >= 0) {\\n        y = \\\"\\\".concat(parseInt(y, 10) * progress, \\\"%\\\");\\n      } else {\\n        y = \\\"\\\".concat(y * progress, \\\"px\\\");\\n      }\\n\\n      if (typeof opacity !== 'undefined' && opacity !== null) {\\n        var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\\n        $el[0].style.opacity = currentOpacity;\\n      }\\n\\n      if (typeof scale === 'undefined' || scale === null) {\\n        $el.transform(\\\"translate3d(\\\".concat(x, \\\", \\\").concat(y, \\\", 0px)\\\"));\\n      } else {\\n        var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\\n        $el.transform(\\\"translate3d(\\\".concat(x, \\\", \\\").concat(y, \\\", 0px) scale(\\\").concat(currentScale, \\\")\\\"));\\n      }\\n    };\\n\\n    var setTranslate = function setTranslate() {\\n      var $el = swiper.$el,\\n          slides = swiper.slides,\\n          progress = swiper.progress,\\n          snapGrid = swiper.snapGrid;\\n      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {\\n        setTransform(el, progress);\\n      });\\n      slides.each(function (slideEl, slideIndex) {\\n        var slideProgress = slideEl.progress;\\n\\n        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\\n          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\\n        }\\n\\n        slideProgress = Math.min(Math.max(slideProgress, -1), 1);\\n        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (el) {\\n          setTransform(el, slideProgress);\\n        });\\n      });\\n    };\\n\\n    var setTransition = function setTransition() {\\n      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : swiper.params.speed;\\n      var $el = swiper.$el;\\n      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (parallaxEl) {\\n        var $parallaxEl = $(parallaxEl);\\n        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;\\n\\n        if (duration === 0) {\\n          parallaxDuration = 0;\\n        }\\n\\n        $parallaxEl.transition(parallaxDuration);\\n      });\\n    };\\n\\n    on('beforeInit', function () {\\n      if (!swiper.params.parallax.enabled) {\\n        return;\\n      }\\n\\n      swiper.params.watchSlidesProgress = true;\\n      swiper.originalParams.watchSlidesProgress = true;\\n    });\\n    on('init', function () {\\n      if (!swiper.params.parallax.enabled) {\\n        return;\\n      }\\n\\n      setTranslate();\\n    });\\n    on('setTranslate', function () {\\n      if (!swiper.params.parallax.enabled) {\\n        return;\\n      }\\n\\n      setTranslate();\\n    });\\n    on('setTransition', function (_swiper, duration) {\\n      if (!swiper.params.parallax.enabled) {\\n        return;\\n      }\\n\\n      setTransition(duration);\\n    });\\n  }\\n\\n  function Zoom(_ref14) {\\n    var swiper = _ref14.swiper,\\n        extendParams = _ref14.extendParams,\\n        on = _ref14.on,\\n        emit = _ref14.emit;\\n    var window = getWindow();\\n    extendParams({\\n      zoom: {\\n        enabled: false,\\n        maxRatio: 3,\\n        minRatio: 1,\\n        toggle: true,\\n        containerClass: 'swiper-zoom-container',\\n        zoomedSlideClass: 'swiper-slide-zoomed'\\n      }\\n    });\\n    swiper.zoom = {\\n      enabled: false\\n    };\\n    var currentScale = 1;\\n    var isScaling = false;\\n    var gesturesEnabled;\\n    var fakeGestureTouched;\\n    var fakeGestureMoved;\\n    var gesture = {\\n      $slideEl: undefined,\\n      slideWidth: undefined,\\n      slideHeight: undefined,\\n      $imageEl: undefined,\\n      $imageWrapEl: undefined,\\n      maxRatio: 3\\n    };\\n    var image = {\\n      isTouched: undefined,\\n      isMoved: undefined,\\n      currentX: undefined,\\n      currentY: undefined,\\n      minX: undefined,\\n      minY: undefined,\\n      maxX: undefined,\\n      maxY: undefined,\\n      width: undefined,\\n      height: undefined,\\n      startX: undefined,\\n      startY: undefined,\\n      touchesStart: {},\\n      touchesCurrent: {}\\n    };\\n    var velocity = {\\n      x: undefined,\\n      y: undefined,\\n      prevPositionX: undefined,\\n      prevPositionY: undefined,\\n      prevTime: undefined\\n    };\\n    var scale = 1;\\n    Object.defineProperty(swiper.zoom, 'scale', {\\n      get: function get() {\\n        return scale;\\n      },\\n      set: function set(value) {\\n        if (scale !== value) {\\n          var imageEl = gesture.$imageEl ? gesture.$imageEl[0] : undefined;\\n          var slideEl = gesture.$slideEl ? gesture.$slideEl[0] : undefined;\\n          emit('zoomChange', value, imageEl, slideEl);\\n        }\\n\\n        scale = value;\\n      }\\n    });\\n\\n    function getDistanceBetweenTouches(e) {\\n      if (e.targetTouches.length < 2) {\\n        return 1;\\n      }\\n\\n      var x1 = e.targetTouches[0].pageX;\\n      var y1 = e.targetTouches[0].pageY;\\n      var x2 = e.targetTouches[1].pageX;\\n      var y2 = e.targetTouches[1].pageY;\\n      var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\\n      return distance;\\n    } // Events\\n\\n\\n    function onGestureStart(e) {\\n      var support = swiper.support;\\n      var params = swiper.params.zoom;\\n      fakeGestureTouched = false;\\n      fakeGestureMoved = false;\\n\\n      if (!support.gestures) {\\n        if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {\\n          return;\\n        }\\n\\n        fakeGestureTouched = true;\\n        gesture.scaleStart = getDistanceBetweenTouches(e);\\n      }\\n\\n      if (!gesture.$slideEl || !gesture.$slideEl.length) {\\n        gesture.$slideEl = $(e.target).closest(\\\".\\\".concat(swiper.params.slideClass));\\n\\n        if (gesture.$slideEl.length === 0) {\\n          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\\n        }\\n\\n        gesture.$imageEl = gesture.$slideEl.find(\\\".\\\".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);\\n        gesture.$imageWrapEl = gesture.$imageEl.parent(\\\".\\\".concat(params.containerClass));\\n        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n\\n        if (gesture.$imageWrapEl.length === 0) {\\n          gesture.$imageEl = undefined;\\n          return;\\n        }\\n      }\\n\\n      if (gesture.$imageEl) {\\n        gesture.$imageEl.transition(0);\\n      }\\n\\n      isScaling = true;\\n    }\\n\\n    function onGestureChange(e) {\\n      var support = swiper.support;\\n      var params = swiper.params.zoom;\\n      var zoom = swiper.zoom;\\n\\n      if (!support.gestures) {\\n        if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {\\n          return;\\n        }\\n\\n        fakeGestureMoved = true;\\n        gesture.scaleMove = getDistanceBetweenTouches(e);\\n      }\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\\n        if (e.type === 'gesturechange') {\\n          onGestureStart(e);\\n        }\\n\\n        return;\\n      }\\n\\n      if (support.gestures) {\\n        zoom.scale = e.scale * currentScale;\\n      } else {\\n        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\\n      }\\n\\n      if (zoom.scale > gesture.maxRatio) {\\n        zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);\\n      }\\n\\n      if (zoom.scale < params.minRatio) {\\n        zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);\\n      }\\n\\n      gesture.$imageEl.transform(\\\"translate3d(0,0,0) scale(\\\".concat(zoom.scale, \\\")\\\"));\\n    }\\n\\n    function onGestureEnd(e) {\\n      var device = swiper.device;\\n      var support = swiper.support;\\n      var params = swiper.params.zoom;\\n      var zoom = swiper.zoom;\\n\\n      if (!support.gestures) {\\n        if (!fakeGestureTouched || !fakeGestureMoved) {\\n          return;\\n        }\\n\\n        if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !device.android) {\\n          return;\\n        }\\n\\n        fakeGestureTouched = false;\\n        fakeGestureMoved = false;\\n      }\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\\n        return;\\n      }\\n\\n      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\\n      gesture.$imageEl.transition(swiper.params.speed).transform(\\\"translate3d(0,0,0) scale(\\\".concat(zoom.scale, \\\")\\\"));\\n      currentScale = zoom.scale;\\n      isScaling = false;\\n\\n      if (zoom.scale === 1) {\\n        gesture.$slideEl = undefined;\\n      }\\n    }\\n\\n    function onTouchStart(e) {\\n      var device = swiper.device;\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\\n        return;\\n      }\\n\\n      if (image.isTouched) {\\n        return;\\n      }\\n\\n      if (device.android && e.cancelable) {\\n        e.preventDefault();\\n      }\\n\\n      image.isTouched = true;\\n      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;\\n      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;\\n    }\\n\\n    function onTouchMove(e) {\\n      var zoom = swiper.zoom;\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\\n        return;\\n      }\\n\\n      swiper.allowClick = false;\\n\\n      if (!image.isTouched || !gesture.$slideEl) {\\n        return;\\n      }\\n\\n      if (!image.isMoved) {\\n        image.width = gesture.$imageEl[0].offsetWidth;\\n        image.height = gesture.$imageEl[0].offsetHeight;\\n        image.startX = getTranslate(gesture.$imageWrapEl[0], 'x') || 0;\\n        image.startY = getTranslate(gesture.$imageWrapEl[0], 'y') || 0;\\n        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;\\n        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;\\n        gesture.$imageWrapEl.transition(0);\\n      } // Define if we need image drag\\n\\n\\n      var scaledWidth = image.width * zoom.scale;\\n      var scaledHeight = image.height * zoom.scale;\\n\\n      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {\\n        return;\\n      }\\n\\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\\n      image.maxX = -image.minX;\\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\\n      image.maxY = -image.minY;\\n      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;\\n      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;\\n\\n      if (!image.isMoved && !isScaling) {\\n        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\\n          image.isTouched = false;\\n          return;\\n        }\\n\\n        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\\n          image.isTouched = false;\\n          return;\\n        }\\n      }\\n\\n      if (e.cancelable) {\\n        e.preventDefault();\\n      }\\n\\n      e.stopPropagation();\\n      image.isMoved = true;\\n      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;\\n      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;\\n\\n      if (image.currentX < image.minX) {\\n        image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);\\n      }\\n\\n      if (image.currentX > image.maxX) {\\n        image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);\\n      }\\n\\n      if (image.currentY < image.minY) {\\n        image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);\\n      }\\n\\n      if (image.currentY > image.maxY) {\\n        image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);\\n      } // Velocity\\n\\n\\n      if (!velocity.prevPositionX) {\\n        velocity.prevPositionX = image.touchesCurrent.x;\\n      }\\n\\n      if (!velocity.prevPositionY) {\\n        velocity.prevPositionY = image.touchesCurrent.y;\\n      }\\n\\n      if (!velocity.prevTime) {\\n        velocity.prevTime = Date.now();\\n      }\\n\\n      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\\n      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\\n\\n      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {\\n        velocity.x = 0;\\n      }\\n\\n      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {\\n        velocity.y = 0;\\n      }\\n\\n      velocity.prevPositionX = image.touchesCurrent.x;\\n      velocity.prevPositionY = image.touchesCurrent.y;\\n      velocity.prevTime = Date.now();\\n      gesture.$imageWrapEl.transform(\\\"translate3d(\\\".concat(image.currentX, \\\"px, \\\").concat(image.currentY, \\\"px,0)\\\"));\\n    }\\n\\n    function onTouchEnd() {\\n      var zoom = swiper.zoom;\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {\\n        return;\\n      }\\n\\n      if (!image.isTouched || !image.isMoved) {\\n        image.isTouched = false;\\n        image.isMoved = false;\\n        return;\\n      }\\n\\n      image.isTouched = false;\\n      image.isMoved = false;\\n      var momentumDurationX = 300;\\n      var momentumDurationY = 300;\\n      var momentumDistanceX = velocity.x * momentumDurationX;\\n      var newPositionX = image.currentX + momentumDistanceX;\\n      var momentumDistanceY = velocity.y * momentumDurationY;\\n      var newPositionY = image.currentY + momentumDistanceY; // Fix duration\\n\\n      if (velocity.x !== 0) {\\n        momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\\n      }\\n\\n      if (velocity.y !== 0) {\\n        momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\\n      }\\n\\n      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);\\n      image.currentX = newPositionX;\\n      image.currentY = newPositionY; // Define if we need image drag\\n\\n      var scaledWidth = image.width * zoom.scale;\\n      var scaledHeight = image.height * zoom.scale;\\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\\n      image.maxX = -image.minX;\\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\\n      image.maxY = -image.minY;\\n      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\\n      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\\n      gesture.$imageWrapEl.transition(momentumDuration).transform(\\\"translate3d(\\\".concat(image.currentX, \\\"px, \\\").concat(image.currentY, \\\"px,0)\\\"));\\n    }\\n\\n    function onTransitionEnd() {\\n      var zoom = swiper.zoom;\\n\\n      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {\\n        if (gesture.$imageEl) {\\n          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');\\n        }\\n\\n        if (gesture.$imageWrapEl) {\\n          gesture.$imageWrapEl.transform('translate3d(0,0,0)');\\n        }\\n\\n        zoom.scale = 1;\\n        currentScale = 1;\\n        gesture.$slideEl = undefined;\\n        gesture.$imageEl = undefined;\\n        gesture.$imageWrapEl = undefined;\\n      }\\n    }\\n\\n    function zoomIn(e) {\\n      var zoom = swiper.zoom;\\n      var params = swiper.params.zoom;\\n\\n      if (!gesture.$slideEl) {\\n        if (e && e.target) {\\n          gesture.$slideEl = $(e.target).closest(\\\".\\\".concat(swiper.params.slideClass));\\n        }\\n\\n        if (!gesture.$slideEl) {\\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\\n            gesture.$slideEl = swiper.$wrapperEl.children(\\\".\\\".concat(swiper.params.slideActiveClass));\\n          } else {\\n            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\\n          }\\n        }\\n\\n        gesture.$imageEl = gesture.$slideEl.find(\\\".\\\".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);\\n        gesture.$imageWrapEl = gesture.$imageEl.parent(\\\".\\\".concat(params.containerClass));\\n      }\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) {\\n        return;\\n      }\\n\\n      if (swiper.params.cssMode) {\\n        swiper.wrapperEl.style.overflow = 'hidden';\\n        swiper.wrapperEl.style.touchAction = 'none';\\n      }\\n\\n      gesture.$slideEl.addClass(\\\"\\\".concat(params.zoomedSlideClass));\\n      var touchX;\\n      var touchY;\\n      var offsetX;\\n      var offsetY;\\n      var diffX;\\n      var diffY;\\n      var translateX;\\n      var translateY;\\n      var imageWidth;\\n      var imageHeight;\\n      var scaledWidth;\\n      var scaledHeight;\\n      var translateMinX;\\n      var translateMinY;\\n      var translateMaxX;\\n      var translateMaxY;\\n      var slideWidth;\\n      var slideHeight;\\n\\n      if (typeof image.touchesStart.x === 'undefined' && e) {\\n        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;\\n        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;\\n      } else {\\n        touchX = image.touchesStart.x;\\n        touchY = image.touchesStart.y;\\n      }\\n\\n      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n      currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;\\n\\n      if (e) {\\n        slideWidth = gesture.$slideEl[0].offsetWidth;\\n        slideHeight = gesture.$slideEl[0].offsetHeight;\\n        offsetX = gesture.$slideEl.offset().left + window.scrollX;\\n        offsetY = gesture.$slideEl.offset().top + window.scrollY;\\n        diffX = offsetX + slideWidth / 2 - touchX;\\n        diffY = offsetY + slideHeight / 2 - touchY;\\n        imageWidth = gesture.$imageEl[0].offsetWidth;\\n        imageHeight = gesture.$imageEl[0].offsetHeight;\\n        scaledWidth = imageWidth * zoom.scale;\\n        scaledHeight = imageHeight * zoom.scale;\\n        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\\n        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\\n        translateMaxX = -translateMinX;\\n        translateMaxY = -translateMinY;\\n        translateX = diffX * zoom.scale;\\n        translateY = diffY * zoom.scale;\\n\\n        if (translateX < translateMinX) {\\n          translateX = translateMinX;\\n        }\\n\\n        if (translateX > translateMaxX) {\\n          translateX = translateMaxX;\\n        }\\n\\n        if (translateY < translateMinY) {\\n          translateY = translateMinY;\\n        }\\n\\n        if (translateY > translateMaxY) {\\n          translateY = translateMaxY;\\n        }\\n      } else {\\n        translateX = 0;\\n        translateY = 0;\\n      }\\n\\n      gesture.$imageWrapEl.transition(300).transform(\\\"translate3d(\\\".concat(translateX, \\\"px, \\\").concat(translateY, \\\"px,0)\\\"));\\n      gesture.$imageEl.transition(300).transform(\\\"translate3d(0,0,0) scale(\\\".concat(zoom.scale, \\\")\\\"));\\n    }\\n\\n    function zoomOut() {\\n      var zoom = swiper.zoom;\\n      var params = swiper.params.zoom;\\n\\n      if (!gesture.$slideEl) {\\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\\n          gesture.$slideEl = swiper.$wrapperEl.children(\\\".\\\".concat(swiper.params.slideActiveClass));\\n        } else {\\n          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);\\n        }\\n\\n        gesture.$imageEl = gesture.$slideEl.find(\\\".\\\".concat(params.containerClass)).eq(0).find('picture, img, svg, canvas, .swiper-zoom-target').eq(0);\\n        gesture.$imageWrapEl = gesture.$imageEl.parent(\\\".\\\".concat(params.containerClass));\\n      }\\n\\n      if (!gesture.$imageEl || gesture.$imageEl.length === 0 || !gesture.$imageWrapEl || gesture.$imageWrapEl.length === 0) {\\n        return;\\n      }\\n\\n      if (swiper.params.cssMode) {\\n        swiper.wrapperEl.style.overflow = '';\\n        swiper.wrapperEl.style.touchAction = '';\\n      }\\n\\n      zoom.scale = 1;\\n      currentScale = 1;\\n      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');\\n      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');\\n      gesture.$slideEl.removeClass(\\\"\\\".concat(params.zoomedSlideClass));\\n      gesture.$slideEl = undefined;\\n    } // Toggle Zoom\\n\\n\\n    function zoomToggle(e) {\\n      var zoom = swiper.zoom;\\n\\n      if (zoom.scale && zoom.scale !== 1) {\\n        // Zoom Out\\n        zoomOut();\\n      } else {\\n        // Zoom In\\n        zoomIn(e);\\n      }\\n    }\\n\\n    function getListeners() {\\n      var support = swiper.support;\\n      var passiveListener = swiper.touchEvents.start === 'touchstart' && support.passiveListener && swiper.params.passiveListeners ? {\\n        passive: true,\\n        capture: false\\n      } : false;\\n      var activeListenerWithCapture = support.passiveListener ? {\\n        passive: false,\\n        capture: true\\n      } : true;\\n      return {\\n        passiveListener: passiveListener,\\n        activeListenerWithCapture: activeListenerWithCapture\\n      };\\n    }\\n\\n    function getSlideSelector() {\\n      return \\\".\\\".concat(swiper.params.slideClass);\\n    }\\n\\n    function toggleGestures(method) {\\n      var _getListeners = getListeners(),\\n          passiveListener = _getListeners.passiveListener;\\n\\n      var slideSelector = getSlideSelector();\\n      swiper.$wrapperEl[method]('gesturestart', slideSelector, onGestureStart, passiveListener);\\n      swiper.$wrapperEl[method]('gesturechange', slideSelector, onGestureChange, passiveListener);\\n      swiper.$wrapperEl[method]('gestureend', slideSelector, onGestureEnd, passiveListener);\\n    }\\n\\n    function enableGestures() {\\n      if (gesturesEnabled) {\\n        return;\\n      }\\n\\n      gesturesEnabled = true;\\n      toggleGestures('on');\\n    }\\n\\n    function disableGestures() {\\n      if (!gesturesEnabled) {\\n        return;\\n      }\\n\\n      gesturesEnabled = false;\\n      toggleGestures('off');\\n    } // Attach/Detach Events\\n\\n\\n    function enable() {\\n      var zoom = swiper.zoom;\\n\\n      if (zoom.enabled) {\\n        return;\\n      }\\n\\n      zoom.enabled = true;\\n      var support = swiper.support;\\n\\n      var _getListeners2 = getListeners(),\\n          passiveListener = _getListeners2.passiveListener,\\n          activeListenerWithCapture = _getListeners2.activeListenerWithCapture;\\n\\n      var slideSelector = getSlideSelector(); // Scale image\\n\\n      if (support.gestures) {\\n        swiper.$wrapperEl.on(swiper.touchEvents.start, enableGestures, passiveListener);\\n        swiper.$wrapperEl.on(swiper.touchEvents.end, disableGestures, passiveListener);\\n      } else if (swiper.touchEvents.start === 'touchstart') {\\n        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\\n        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\\n        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\\n\\n        if (swiper.touchEvents.cancel) {\\n          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\\n        }\\n      } // Move image\\n\\n\\n      swiper.$wrapperEl.on(swiper.touchEvents.move, \\\".\\\".concat(swiper.params.zoom.containerClass), onTouchMove, activeListenerWithCapture);\\n    }\\n\\n    function disable() {\\n      var zoom = swiper.zoom;\\n\\n      if (!zoom.enabled) {\\n        return;\\n      }\\n\\n      var support = swiper.support;\\n      zoom.enabled = false;\\n\\n      var _getListeners3 = getListeners(),\\n          passiveListener = _getListeners3.passiveListener,\\n          activeListenerWithCapture = _getListeners3.activeListenerWithCapture;\\n\\n      var slideSelector = getSlideSelector(); // Scale image\\n\\n      if (support.gestures) {\\n        swiper.$wrapperEl.off(swiper.touchEvents.start, enableGestures, passiveListener);\\n        swiper.$wrapperEl.off(swiper.touchEvents.end, disableGestures, passiveListener);\\n      } else if (swiper.touchEvents.start === 'touchstart') {\\n        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, onGestureStart, passiveListener);\\n        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, onGestureChange, activeListenerWithCapture);\\n        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, onGestureEnd, passiveListener);\\n\\n        if (swiper.touchEvents.cancel) {\\n          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, onGestureEnd, passiveListener);\\n        }\\n      } // Move image\\n\\n\\n      swiper.$wrapperEl.off(swiper.touchEvents.move, \\\".\\\".concat(swiper.params.zoom.containerClass), onTouchMove, activeListenerWithCapture);\\n    }\\n\\n    on('init', function () {\\n      if (swiper.params.zoom.enabled) {\\n        enable();\\n      }\\n    });\\n    on('destroy', function () {\\n      disable();\\n    });\\n    on('touchStart', function (_s, e) {\\n      if (!swiper.zoom.enabled) {\\n        return;\\n      }\\n\\n      onTouchStart(e);\\n    });\\n    on('touchEnd', function (_s, e) {\\n      if (!swiper.zoom.enabled) {\\n        return;\\n      }\\n\\n      onTouchEnd();\\n    });\\n    on('doubleTap', function (_s, e) {\\n      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\\n        zoomToggle(e);\\n      }\\n    });\\n    on('transitionEnd', function () {\\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\\n        onTransitionEnd();\\n      }\\n    });\\n    on('slideChange', function () {\\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\\n        onTransitionEnd();\\n      }\\n    });\\n    Object.assign(swiper.zoom, {\\n      enable: enable,\\n      disable: disable,\\n      in: zoomIn,\\n      out: zoomOut,\\n      toggle: zoomToggle\\n    });\\n  }\\n\\n  function Lazy(_ref15) {\\n    var swiper = _ref15.swiper,\\n        extendParams = _ref15.extendParams,\\n        on = _ref15.on,\\n        emit = _ref15.emit;\\n    extendParams({\\n      lazy: {\\n        checkInView: false,\\n        enabled: false,\\n        loadPrevNext: false,\\n        loadPrevNextAmount: 1,\\n        loadOnTransitionStart: false,\\n        scrollingElement: '',\\n        elementClass: 'swiper-lazy',\\n        loadingClass: 'swiper-lazy-loading',\\n        loadedClass: 'swiper-lazy-loaded',\\n        preloaderClass: 'swiper-lazy-preloader'\\n      }\\n    });\\n    swiper.lazy = {};\\n    var scrollHandlerAttached = false;\\n    var initialImageLoaded = false;\\n\\n    function loadInSlide(index) {\\n      var loadInDuplicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n      var params = swiper.params.lazy;\\n\\n      if (typeof index === 'undefined') {\\n        return;\\n      }\\n\\n      if (swiper.slides.length === 0) {\\n        return;\\n      }\\n\\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n      var $slideEl = isVirtual ? swiper.$wrapperEl.children(\\\".\\\".concat(swiper.params.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(index, \\\"\\\\\\\"]\\\")) : swiper.slides.eq(index);\\n      var $images = $slideEl.find(\\\".\\\".concat(params.elementClass, \\\":not(.\\\").concat(params.loadedClass, \\\"):not(.\\\").concat(params.loadingClass, \\\")\\\"));\\n\\n      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {\\n        $images.push($slideEl[0]);\\n      }\\n\\n      if ($images.length === 0) {\\n        return;\\n      }\\n\\n      $images.each(function (imageEl) {\\n        var $imageEl = $(imageEl);\\n        $imageEl.addClass(params.loadingClass);\\n        var background = $imageEl.attr('data-background');\\n        var src = $imageEl.attr('data-src');\\n        var srcset = $imageEl.attr('data-srcset');\\n        var sizes = $imageEl.attr('data-sizes');\\n        var $pictureEl = $imageEl.parent('picture');\\n        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {\\n          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) {\\n            return;\\n          }\\n\\n          if (background) {\\n            $imageEl.css('background-image', \\\"url(\\\\\\\"\\\".concat(background, \\\"\\\\\\\")\\\"));\\n            $imageEl.removeAttr('data-background');\\n          } else {\\n            if (srcset) {\\n              $imageEl.attr('srcset', srcset);\\n              $imageEl.removeAttr('data-srcset');\\n            }\\n\\n            if (sizes) {\\n              $imageEl.attr('sizes', sizes);\\n              $imageEl.removeAttr('data-sizes');\\n            }\\n\\n            if ($pictureEl.length) {\\n              $pictureEl.children('source').each(function (sourceEl) {\\n                var $source = $(sourceEl);\\n\\n                if ($source.attr('data-srcset')) {\\n                  $source.attr('srcset', $source.attr('data-srcset'));\\n                  $source.removeAttr('data-srcset');\\n                }\\n              });\\n            }\\n\\n            if (src) {\\n              $imageEl.attr('src', src);\\n              $imageEl.removeAttr('data-src');\\n            }\\n          }\\n\\n          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);\\n          $slideEl.find(\\\".\\\".concat(params.preloaderClass)).remove();\\n\\n          if (swiper.params.loop && loadInDuplicate) {\\n            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');\\n\\n            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {\\n              var originalSlide = swiper.$wrapperEl.children(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(slideOriginalIndex, \\\"\\\\\\\"]:not(.\\\").concat(swiper.params.slideDuplicateClass, \\\")\\\"));\\n              loadInSlide(originalSlide.index(), false);\\n            } else {\\n              var duplicatedSlide = swiper.$wrapperEl.children(\\\".\\\".concat(swiper.params.slideDuplicateClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(slideOriginalIndex, \\\"\\\\\\\"]\\\"));\\n              loadInSlide(duplicatedSlide.index(), false);\\n            }\\n          }\\n\\n          emit('lazyImageReady', $slideEl[0], $imageEl[0]);\\n\\n          if (swiper.params.autoHeight) {\\n            swiper.updateAutoHeight();\\n          }\\n        });\\n        emit('lazyImageLoad', $slideEl[0], $imageEl[0]);\\n      });\\n    }\\n\\n    function load() {\\n      var $wrapperEl = swiper.$wrapperEl,\\n          swiperParams = swiper.params,\\n          slides = swiper.slides,\\n          activeIndex = swiper.activeIndex;\\n      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;\\n      var params = swiperParams.lazy;\\n      var slidesPerView = swiperParams.slidesPerView;\\n\\n      if (slidesPerView === 'auto') {\\n        slidesPerView = 0;\\n      }\\n\\n      function slideExist(index) {\\n        if (isVirtual) {\\n          if ($wrapperEl.children(\\\".\\\".concat(swiperParams.slideClass, \\\"[data-swiper-slide-index=\\\\\\\"\\\").concat(index, \\\"\\\\\\\"]\\\")).length) {\\n            return true;\\n          }\\n        } else if (slides[index]) {\\n          return true;\\n        }\\n\\n        return false;\\n      }\\n\\n      function slideIndex(slideEl) {\\n        if (isVirtual) {\\n          return $(slideEl).attr('data-swiper-slide-index');\\n        }\\n\\n        return $(slideEl).index();\\n      }\\n\\n      if (!initialImageLoaded) {\\n        initialImageLoaded = true;\\n      }\\n\\n      if (swiper.params.watchSlidesProgress) {\\n        $wrapperEl.children(\\\".\\\".concat(swiperParams.slideVisibleClass)).each(function (slideEl) {\\n          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();\\n          loadInSlide(index);\\n        });\\n      } else if (slidesPerView > 1) {\\n        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {\\n          if (slideExist(i)) {\\n            loadInSlide(i);\\n          }\\n        }\\n      } else {\\n        loadInSlide(activeIndex);\\n      }\\n\\n      if (params.loadPrevNext) {\\n        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {\\n          var amount = params.loadPrevNextAmount;\\n          var spv = slidesPerView;\\n          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);\\n          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides\\n\\n          for (var _i9 = activeIndex + slidesPerView; _i9 < maxIndex; _i9 += 1) {\\n            if (slideExist(_i9)) {\\n              loadInSlide(_i9);\\n            }\\n          } // Prev Slides\\n\\n\\n          for (var _i10 = minIndex; _i10 < activeIndex; _i10 += 1) {\\n            if (slideExist(_i10)) {\\n              loadInSlide(_i10);\\n            }\\n          }\\n        } else {\\n          var nextSlide = $wrapperEl.children(\\\".\\\".concat(swiperParams.slideNextClass));\\n\\n          if (nextSlide.length > 0) {\\n            loadInSlide(slideIndex(nextSlide));\\n          }\\n\\n          var prevSlide = $wrapperEl.children(\\\".\\\".concat(swiperParams.slidePrevClass));\\n\\n          if (prevSlide.length > 0) {\\n            loadInSlide(slideIndex(prevSlide));\\n          }\\n        }\\n      }\\n    }\\n\\n    function checkInViewOnLoad() {\\n      var window = getWindow();\\n\\n      if (!swiper || swiper.destroyed) {\\n        return;\\n      }\\n\\n      var $scrollElement = swiper.params.lazy.scrollingElement ? $(swiper.params.lazy.scrollingElement) : $(window);\\n      var isWindow = $scrollElement[0] === window;\\n      var scrollElementWidth = isWindow ? window.innerWidth : $scrollElement[0].offsetWidth;\\n      var scrollElementHeight = isWindow ? window.innerHeight : $scrollElement[0].offsetHeight;\\n      var swiperOffset = swiper.$el.offset();\\n      var rtl = swiper.rtlTranslate;\\n      var inView = false;\\n\\n      if (rtl) {\\n        swiperOffset.left -= swiper.$el[0].scrollLeft;\\n      }\\n\\n      var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];\\n\\n      for (var i = 0; i < swiperCoord.length; i += 1) {\\n        var point = swiperCoord[i];\\n\\n        if (point[0] >= 0 && point[0] <= scrollElementWidth && point[1] >= 0 && point[1] <= scrollElementHeight) {\\n          if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\\n\\n          inView = true;\\n        }\\n      }\\n\\n      var passiveListener = swiper.touchEvents.start === 'touchstart' && swiper.support.passiveListener && swiper.params.passiveListeners ? {\\n        passive: true,\\n        capture: false\\n      } : false;\\n\\n      if (inView) {\\n        load();\\n        $scrollElement.off('scroll', checkInViewOnLoad, passiveListener);\\n      } else if (!scrollHandlerAttached) {\\n        scrollHandlerAttached = true;\\n        $scrollElement.on('scroll', checkInViewOnLoad, passiveListener);\\n      }\\n    }\\n\\n    on('beforeInit', function () {\\n      if (swiper.params.lazy.enabled && swiper.params.preloadImages) {\\n        swiper.params.preloadImages = false;\\n      }\\n    });\\n    on('init', function () {\\n      if (swiper.params.lazy.enabled) {\\n        if (swiper.params.lazy.checkInView) {\\n          checkInViewOnLoad();\\n        } else {\\n          load();\\n        }\\n      }\\n    });\\n    on('scroll', function () {\\n      if (swiper.params.freeMode && swiper.params.freeMode.enabled && !swiper.params.freeMode.sticky) {\\n        load();\\n      }\\n    });\\n    on('scrollbarDragMove resize _freeModeNoMomentumRelease', function () {\\n      if (swiper.params.lazy.enabled) {\\n        if (swiper.params.lazy.checkInView) {\\n          checkInViewOnLoad();\\n        } else {\\n          load();\\n        }\\n      }\\n    });\\n    on('transitionStart', function () {\\n      if (swiper.params.lazy.enabled) {\\n        if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !initialImageLoaded) {\\n          if (swiper.params.lazy.checkInView) {\\n            checkInViewOnLoad();\\n          } else {\\n            load();\\n          }\\n        }\\n      }\\n    });\\n    on('transitionEnd', function () {\\n      if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {\\n        if (swiper.params.lazy.checkInView) {\\n          checkInViewOnLoad();\\n        } else {\\n          load();\\n        }\\n      }\\n    });\\n    on('slideChange', function () {\\n      var _swiper$params2 = swiper.params,\\n          lazy = _swiper$params2.lazy,\\n          cssMode = _swiper$params2.cssMode,\\n          watchSlidesProgress = _swiper$params2.watchSlidesProgress,\\n          touchReleaseOnEdges = _swiper$params2.touchReleaseOnEdges,\\n          resistanceRatio = _swiper$params2.resistanceRatio;\\n\\n      if (lazy.enabled && (cssMode || watchSlidesProgress && (touchReleaseOnEdges || resistanceRatio === 0))) {\\n        load();\\n      }\\n    });\\n    Object.assign(swiper.lazy, {\\n      load: load,\\n      loadInSlide: loadInSlide\\n    });\\n  }\\n  /* eslint no-bitwise: [\\\"error\\\", { \\\"allow\\\": [\\\">>\\\"] }] */\\n\\n\\n  function Controller(_ref16) {\\n    var swiper = _ref16.swiper,\\n        extendParams = _ref16.extendParams,\\n        on = _ref16.on;\\n    extendParams({\\n      controller: {\\n        control: undefined,\\n        inverse: false,\\n        by: 'slide' // or 'container'\\n\\n      }\\n    });\\n    swiper.controller = {\\n      control: undefined\\n    };\\n\\n    function LinearSpline(x, y) {\\n      var binarySearch = function search() {\\n        var maxIndex;\\n        var minIndex;\\n        var guess;\\n        return function (array, val) {\\n          minIndex = -1;\\n          maxIndex = array.length;\\n\\n          while (maxIndex - minIndex > 1) {\\n            guess = maxIndex + minIndex >> 1;\\n\\n            if (array[guess] <= val) {\\n              minIndex = guess;\\n            } else {\\n              maxIndex = guess;\\n            }\\n          }\\n\\n          return maxIndex;\\n        };\\n      }();\\n\\n      this.x = x;\\n      this.y = y;\\n      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:\\n      // (x1,y1) is the known point before given value,\\n      // (x3,y3) is the known point after given value.\\n\\n      var i1;\\n      var i3;\\n\\n      this.interpolate = function interpolate(x2) {\\n        if (!x2) {\\n          return 0;\\n        } // Get the indexes of x1 and x3 (the array indexes before and after given x2):\\n\\n\\n        i3 = binarySearch(this.x, x2);\\n        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:\\n        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\\n\\n        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\\n      };\\n\\n      return this;\\n    } // xxx: for now i will just save one spline function to to\\n\\n\\n    function getInterpolateFunction(c) {\\n      if (!swiper.controller.spline) {\\n        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\\n      }\\n    }\\n\\n    function setTranslate(_t, byController) {\\n      var controlled = swiper.controller.control;\\n      var multiplier;\\n      var controlledTranslate;\\n      var Swiper = swiper.constructor;\\n\\n      function setControlledTranslate(c) {\\n        // this will create an Interpolate function based on the snapGrids\\n        // x is the Grid of the scrolled scroller and y will be the controlled scroller\\n        // it makes sense to create this only once and recall it for the interpolation\\n        // the function does a lot of value caching for performance\\n        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\\n\\n        if (swiper.params.controller.by === 'slide') {\\n          getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\\n          // but it did not work out\\n\\n          controlledTranslate = -swiper.controller.spline.interpolate(-translate);\\n        }\\n\\n        if (!controlledTranslate || swiper.params.controller.by === 'container') {\\n          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\\n          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\\n        }\\n\\n        if (swiper.params.controller.inverse) {\\n          controlledTranslate = c.maxTranslate() - controlledTranslate;\\n        }\\n\\n        c.updateProgress(controlledTranslate);\\n        c.setTranslate(controlledTranslate, swiper);\\n        c.updateActiveIndex();\\n        c.updateSlidesClasses();\\n      }\\n\\n      if (Array.isArray(controlled)) {\\n        for (var i = 0; i < controlled.length; i += 1) {\\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\\n            setControlledTranslate(controlled[i]);\\n          }\\n        }\\n      } else if (controlled instanceof Swiper && byController !== controlled) {\\n        setControlledTranslate(controlled);\\n      }\\n    }\\n\\n    function setTransition(duration, byController) {\\n      var Swiper = swiper.constructor;\\n      var controlled = swiper.controller.control;\\n      var i;\\n\\n      function setControlledTransition(c) {\\n        c.setTransition(duration, swiper);\\n\\n        if (duration !== 0) {\\n          c.transitionStart();\\n\\n          if (c.params.autoHeight) {\\n            nextTick(function () {\\n              c.updateAutoHeight();\\n            });\\n          }\\n\\n          c.$wrapperEl.transitionEnd(function () {\\n            if (!controlled) {\\n              return;\\n            }\\n\\n            if (c.params.loop && swiper.params.controller.by === 'slide') {\\n              c.loopFix();\\n            }\\n\\n            c.transitionEnd();\\n          });\\n        }\\n      }\\n\\n      if (Array.isArray(controlled)) {\\n        for (i = 0; i < controlled.length; i += 1) {\\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\\n            setControlledTransition(controlled[i]);\\n          }\\n        }\\n      } else if (controlled instanceof Swiper && byController !== controlled) {\\n        setControlledTransition(controlled);\\n      }\\n    }\\n\\n    function removeSpline() {\\n      if (!swiper.controller.control) {\\n        return;\\n      }\\n\\n      if (swiper.controller.spline) {\\n        swiper.controller.spline = undefined;\\n        delete swiper.controller.spline;\\n      }\\n    }\\n\\n    on('beforeInit', function () {\\n      swiper.controller.control = swiper.params.controller.control;\\n    });\\n    on('update', function () {\\n      removeSpline();\\n    });\\n    on('resize', function () {\\n      removeSpline();\\n    });\\n    on('observerUpdate', function () {\\n      removeSpline();\\n    });\\n    on('setTranslate', function (_s, translate, byController) {\\n      if (!swiper.controller.control) {\\n        return;\\n      }\\n\\n      swiper.controller.setTranslate(translate, byController);\\n    });\\n    on('setTransition', function (_s, duration, byController) {\\n      if (!swiper.controller.control) {\\n        return;\\n      }\\n\\n      swiper.controller.setTransition(duration, byController);\\n    });\\n    Object.assign(swiper.controller, {\\n      setTranslate: setTranslate,\\n      setTransition: setTransition\\n    });\\n  }\\n\\n  function A11y(_ref17) {\\n    var swiper = _ref17.swiper,\\n        extendParams = _ref17.extendParams,\\n        on = _ref17.on;\\n    extendParams({\\n      a11y: {\\n        enabled: true,\\n        notificationClass: 'swiper-notification',\\n        prevSlideMessage: 'Previous slide',\\n        nextSlideMessage: 'Next slide',\\n        firstSlideMessage: 'This is the first slide',\\n        lastSlideMessage: 'This is the last slide',\\n        paginationBulletMessage: 'Go to slide {{index}}',\\n        slideLabelMessage: '{{index}} / {{slidesLength}}',\\n        containerMessage: null,\\n        containerRoleDescriptionMessage: null,\\n        itemRoleDescriptionMessage: null,\\n        slideRole: 'group'\\n      }\\n    });\\n    var liveRegion = null;\\n\\n    function notify(message) {\\n      var notification = liveRegion;\\n\\n      if (notification.length === 0) {\\n        return;\\n      }\\n\\n      notification.html('');\\n      notification.html(message);\\n    }\\n\\n    function getRandomNumber() {\\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\\n\\n      var randomChar = function randomChar() {\\n        return Math.round(16 * Math.random()).toString(16);\\n      };\\n\\n      return 'x'.repeat(size).replace(/x/g, randomChar);\\n    }\\n\\n    function makeElFocusable($el) {\\n      $el.attr('tabIndex', '0');\\n    }\\n\\n    function makeElNotFocusable($el) {\\n      $el.attr('tabIndex', '-1');\\n    }\\n\\n    function addElRole($el, role) {\\n      $el.attr('role', role);\\n    }\\n\\n    function addElRoleDescription($el, description) {\\n      $el.attr('aria-roledescription', description);\\n    }\\n\\n    function addElControls($el, controls) {\\n      $el.attr('aria-controls', controls);\\n    }\\n\\n    function addElLabel($el, label) {\\n      $el.attr('aria-label', label);\\n    }\\n\\n    function addElId($el, id) {\\n      $el.attr('id', id);\\n    }\\n\\n    function addElLive($el, live) {\\n      $el.attr('aria-live', live);\\n    }\\n\\n    function disableEl($el) {\\n      $el.attr('aria-disabled', true);\\n    }\\n\\n    function enableEl($el) {\\n      $el.attr('aria-disabled', false);\\n    }\\n\\n    function onEnterOrSpaceKey(e) {\\n      if (e.keyCode !== 13 && e.keyCode !== 32) {\\n        return;\\n      }\\n\\n      var params = swiper.params.a11y;\\n      var $targetEl = $(e.target);\\n\\n      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {\\n        if (!(swiper.isEnd && !swiper.params.loop)) {\\n          swiper.slideNext();\\n        }\\n\\n        if (swiper.isEnd) {\\n          notify(params.lastSlideMessage);\\n        } else {\\n          notify(params.nextSlideMessage);\\n        }\\n      }\\n\\n      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {\\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\\n          swiper.slidePrev();\\n        }\\n\\n        if (swiper.isBeginning) {\\n          notify(params.firstSlideMessage);\\n        } else {\\n          notify(params.prevSlideMessage);\\n        }\\n      }\\n\\n      if (swiper.pagination && $targetEl.is(classesToSelector(swiper.params.pagination.bulletClass))) {\\n        $targetEl[0].click();\\n      }\\n    }\\n\\n    function updateNavigation() {\\n      if (swiper.params.loop || !swiper.navigation) {\\n        return;\\n      }\\n\\n      var _swiper$navigation5 = swiper.navigation,\\n          $nextEl = _swiper$navigation5.$nextEl,\\n          $prevEl = _swiper$navigation5.$prevEl;\\n\\n      if ($prevEl && $prevEl.length > 0) {\\n        if (swiper.isBeginning) {\\n          disableEl($prevEl);\\n          makeElNotFocusable($prevEl);\\n        } else {\\n          enableEl($prevEl);\\n          makeElFocusable($prevEl);\\n        }\\n      }\\n\\n      if ($nextEl && $nextEl.length > 0) {\\n        if (swiper.isEnd) {\\n          disableEl($nextEl);\\n          makeElNotFocusable($nextEl);\\n        } else {\\n          enableEl($nextEl);\\n          makeElFocusable($nextEl);\\n        }\\n      }\\n    }\\n\\n    function hasPagination() {\\n      return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\\n    }\\n\\n    function hasClickablePagination() {\\n      return hasPagination() && swiper.params.pagination.clickable;\\n    }\\n\\n    function updatePagination() {\\n      var params = swiper.params.a11y;\\n\\n      if (!hasPagination()) {\\n        return;\\n      }\\n\\n      swiper.pagination.bullets.each(function (bulletEl) {\\n        var $bulletEl = $(bulletEl);\\n\\n        if (swiper.params.pagination.clickable) {\\n          makeElFocusable($bulletEl);\\n\\n          if (!swiper.params.pagination.renderBullet) {\\n            addElRole($bulletEl, 'button');\\n            addElLabel($bulletEl, params.paginationBulletMessage.replace(/\\\\{\\\\{index\\\\}\\\\}/, $bulletEl.index() + 1));\\n          }\\n        }\\n\\n        if ($bulletEl.is(\\\".\\\".concat(swiper.params.pagination.bulletActiveClass))) {\\n          $bulletEl.attr('aria-current', 'true');\\n        } else {\\n          $bulletEl.removeAttr('aria-current');\\n        }\\n      });\\n    }\\n\\n    var initNavEl = function initNavEl($el, wrapperId, message) {\\n      makeElFocusable($el);\\n\\n      if ($el[0].tagName !== 'BUTTON') {\\n        addElRole($el, 'button');\\n        $el.on('keydown', onEnterOrSpaceKey);\\n      }\\n\\n      addElLabel($el, message);\\n      addElControls($el, wrapperId);\\n    };\\n\\n    function init() {\\n      var params = swiper.params.a11y;\\n      swiper.$el.append(liveRegion); // Container\\n\\n      var $containerEl = swiper.$el;\\n\\n      if (params.containerRoleDescriptionMessage) {\\n        addElRoleDescription($containerEl, params.containerRoleDescriptionMessage);\\n      }\\n\\n      if (params.containerMessage) {\\n        addElLabel($containerEl, params.containerMessage);\\n      } // Wrapper\\n\\n\\n      var $wrapperEl = swiper.$wrapperEl;\\n      var wrapperId = $wrapperEl.attr('id') || \\\"swiper-wrapper-\\\".concat(getRandomNumber(16));\\n      var live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\\n      addElId($wrapperEl, wrapperId);\\n      addElLive($wrapperEl, live); // Slide\\n\\n      if (params.itemRoleDescriptionMessage) {\\n        addElRoleDescription($(swiper.slides), params.itemRoleDescriptionMessage);\\n      }\\n\\n      addElRole($(swiper.slides), params.slideRole);\\n      var slidesLength = swiper.params.loop ? swiper.slides.filter(function (el) {\\n        return !el.classList.contains(swiper.params.slideDuplicateClass);\\n      }).length : swiper.slides.length;\\n      swiper.slides.each(function (slideEl, index) {\\n        var $slideEl = $(slideEl);\\n        var slideIndex = swiper.params.loop ? parseInt($slideEl.attr('data-swiper-slide-index'), 10) : index;\\n        var ariaLabelMessage = params.slideLabelMessage.replace(/\\\\{\\\\{index\\\\}\\\\}/, slideIndex + 1).replace(/\\\\{\\\\{slidesLength\\\\}\\\\}/, slidesLength);\\n        addElLabel($slideEl, ariaLabelMessage);\\n      }); // Navigation\\n\\n      var $nextEl;\\n      var $prevEl;\\n\\n      if (swiper.navigation && swiper.navigation.$nextEl) {\\n        $nextEl = swiper.navigation.$nextEl;\\n      }\\n\\n      if (swiper.navigation && swiper.navigation.$prevEl) {\\n        $prevEl = swiper.navigation.$prevEl;\\n      }\\n\\n      if ($nextEl && $nextEl.length) {\\n        initNavEl($nextEl, wrapperId, params.nextSlideMessage);\\n      }\\n\\n      if ($prevEl && $prevEl.length) {\\n        initNavEl($prevEl, wrapperId, params.prevSlideMessage);\\n      } // Pagination\\n\\n\\n      if (hasClickablePagination()) {\\n        swiper.pagination.$el.on('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);\\n      }\\n    }\\n\\n    function destroy() {\\n      if (liveRegion && liveRegion.length > 0) {\\n        liveRegion.remove();\\n      }\\n\\n      var $nextEl;\\n      var $prevEl;\\n\\n      if (swiper.navigation && swiper.navigation.$nextEl) {\\n        $nextEl = swiper.navigation.$nextEl;\\n      }\\n\\n      if (swiper.navigation && swiper.navigation.$prevEl) {\\n        $prevEl = swiper.navigation.$prevEl;\\n      }\\n\\n      if ($nextEl) {\\n        $nextEl.off('keydown', onEnterOrSpaceKey);\\n      }\\n\\n      if ($prevEl) {\\n        $prevEl.off('keydown', onEnterOrSpaceKey);\\n      } // Pagination\\n\\n\\n      if (hasClickablePagination()) {\\n        swiper.pagination.$el.off('keydown', classesToSelector(swiper.params.pagination.bulletClass), onEnterOrSpaceKey);\\n      }\\n    }\\n\\n    on('beforeInit', function () {\\n      liveRegion = $(\\\"<span class=\\\\\\\"\\\".concat(swiper.params.a11y.notificationClass, \\\"\\\\\\\" aria-live=\\\\\\\"assertive\\\\\\\" aria-atomic=\\\\\\\"true\\\\\\\"></span>\\\"));\\n    });\\n    on('afterInit', function () {\\n      if (!swiper.params.a11y.enabled) {\\n        return;\\n      }\\n\\n      init();\\n      updateNavigation();\\n    });\\n    on('toEdge', function () {\\n      if (!swiper.params.a11y.enabled) {\\n        return;\\n      }\\n\\n      updateNavigation();\\n    });\\n    on('fromEdge', function () {\\n      if (!swiper.params.a11y.enabled) {\\n        return;\\n      }\\n\\n      updateNavigation();\\n    });\\n    on('paginationUpdate', function () {\\n      if (!swiper.params.a11y.enabled) {\\n        return;\\n      }\\n\\n      updatePagination();\\n    });\\n    on('destroy', function () {\\n      if (!swiper.params.a11y.enabled) {\\n        return;\\n      }\\n\\n      destroy();\\n    });\\n  }\\n\\n  function History(_ref18) {\\n    var swiper = _ref18.swiper,\\n        extendParams = _ref18.extendParams,\\n        on = _ref18.on;\\n    extendParams({\\n      history: {\\n        enabled: false,\\n        root: '',\\n        replaceState: false,\\n        key: 'slides'\\n      }\\n    });\\n    var initialized = false;\\n    var paths = {};\\n\\n    var slugify = function slugify(text) {\\n      return text.toString().replace(/\\\\s+/g, '-').replace(/[^\\\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\\n    };\\n\\n    var getPathValues = function getPathValues(urlOverride) {\\n      var window = getWindow();\\n      var location;\\n\\n      if (urlOverride) {\\n        location = new URL(urlOverride);\\n      } else {\\n        location = window.location;\\n      }\\n\\n      var pathArray = location.pathname.slice(1).split('/').filter(function (part) {\\n        return part !== '';\\n      });\\n      var total = pathArray.length;\\n      var key = pathArray[total - 2];\\n      var value = pathArray[total - 1];\\n      return {\\n        key: key,\\n        value: value\\n      };\\n    };\\n\\n    var setHistory = function setHistory(key, index) {\\n      var window = getWindow();\\n\\n      if (!initialized || !swiper.params.history.enabled) {\\n        return;\\n      }\\n\\n      var location;\\n\\n      if (swiper.params.url) {\\n        location = new URL(swiper.params.url);\\n      } else {\\n        location = window.location;\\n      }\\n\\n      var slide = swiper.slides.eq(index);\\n      var value = slugify(slide.attr('data-history'));\\n\\n      if (swiper.params.history.root.length > 0) {\\n        var root = swiper.params.history.root;\\n\\n        if (root[root.length - 1] === '/') {\\n          root = root.slice(0, root.length - 1);\\n        }\\n\\n        value = \\\"\\\".concat(root, \\\"/\\\").concat(key, \\\"/\\\").concat(value);\\n      } else if (!location.pathname.includes(key)) {\\n        value = \\\"\\\".concat(key, \\\"/\\\").concat(value);\\n      }\\n\\n      var currentState = window.history.state;\\n\\n      if (currentState && currentState.value === value) {\\n        return;\\n      }\\n\\n      if (swiper.params.history.replaceState) {\\n        window.history.replaceState({\\n          value: value\\n        }, null, value);\\n      } else {\\n        window.history.pushState({\\n          value: value\\n        }, null, value);\\n      }\\n    };\\n\\n    var scrollToSlide = function scrollToSlide(speed, value, runCallbacks) {\\n      if (value) {\\n        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\\n          var _slide3 = swiper.slides.eq(i);\\n\\n          var slideHistory = slugify(_slide3.attr('data-history'));\\n\\n          if (slideHistory === value && !_slide3.hasClass(swiper.params.slideDuplicateClass)) {\\n            var _index2 = _slide3.index();\\n\\n            swiper.slideTo(_index2, speed, runCallbacks);\\n          }\\n        }\\n      } else {\\n        swiper.slideTo(0, speed, runCallbacks);\\n      }\\n    };\\n\\n    var setHistoryPopState = function setHistoryPopState() {\\n      paths = getPathValues(swiper.params.url);\\n      scrollToSlide(swiper.params.speed, swiper.paths.value, false);\\n    };\\n\\n    var init = function init() {\\n      var window = getWindow();\\n\\n      if (!swiper.params.history) {\\n        return;\\n      }\\n\\n      if (!window.history || !window.history.pushState) {\\n        swiper.params.history.enabled = false;\\n        swiper.params.hashNavigation.enabled = true;\\n        return;\\n      }\\n\\n      initialized = true;\\n      paths = getPathValues(swiper.params.url);\\n\\n      if (!paths.key && !paths.value) {\\n        return;\\n      }\\n\\n      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\\n\\n      if (!swiper.params.history.replaceState) {\\n        window.addEventListener('popstate', setHistoryPopState);\\n      }\\n    };\\n\\n    var destroy = function destroy() {\\n      var window = getWindow();\\n\\n      if (!swiper.params.history.replaceState) {\\n        window.removeEventListener('popstate', setHistoryPopState);\\n      }\\n    };\\n\\n    on('init', function () {\\n      if (swiper.params.history.enabled) {\\n        init();\\n      }\\n    });\\n    on('destroy', function () {\\n      if (swiper.params.history.enabled) {\\n        destroy();\\n      }\\n    });\\n    on('transitionEnd _freeModeNoMomentumRelease', function () {\\n      if (initialized) {\\n        setHistory(swiper.params.history.key, swiper.activeIndex);\\n      }\\n    });\\n    on('slideChange', function () {\\n      if (initialized && swiper.params.cssMode) {\\n        setHistory(swiper.params.history.key, swiper.activeIndex);\\n      }\\n    });\\n  }\\n\\n  function HashNavigation(_ref19) {\\n    var swiper = _ref19.swiper,\\n        extendParams = _ref19.extendParams,\\n        emit = _ref19.emit,\\n        on = _ref19.on;\\n    var initialized = false;\\n    var document = getDocument();\\n    var window = getWindow();\\n    extendParams({\\n      hashNavigation: {\\n        enabled: false,\\n        replaceState: false,\\n        watchState: false\\n      }\\n    });\\n\\n    var onHashChange = function onHashChange() {\\n      emit('hashChange');\\n      var newHash = document.location.hash.replace('#', '');\\n      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');\\n\\n      if (newHash !== activeSlideHash) {\\n        var newIndex = swiper.$wrapperEl.children(\\\".\\\".concat(swiper.params.slideClass, \\\"[data-hash=\\\\\\\"\\\").concat(newHash, \\\"\\\\\\\"]\\\")).index();\\n\\n        if (typeof newIndex === 'undefined') {\\n          return;\\n        }\\n\\n        swiper.slideTo(newIndex);\\n      }\\n    };\\n\\n    var setHash = function setHash() {\\n      if (!initialized || !swiper.params.hashNavigation.enabled) {\\n        return;\\n      }\\n\\n      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\\n        window.history.replaceState(null, null, \\\"#\\\".concat(swiper.slides.eq(swiper.activeIndex).attr('data-hash')) || false);\\n        emit('hashSet');\\n      } else {\\n        var _slide4 = swiper.slides.eq(swiper.activeIndex);\\n\\n        var hash = _slide4.attr('data-hash') || _slide4.attr('data-history');\\n\\n        document.location.hash = hash || '';\\n        emit('hashSet');\\n      }\\n    };\\n\\n    var init = function init() {\\n      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) {\\n        return;\\n      }\\n\\n      initialized = true;\\n      var hash = document.location.hash.replace('#', '');\\n\\n      if (hash) {\\n        var speed = 0;\\n\\n        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {\\n          var _slide5 = swiper.slides.eq(i);\\n\\n          var slideHash = _slide5.attr('data-hash') || _slide5.attr('data-history');\\n\\n          if (slideHash === hash && !_slide5.hasClass(swiper.params.slideDuplicateClass)) {\\n            var _index3 = _slide5.index();\\n\\n            swiper.slideTo(_index3, speed, swiper.params.runCallbacksOnInit, true);\\n          }\\n        }\\n      }\\n\\n      if (swiper.params.hashNavigation.watchState) {\\n        $(window).on('hashchange', onHashChange);\\n      }\\n    };\\n\\n    var destroy = function destroy() {\\n      if (swiper.params.hashNavigation.watchState) {\\n        $(window).off('hashchange', onHashChange);\\n      }\\n    };\\n\\n    on('init', function () {\\n      if (swiper.params.hashNavigation.enabled) {\\n        init();\\n      }\\n    });\\n    on('destroy', function () {\\n      if (swiper.params.hashNavigation.enabled) {\\n        destroy();\\n      }\\n    });\\n    on('transitionEnd _freeModeNoMomentumRelease', function () {\\n      if (initialized) {\\n        setHash();\\n      }\\n    });\\n    on('slideChange', function () {\\n      if (initialized && swiper.params.cssMode) {\\n        setHash();\\n      }\\n    });\\n  }\\n  /* eslint no-underscore-dangle: \\\"off\\\" */\\n\\n\\n  function Autoplay(_ref20) {\\n    var swiper = _ref20.swiper,\\n        extendParams = _ref20.extendParams,\\n        on = _ref20.on,\\n        emit = _ref20.emit;\\n    var timeout;\\n    swiper.autoplay = {\\n      running: false,\\n      paused: false\\n    };\\n    extendParams({\\n      autoplay: {\\n        enabled: false,\\n        delay: 3000,\\n        waitForTransition: true,\\n        disableOnInteraction: true,\\n        stopOnLastSlide: false,\\n        reverseDirection: false,\\n        pauseOnMouseEnter: false\\n      }\\n    });\\n\\n    function run() {\\n      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);\\n      var delay = swiper.params.autoplay.delay;\\n\\n      if ($activeSlideEl.attr('data-swiper-autoplay')) {\\n        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;\\n      }\\n\\n      clearTimeout(timeout);\\n      timeout = nextTick(function () {\\n        var autoplayResult;\\n\\n        if (swiper.params.autoplay.reverseDirection) {\\n          if (swiper.params.loop) {\\n            swiper.loopFix();\\n            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\\n            emit('autoplay');\\n          } else if (!swiper.isBeginning) {\\n            autoplayResult = swiper.slidePrev(swiper.params.speed, true, true);\\n            emit('autoplay');\\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\\n            autoplayResult = swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);\\n            emit('autoplay');\\n          } else {\\n            stop();\\n          }\\n        } else if (swiper.params.loop) {\\n          swiper.loopFix();\\n          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\\n          emit('autoplay');\\n        } else if (!swiper.isEnd) {\\n          autoplayResult = swiper.slideNext(swiper.params.speed, true, true);\\n          emit('autoplay');\\n        } else if (!swiper.params.autoplay.stopOnLastSlide) {\\n          autoplayResult = swiper.slideTo(0, swiper.params.speed, true, true);\\n          emit('autoplay');\\n        } else {\\n          stop();\\n        }\\n\\n        if (swiper.params.cssMode && swiper.autoplay.running) {\\n          run();\\n        } else if (autoplayResult === false) {\\n          run();\\n        }\\n      }, delay);\\n    }\\n\\n    function start() {\\n      if (typeof timeout !== 'undefined') {\\n        return false;\\n      }\\n\\n      if (swiper.autoplay.running) {\\n        return false;\\n      }\\n\\n      swiper.autoplay.running = true;\\n      emit('autoplayStart');\\n      run();\\n      return true;\\n    }\\n\\n    function stop() {\\n      if (!swiper.autoplay.running) {\\n        return false;\\n      }\\n\\n      if (typeof timeout === 'undefined') {\\n        return false;\\n      }\\n\\n      if (timeout) {\\n        clearTimeout(timeout);\\n        timeout = undefined;\\n      }\\n\\n      swiper.autoplay.running = false;\\n      emit('autoplayStop');\\n      return true;\\n    }\\n\\n    function pause(speed) {\\n      if (!swiper.autoplay.running) {\\n        return;\\n      }\\n\\n      if (swiper.autoplay.paused) {\\n        return;\\n      }\\n\\n      if (timeout) {\\n        clearTimeout(timeout);\\n      }\\n\\n      swiper.autoplay.paused = true;\\n\\n      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {\\n        swiper.autoplay.paused = false;\\n        run();\\n      } else {\\n        ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\\n          swiper.$wrapperEl[0].addEventListener(event, onTransitionEnd);\\n        });\\n      }\\n    }\\n\\n    function onVisibilityChange() {\\n      var document = getDocument();\\n\\n      if (document.visibilityState === 'hidden' && swiper.autoplay.running) {\\n        pause();\\n      }\\n\\n      if (document.visibilityState === 'visible' && swiper.autoplay.paused) {\\n        run();\\n        swiper.autoplay.paused = false;\\n      }\\n    }\\n\\n    function onTransitionEnd(e) {\\n      if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {\\n        return;\\n      }\\n\\n      if (e.target !== swiper.$wrapperEl[0]) {\\n        return;\\n      }\\n\\n      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\\n        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\\n      });\\n      swiper.autoplay.paused = false;\\n\\n      if (!swiper.autoplay.running) {\\n        stop();\\n      } else {\\n        run();\\n      }\\n    }\\n\\n    function onMouseEnter() {\\n      if (swiper.params.autoplay.disableOnInteraction) {\\n        stop();\\n      } else {\\n        pause();\\n      }\\n\\n      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\\n        swiper.$wrapperEl[0].removeEventListener(event, onTransitionEnd);\\n      });\\n    }\\n\\n    function onMouseLeave() {\\n      if (swiper.params.autoplay.disableOnInteraction) {\\n        return;\\n      }\\n\\n      swiper.autoplay.paused = false;\\n      run();\\n    }\\n\\n    function attachMouseEvents() {\\n      if (swiper.params.autoplay.pauseOnMouseEnter) {\\n        swiper.$el.on('mouseenter', onMouseEnter);\\n        swiper.$el.on('mouseleave', onMouseLeave);\\n      }\\n    }\\n\\n    function detachMouseEvents() {\\n      swiper.$el.off('mouseenter', onMouseEnter);\\n      swiper.$el.off('mouseleave', onMouseLeave);\\n    }\\n\\n    on('init', function () {\\n      if (swiper.params.autoplay.enabled) {\\n        start();\\n\\n        var _document3 = getDocument();\\n\\n        _document3.addEventListener('visibilitychange', onVisibilityChange);\\n\\n        attachMouseEvents();\\n      }\\n    });\\n    on('beforeTransitionStart', function (_s, speed, internal) {\\n      if (swiper.autoplay.running) {\\n        if (internal || !swiper.params.autoplay.disableOnInteraction) {\\n          swiper.autoplay.pause(speed);\\n        } else {\\n          stop();\\n        }\\n      }\\n    });\\n    on('sliderFirstMove', function () {\\n      if (swiper.autoplay.running) {\\n        if (swiper.params.autoplay.disableOnInteraction) {\\n          stop();\\n        } else {\\n          pause();\\n        }\\n      }\\n    });\\n    on('touchEnd', function () {\\n      if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {\\n        run();\\n      }\\n    });\\n    on('destroy', function () {\\n      detachMouseEvents();\\n\\n      if (swiper.autoplay.running) {\\n        stop();\\n      }\\n\\n      var document = getDocument();\\n      document.removeEventListener('visibilitychange', onVisibilityChange);\\n    });\\n    Object.assign(swiper.autoplay, {\\n      pause: pause,\\n      run: run,\\n      start: start,\\n      stop: stop\\n    });\\n  }\\n\\n  function Thumb(_ref21) {\\n    var swiper = _ref21.swiper,\\n        extendParams = _ref21.extendParams,\\n        on = _ref21.on;\\n    extendParams({\\n      thumbs: {\\n        swiper: null,\\n        multipleActiveThumbs: true,\\n        autoScrollOffset: 0,\\n        slideThumbActiveClass: 'swiper-slide-thumb-active',\\n        thumbsContainerClass: 'swiper-thumbs'\\n      }\\n    });\\n    var initialized = false;\\n    var swiperCreated = false;\\n    swiper.thumbs = {\\n      swiper: null\\n    };\\n\\n    function onThumbClick() {\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n\\n      if (!thumbsSwiper) {\\n        return;\\n      }\\n\\n      var clickedIndex = thumbsSwiper.clickedIndex;\\n      var clickedSlide = thumbsSwiper.clickedSlide;\\n\\n      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) {\\n        return;\\n      }\\n\\n      if (typeof clickedIndex === 'undefined' || clickedIndex === null) {\\n        return;\\n      }\\n\\n      var slideToIndex;\\n\\n      if (thumbsSwiper.params.loop) {\\n        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);\\n      } else {\\n        slideToIndex = clickedIndex;\\n      }\\n\\n      if (swiper.params.loop) {\\n        var currentIndex = swiper.activeIndex;\\n\\n        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {\\n          swiper.loopFix(); // eslint-disable-next-line\\n\\n          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;\\n          currentIndex = swiper.activeIndex;\\n        }\\n\\n        var prevIndex = swiper.slides.eq(currentIndex).prevAll(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(slideToIndex, \\\"\\\\\\\"]\\\")).eq(0).index();\\n        var nextIndex = swiper.slides.eq(currentIndex).nextAll(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(slideToIndex, \\\"\\\\\\\"]\\\")).eq(0).index();\\n\\n        if (typeof prevIndex === 'undefined') {\\n          slideToIndex = nextIndex;\\n        } else if (typeof nextIndex === 'undefined') {\\n          slideToIndex = prevIndex;\\n        } else if (nextIndex - currentIndex < currentIndex - prevIndex) {\\n          slideToIndex = nextIndex;\\n        } else {\\n          slideToIndex = prevIndex;\\n        }\\n      }\\n\\n      swiper.slideTo(slideToIndex);\\n    }\\n\\n    function init() {\\n      var thumbsParams = swiper.params.thumbs;\\n\\n      if (initialized) {\\n        return false;\\n      }\\n\\n      initialized = true;\\n      var SwiperClass = swiper.constructor;\\n\\n      if (thumbsParams.swiper instanceof SwiperClass) {\\n        swiper.thumbs.swiper = thumbsParams.swiper;\\n        Object.assign(swiper.thumbs.swiper.originalParams, {\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false\\n        });\\n        Object.assign(swiper.thumbs.swiper.params, {\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false\\n        });\\n      } else if (isObject(thumbsParams.swiper)) {\\n        var thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\\n        Object.assign(thumbsSwiperParams, {\\n          watchSlidesProgress: true,\\n          slideToClickedSlide: false\\n        });\\n        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\\n        swiperCreated = true;\\n      }\\n\\n      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);\\n      swiper.thumbs.swiper.on('tap', onThumbClick);\\n      return true;\\n    }\\n\\n    function update(initial) {\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n\\n      if (!thumbsSwiper) {\\n        return;\\n      }\\n\\n      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\\n      var autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\\n      var useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\\n\\n      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\\n        var currentThumbsIndex = thumbsSwiper.activeIndex;\\n        var newThumbsIndex;\\n        var direction;\\n\\n        if (thumbsSwiper.params.loop) {\\n          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {\\n            thumbsSwiper.loopFix(); // eslint-disable-next-line\\n\\n            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;\\n            currentThumbsIndex = thumbsSwiper.activeIndex;\\n          } // Find actual thumbs index to slide to\\n\\n\\n          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(swiper.realIndex, \\\"\\\\\\\"]\\\")).eq(0).index();\\n          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(swiper.realIndex, \\\"\\\\\\\"]\\\")).eq(0).index();\\n\\n          if (typeof prevThumbsIndex === 'undefined') {\\n            newThumbsIndex = nextThumbsIndex;\\n          } else if (typeof nextThumbsIndex === 'undefined') {\\n            newThumbsIndex = prevThumbsIndex;\\n          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {\\n            newThumbsIndex = thumbsSwiper.params.slidesPerGroup > 1 ? nextThumbsIndex : currentThumbsIndex;\\n          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {\\n            newThumbsIndex = nextThumbsIndex;\\n          } else {\\n            newThumbsIndex = prevThumbsIndex;\\n          }\\n\\n          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\\n        } else {\\n          newThumbsIndex = swiper.realIndex;\\n          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\\n        }\\n\\n        if (useOffset) {\\n          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\\n        }\\n\\n        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\\n          if (thumbsSwiper.params.centeredSlides) {\\n            if (newThumbsIndex > currentThumbsIndex) {\\n              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\\n            } else {\\n              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\\n            }\\n          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) {}\\n\\n          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\\n        }\\n      } // Activate thumbs\\n\\n\\n      var thumbsToActivate = 1;\\n      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\\n\\n      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\\n        thumbsToActivate = swiper.params.slidesPerView;\\n      }\\n\\n      if (!swiper.params.thumbs.multipleActiveThumbs) {\\n        thumbsToActivate = 1;\\n      }\\n\\n      thumbsToActivate = Math.floor(thumbsToActivate);\\n      thumbsSwiper.slides.removeClass(thumbActiveClass);\\n\\n      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\\n        for (var i = 0; i < thumbsToActivate; i += 1) {\\n          thumbsSwiper.$wrapperEl.children(\\\"[data-swiper-slide-index=\\\\\\\"\\\".concat(swiper.realIndex + i, \\\"\\\\\\\"]\\\")).addClass(thumbActiveClass);\\n        }\\n      } else {\\n        for (var _i11 = 0; _i11 < thumbsToActivate; _i11 += 1) {\\n          thumbsSwiper.slides.eq(swiper.realIndex + _i11).addClass(thumbActiveClass);\\n        }\\n      }\\n    }\\n\\n    on('beforeInit', function () {\\n      var thumbs = swiper.params.thumbs;\\n\\n      if (!thumbs || !thumbs.swiper) {\\n        return;\\n      }\\n\\n      init();\\n      update(true);\\n    });\\n    on('slideChange update resize observerUpdate', function () {\\n      if (!swiper.thumbs.swiper) {\\n        return;\\n      }\\n\\n      update();\\n    });\\n    on('setTransition', function (_s, duration) {\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n\\n      if (!thumbsSwiper) {\\n        return;\\n      }\\n\\n      thumbsSwiper.setTransition(duration);\\n    });\\n    on('beforeDestroy', function () {\\n      var thumbsSwiper = swiper.thumbs.swiper;\\n\\n      if (!thumbsSwiper) {\\n        return;\\n      }\\n\\n      if (swiperCreated && thumbsSwiper) {\\n        thumbsSwiper.destroy();\\n      }\\n    });\\n    Object.assign(swiper.thumbs, {\\n      init: init,\\n      update: update\\n    });\\n  }\\n\\n  function freeMode(_ref22) {\\n    var swiper = _ref22.swiper,\\n        extendParams = _ref22.extendParams,\\n        emit = _ref22.emit,\\n        once = _ref22.once;\\n    extendParams({\\n      freeMode: {\\n        enabled: false,\\n        momentum: true,\\n        momentumRatio: 1,\\n        momentumBounce: true,\\n        momentumBounceRatio: 1,\\n        momentumVelocityRatio: 1,\\n        sticky: false,\\n        minimumVelocity: 0.02\\n      }\\n    });\\n\\n    function onTouchMove() {\\n      var data = swiper.touchEventsData,\\n          touches = swiper.touches; // Velocity\\n\\n      if (data.velocities.length === 0) {\\n        data.velocities.push({\\n          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\\n          time: data.touchStartTime\\n        });\\n      }\\n\\n      data.velocities.push({\\n        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\\n        time: now()\\n      });\\n    }\\n\\n    function onTouchEnd(_ref23) {\\n      var currentPos = _ref23.currentPos;\\n      var params = swiper.params,\\n          $wrapperEl = swiper.$wrapperEl,\\n          rtl = swiper.rtlTranslate,\\n          snapGrid = swiper.snapGrid,\\n          data = swiper.touchEventsData; // Time diff\\n\\n      var touchEndTime = now();\\n      var timeDiff = touchEndTime - data.touchStartTime;\\n\\n      if (currentPos < -swiper.minTranslate()) {\\n        swiper.slideTo(swiper.activeIndex);\\n        return;\\n      }\\n\\n      if (currentPos > -swiper.maxTranslate()) {\\n        if (swiper.slides.length < snapGrid.length) {\\n          swiper.slideTo(snapGrid.length - 1);\\n        } else {\\n          swiper.slideTo(swiper.slides.length - 1);\\n        }\\n\\n        return;\\n      }\\n\\n      if (params.freeMode.momentum) {\\n        if (data.velocities.length > 1) {\\n          var lastMoveEvent = data.velocities.pop();\\n          var velocityEvent = data.velocities.pop();\\n          var distance = lastMoveEvent.position - velocityEvent.position;\\n          var time = lastMoveEvent.time - velocityEvent.time;\\n          swiper.velocity = distance / time;\\n          swiper.velocity /= 2;\\n\\n          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\\n            swiper.velocity = 0;\\n          } // this implies that the user stopped moving a finger then released.\\n          // There would be no events with distance zero, so the last event is stale.\\n\\n\\n          if (time > 150 || now() - lastMoveEvent.time > 300) {\\n            swiper.velocity = 0;\\n          }\\n        } else {\\n          swiper.velocity = 0;\\n        }\\n\\n        swiper.velocity *= params.freeMode.momentumVelocityRatio;\\n        data.velocities.length = 0;\\n        var momentumDuration = 1000 * params.freeMode.momentumRatio;\\n        var momentumDistance = swiper.velocity * momentumDuration;\\n        var newPosition = swiper.translate + momentumDistance;\\n\\n        if (rtl) {\\n          newPosition = -newPosition;\\n        }\\n\\n        var doBounce = false;\\n        var afterBouncePosition;\\n        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\\n        var needsLoopFix;\\n\\n        if (newPosition < swiper.maxTranslate()) {\\n          if (params.freeMode.momentumBounce) {\\n            if (newPosition + swiper.maxTranslate() < -bounceAmount) {\\n              newPosition = swiper.maxTranslate() - bounceAmount;\\n            }\\n\\n            afterBouncePosition = swiper.maxTranslate();\\n            doBounce = true;\\n            data.allowMomentumBounce = true;\\n          } else {\\n            newPosition = swiper.maxTranslate();\\n          }\\n\\n          if (params.loop && params.centeredSlides) {\\n            needsLoopFix = true;\\n          }\\n        } else if (newPosition > swiper.minTranslate()) {\\n          if (params.freeMode.momentumBounce) {\\n            if (newPosition - swiper.minTranslate() > bounceAmount) {\\n              newPosition = swiper.minTranslate() + bounceAmount;\\n            }\\n\\n            afterBouncePosition = swiper.minTranslate();\\n            doBounce = true;\\n            data.allowMomentumBounce = true;\\n          } else {\\n            newPosition = swiper.minTranslate();\\n          }\\n\\n          if (params.loop && params.centeredSlides) {\\n            needsLoopFix = true;\\n          }\\n        } else if (params.freeMode.sticky) {\\n          var nextSlide;\\n\\n          for (var j = 0; j < snapGrid.length; j += 1) {\\n            if (snapGrid[j] > -newPosition) {\\n              nextSlide = j;\\n              break;\\n            }\\n          }\\n\\n          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\\n            newPosition = snapGrid[nextSlide];\\n          } else {\\n            newPosition = snapGrid[nextSlide - 1];\\n          }\\n\\n          newPosition = -newPosition;\\n        }\\n\\n        if (needsLoopFix) {\\n          once('transitionEnd', function () {\\n            swiper.loopFix();\\n          });\\n        } // Fix duration\\n\\n\\n        if (swiper.velocity !== 0) {\\n          if (rtl) {\\n            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\\n          } else {\\n            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\\n          }\\n\\n          if (params.freeMode.sticky) {\\n            // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\\n            // event, then durations can be 20+ seconds to slide one (or zero!) slides.\\n            // It's easy to see this when simulating touch with mouse events. To fix this,\\n            // limit single-slide swipes to the default slide duration. This also has the\\n            // nice side effect of matching slide speed if the user stopped moving before\\n            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\\n            // For faster swipes, also apply limits (albeit higher ones).\\n            var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\\n            var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\\n\\n            if (moveDistance < currentSlideSize) {\\n              momentumDuration = params.speed;\\n            } else if (moveDistance < 2 * currentSlideSize) {\\n              momentumDuration = params.speed * 1.5;\\n            } else {\\n              momentumDuration = params.speed * 2.5;\\n            }\\n          }\\n        } else if (params.freeMode.sticky) {\\n          swiper.slideToClosest();\\n          return;\\n        }\\n\\n        if (params.freeMode.momentumBounce && doBounce) {\\n          swiper.updateProgress(afterBouncePosition);\\n          swiper.setTransition(momentumDuration);\\n          swiper.setTranslate(newPosition);\\n          swiper.transitionStart(true, swiper.swipeDirection);\\n          swiper.animating = true;\\n          $wrapperEl.transitionEnd(function () {\\n            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {\\n              return;\\n            }\\n\\n            emit('momentumBounce');\\n            swiper.setTransition(params.speed);\\n            setTimeout(function () {\\n              swiper.setTranslate(afterBouncePosition);\\n              $wrapperEl.transitionEnd(function () {\\n                if (!swiper || swiper.destroyed) {\\n                  return;\\n                }\\n\\n                swiper.transitionEnd();\\n              });\\n            }, 0);\\n          });\\n        } else if (swiper.velocity) {\\n          emit('_freeModeNoMomentumRelease');\\n          swiper.updateProgress(newPosition);\\n          swiper.setTransition(momentumDuration);\\n          swiper.setTranslate(newPosition);\\n          swiper.transitionStart(true, swiper.swipeDirection);\\n\\n          if (!swiper.animating) {\\n            swiper.animating = true;\\n            $wrapperEl.transitionEnd(function () {\\n              if (!swiper || swiper.destroyed) {\\n                return;\\n              }\\n\\n              swiper.transitionEnd();\\n            });\\n          }\\n        } else {\\n          swiper.updateProgress(newPosition);\\n        }\\n\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      } else if (params.freeMode.sticky) {\\n        swiper.slideToClosest();\\n        return;\\n      } else if (params.freeMode) {\\n        emit('_freeModeNoMomentumRelease');\\n      }\\n\\n      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\\n        swiper.updateProgress();\\n        swiper.updateActiveIndex();\\n        swiper.updateSlidesClasses();\\n      }\\n    }\\n\\n    Object.assign(swiper, {\\n      freeMode: {\\n        onTouchMove: onTouchMove,\\n        onTouchEnd: onTouchEnd\\n      }\\n    });\\n  }\\n\\n  function Grid(_ref24) {\\n    var swiper = _ref24.swiper,\\n        extendParams = _ref24.extendParams;\\n    extendParams({\\n      grid: {\\n        rows: 1,\\n        fill: 'column'\\n      }\\n    });\\n    var slidesNumberEvenToRows;\\n    var slidesPerRow;\\n    var numFullColumns;\\n\\n    var initSlides = function initSlides(slidesLength) {\\n      var slidesPerView = swiper.params.slidesPerView;\\n      var _swiper$params$grid = swiper.params.grid,\\n          rows = _swiper$params$grid.rows,\\n          fill = _swiper$params$grid.fill;\\n      slidesPerRow = slidesNumberEvenToRows / rows;\\n      numFullColumns = Math.floor(slidesLength / rows);\\n\\n      if (Math.floor(slidesLength / rows) === slidesLength / rows) {\\n        slidesNumberEvenToRows = slidesLength;\\n      } else {\\n        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\\n      }\\n\\n      if (slidesPerView !== 'auto' && fill === 'row') {\\n        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\\n      }\\n    };\\n\\n    var updateSlide = function updateSlide(i, slide, slidesLength, getDirectionLabel) {\\n      var _swiper$params3 = swiper.params,\\n          slidesPerGroup = _swiper$params3.slidesPerGroup,\\n          spaceBetween = _swiper$params3.spaceBetween;\\n      var _swiper$params$grid2 = swiper.params.grid,\\n          rows = _swiper$params$grid2.rows,\\n          fill = _swiper$params$grid2.fill; // Set slides order\\n\\n      var newSlideOrderIndex;\\n      var column;\\n      var row;\\n\\n      if (fill === 'row' && slidesPerGroup > 1) {\\n        var groupIndex = Math.floor(i / (slidesPerGroup * rows));\\n        var slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\\n        var columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\\n        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\\n        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\\n        slide.css({\\n          '-webkit-order': newSlideOrderIndex,\\n          order: newSlideOrderIndex\\n        });\\n      } else if (fill === 'column') {\\n        column = Math.floor(i / rows);\\n        row = i - column * rows;\\n\\n        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\\n          row += 1;\\n\\n          if (row >= rows) {\\n            row = 0;\\n            column += 1;\\n          }\\n        }\\n      } else {\\n        row = Math.floor(i / slidesPerRow);\\n        column = i - row * slidesPerRow;\\n      }\\n\\n      slide.css(getDirectionLabel('margin-top'), row !== 0 ? spaceBetween && \\\"\\\".concat(spaceBetween, \\\"px\\\") : '');\\n    };\\n\\n    var updateWrapperSize = function updateWrapperSize(slideSize, snapGrid, getDirectionLabel) {\\n      var _swiper$params4 = swiper.params,\\n          spaceBetween = _swiper$params4.spaceBetween,\\n          centeredSlides = _swiper$params4.centeredSlides,\\n          roundLengths = _swiper$params4.roundLengths;\\n      var rows = swiper.params.grid.rows;\\n      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\\n      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\\n      swiper.$wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), \\\"\\\".concat(swiper.virtualSize + spaceBetween, \\\"px\\\")));\\n\\n      if (centeredSlides) {\\n        snapGrid.splice(0, snapGrid.length);\\n        var newSlidesGrid = [];\\n\\n        for (var i = 0; i < snapGrid.length; i += 1) {\\n          var slidesGridItem = snapGrid[i];\\n\\n          if (roundLengths) {\\n            slidesGridItem = Math.floor(slidesGridItem);\\n          }\\n\\n          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) {\\n            newSlidesGrid.push(slidesGridItem);\\n          }\\n        }\\n\\n        snapGrid.push.apply(snapGrid, newSlidesGrid);\\n      }\\n    };\\n\\n    swiper.grid = {\\n      initSlides: initSlides,\\n      updateSlide: updateSlide,\\n      updateWrapperSize: updateWrapperSize\\n    };\\n  }\\n\\n  function appendSlide(slides) {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl,\\n        params = swiper.params;\\n\\n    if (params.loop) {\\n      swiper.loopDestroy();\\n    }\\n\\n    if (_typeof(slides) === 'object' && 'length' in slides) {\\n      for (var i = 0; i < slides.length; i += 1) {\\n        if (slides[i]) {\\n          $wrapperEl.append(slides[i]);\\n        }\\n      }\\n    } else {\\n      $wrapperEl.append(slides);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n\\n    if (!params.observer) {\\n      swiper.update();\\n    }\\n  }\\n\\n  function prependSlide(slides) {\\n    var swiper = this;\\n    var params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl,\\n        activeIndex = swiper.activeIndex;\\n\\n    if (params.loop) {\\n      swiper.loopDestroy();\\n    }\\n\\n    var newActiveIndex = activeIndex + 1;\\n\\n    if (_typeof(slides) === 'object' && 'length' in slides) {\\n      for (var i = 0; i < slides.length; i += 1) {\\n        if (slides[i]) {\\n          $wrapperEl.prepend(slides[i]);\\n        }\\n      }\\n\\n      newActiveIndex = activeIndex + slides.length;\\n    } else {\\n      $wrapperEl.prepend(slides);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n\\n    if (!params.observer) {\\n      swiper.update();\\n    }\\n\\n    swiper.slideTo(newActiveIndex, 0, false);\\n  }\\n\\n  function addSlide(index, slides) {\\n    var swiper = this;\\n    var $wrapperEl = swiper.$wrapperEl,\\n        params = swiper.params,\\n        activeIndex = swiper.activeIndex;\\n    var activeIndexBuffer = activeIndex;\\n\\n    if (params.loop) {\\n      activeIndexBuffer -= swiper.loopedSlides;\\n      swiper.loopDestroy();\\n      swiper.slides = $wrapperEl.children(\\\".\\\".concat(params.slideClass));\\n    }\\n\\n    var baseLength = swiper.slides.length;\\n\\n    if (index <= 0) {\\n      swiper.prependSlide(slides);\\n      return;\\n    }\\n\\n    if (index >= baseLength) {\\n      swiper.appendSlide(slides);\\n      return;\\n    }\\n\\n    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\\n    var slidesBuffer = [];\\n\\n    for (var i = baseLength - 1; i >= index; i -= 1) {\\n      var currentSlide = swiper.slides.eq(i);\\n      currentSlide.remove();\\n      slidesBuffer.unshift(currentSlide);\\n    }\\n\\n    if (_typeof(slides) === 'object' && 'length' in slides) {\\n      for (var _i12 = 0; _i12 < slides.length; _i12 += 1) {\\n        if (slides[_i12]) {\\n          $wrapperEl.append(slides[_i12]);\\n        }\\n      }\\n\\n      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\\n    } else {\\n      $wrapperEl.append(slides);\\n    }\\n\\n    for (var _i13 = 0; _i13 < slidesBuffer.length; _i13 += 1) {\\n      $wrapperEl.append(slidesBuffer[_i13]);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n\\n    if (!params.observer) {\\n      swiper.update();\\n    }\\n\\n    if (params.loop) {\\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\\n    } else {\\n      swiper.slideTo(newActiveIndex, 0, false);\\n    }\\n  }\\n\\n  function removeSlide(slidesIndexes) {\\n    var swiper = this;\\n    var params = swiper.params,\\n        $wrapperEl = swiper.$wrapperEl,\\n        activeIndex = swiper.activeIndex;\\n    var activeIndexBuffer = activeIndex;\\n\\n    if (params.loop) {\\n      activeIndexBuffer -= swiper.loopedSlides;\\n      swiper.loopDestroy();\\n      swiper.slides = $wrapperEl.children(\\\".\\\".concat(params.slideClass));\\n    }\\n\\n    var newActiveIndex = activeIndexBuffer;\\n    var indexToRemove;\\n\\n    if (_typeof(slidesIndexes) === 'object' && 'length' in slidesIndexes) {\\n      for (var i = 0; i < slidesIndexes.length; i += 1) {\\n        indexToRemove = slidesIndexes[i];\\n\\n        if (swiper.slides[indexToRemove]) {\\n          swiper.slides.eq(indexToRemove).remove();\\n        }\\n\\n        if (indexToRemove < newActiveIndex) {\\n          newActiveIndex -= 1;\\n        }\\n      }\\n\\n      newActiveIndex = Math.max(newActiveIndex, 0);\\n    } else {\\n      indexToRemove = slidesIndexes;\\n\\n      if (swiper.slides[indexToRemove]) {\\n        swiper.slides.eq(indexToRemove).remove();\\n      }\\n\\n      if (indexToRemove < newActiveIndex) {\\n        newActiveIndex -= 1;\\n      }\\n\\n      newActiveIndex = Math.max(newActiveIndex, 0);\\n    }\\n\\n    if (params.loop) {\\n      swiper.loopCreate();\\n    }\\n\\n    if (!params.observer) {\\n      swiper.update();\\n    }\\n\\n    if (params.loop) {\\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\\n    } else {\\n      swiper.slideTo(newActiveIndex, 0, false);\\n    }\\n  }\\n\\n  function removeAllSlides() {\\n    var swiper = this;\\n    var slidesIndexes = [];\\n\\n    for (var i = 0; i < swiper.slides.length; i += 1) {\\n      slidesIndexes.push(i);\\n    }\\n\\n    swiper.removeSlide(slidesIndexes);\\n  }\\n\\n  function Manipulation(_ref25) {\\n    var swiper = _ref25.swiper;\\n    Object.assign(swiper, {\\n      appendSlide: appendSlide.bind(swiper),\\n      prependSlide: prependSlide.bind(swiper),\\n      addSlide: addSlide.bind(swiper),\\n      removeSlide: removeSlide.bind(swiper),\\n      removeAllSlides: removeAllSlides.bind(swiper)\\n    });\\n  }\\n\\n  function effectInit(params) {\\n    var effect = params.effect,\\n        swiper = params.swiper,\\n        on = params.on,\\n        setTranslate = params.setTranslate,\\n        setTransition = params.setTransition,\\n        overwriteParams = params.overwriteParams,\\n        perspective = params.perspective;\\n    on('beforeInit', function () {\\n      if (swiper.params.effect !== effect) {\\n        return;\\n      }\\n\\n      swiper.classNames.push(\\\"\\\".concat(swiper.params.containerModifierClass).concat(effect));\\n\\n      if (perspective && perspective()) {\\n        swiper.classNames.push(\\\"\\\".concat(swiper.params.containerModifierClass, \\\"3d\\\"));\\n      }\\n\\n      var overwriteParamsResult = overwriteParams ? overwriteParams() : {};\\n      Object.assign(swiper.params, overwriteParamsResult);\\n      Object.assign(swiper.originalParams, overwriteParamsResult);\\n    });\\n    on('setTranslate', function () {\\n      if (swiper.params.effect !== effect) {\\n        return;\\n      }\\n\\n      setTranslate();\\n    });\\n    on('setTransition', function (_s, duration) {\\n      if (swiper.params.effect !== effect) {\\n        return;\\n      }\\n\\n      setTransition(duration);\\n    });\\n  }\\n\\n  function effectTarget(effectParams, $slideEl) {\\n    if (effectParams.transformEl) {\\n      return $slideEl.find(effectParams.transformEl).css({\\n        'backface-visibility': 'hidden',\\n        '-webkit-backface-visibility': 'hidden'\\n      });\\n    }\\n\\n    return $slideEl;\\n  }\\n\\n  function effectVirtualTransitionEnd(_ref26) {\\n    var swiper = _ref26.swiper,\\n        duration = _ref26.duration,\\n        transformEl = _ref26.transformEl,\\n        allSlides = _ref26.allSlides;\\n    var slides = swiper.slides,\\n        activeIndex = swiper.activeIndex,\\n        $wrapperEl = swiper.$wrapperEl;\\n\\n    if (swiper.params.virtualTranslate && duration !== 0) {\\n      var eventTriggered = false;\\n      var $transitionEndTarget;\\n\\n      if (allSlides) {\\n        $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\\n      } else {\\n        $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);\\n      }\\n\\n      $transitionEndTarget.transitionEnd(function () {\\n        if (eventTriggered) {\\n          return;\\n        }\\n\\n        if (!swiper || swiper.destroyed) {\\n          return;\\n        }\\n\\n        eventTriggered = true;\\n        swiper.animating = false;\\n        var triggerEvents = ['webkitTransitionEnd', 'transitionend'];\\n\\n        for (var i = 0; i < triggerEvents.length; i += 1) {\\n          $wrapperEl.trigger(triggerEvents[i]);\\n        }\\n      });\\n    }\\n  }\\n\\n  function EffectFade(_ref27) {\\n    var swiper = _ref27.swiper,\\n        extendParams = _ref27.extendParams,\\n        on = _ref27.on;\\n    extendParams({\\n      fadeEffect: {\\n        crossFade: false,\\n        transformEl: null\\n      }\\n    });\\n\\n    var setTranslate = function setTranslate() {\\n      var slides = swiper.slides;\\n      var params = swiper.params.fadeEffect;\\n\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = swiper.slides.eq(i);\\n        var _offset = $slideEl[0].swiperSlideOffset;\\n        var tx = -_offset;\\n\\n        if (!swiper.params.virtualTranslate) {\\n          tx -= swiper.translate;\\n        }\\n\\n        var ty = 0;\\n\\n        if (!swiper.isHorizontal()) {\\n          ty = tx;\\n          tx = 0;\\n        }\\n\\n        var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\\n        var $targetEl = effectTarget(params, $slideEl);\\n        $targetEl.css({\\n          opacity: slideOpacity\\n        }).transform(\\\"translate3d(\\\".concat(tx, \\\"px, \\\").concat(ty, \\\"px, 0px)\\\"));\\n      }\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var transformEl = swiper.params.fadeEffect.transformEl;\\n      var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\\n      $transitionElements.transition(duration);\\n      effectVirtualTransitionEnd({\\n        swiper: swiper,\\n        duration: duration,\\n        transformEl: transformEl,\\n        allSlides: true\\n      });\\n    };\\n\\n    effectInit({\\n      effect: 'fade',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          slidesPerView: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          spaceBetween: 0,\\n          virtualTranslate: !swiper.params.cssMode\\n        };\\n      }\\n    });\\n  }\\n\\n  function EffectCube(_ref28) {\\n    var swiper = _ref28.swiper,\\n        extendParams = _ref28.extendParams,\\n        on = _ref28.on;\\n    extendParams({\\n      cubeEffect: {\\n        slideShadows: true,\\n        shadow: true,\\n        shadowOffset: 20,\\n        shadowScale: 0.94\\n      }\\n    });\\n\\n    var setTranslate = function setTranslate() {\\n      var $el = swiper.$el,\\n          $wrapperEl = swiper.$wrapperEl,\\n          slides = swiper.slides,\\n          swiperWidth = swiper.width,\\n          swiperHeight = swiper.height,\\n          rtl = swiper.rtlTranslate,\\n          swiperSize = swiper.size,\\n          browser = swiper.browser;\\n      var params = swiper.params.cubeEffect;\\n      var isHorizontal = swiper.isHorizontal();\\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\\n      var wrapperRotate = 0;\\n      var $cubeShadowEl;\\n\\n      if (params.shadow) {\\n        if (isHorizontal) {\\n          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');\\n\\n          if ($cubeShadowEl.length === 0) {\\n            $cubeShadowEl = $('<div class=\\\"swiper-cube-shadow\\\"></div>');\\n            $wrapperEl.append($cubeShadowEl);\\n          }\\n\\n          $cubeShadowEl.css({\\n            height: \\\"\\\".concat(swiperWidth, \\\"px\\\")\\n          });\\n        } else {\\n          $cubeShadowEl = $el.find('.swiper-cube-shadow');\\n\\n          if ($cubeShadowEl.length === 0) {\\n            $cubeShadowEl = $('<div class=\\\"swiper-cube-shadow\\\"></div>');\\n            $el.append($cubeShadowEl);\\n          }\\n        }\\n      }\\n\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var slideIndex = i;\\n\\n        if (isVirtual) {\\n          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);\\n        }\\n\\n        var slideAngle = slideIndex * 90;\\n        var round = Math.floor(slideAngle / 360);\\n\\n        if (rtl) {\\n          slideAngle = -slideAngle;\\n          round = Math.floor(-slideAngle / 360);\\n        }\\n\\n        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\\n        var tx = 0;\\n        var ty = 0;\\n        var tz = 0;\\n\\n        if (slideIndex % 4 === 0) {\\n          tx = -round * 4 * swiperSize;\\n          tz = 0;\\n        } else if ((slideIndex - 1) % 4 === 0) {\\n          tx = 0;\\n          tz = -round * 4 * swiperSize;\\n        } else if ((slideIndex - 2) % 4 === 0) {\\n          tx = swiperSize + round * 4 * swiperSize;\\n          tz = swiperSize;\\n        } else if ((slideIndex - 3) % 4 === 0) {\\n          tx = -swiperSize;\\n          tz = 3 * swiperSize + swiperSize * 4 * round;\\n        }\\n\\n        if (rtl) {\\n          tx = -tx;\\n        }\\n\\n        if (!isHorizontal) {\\n          ty = tx;\\n          tx = 0;\\n        }\\n\\n        var _transform = \\\"rotateX(\\\".concat(isHorizontal ? 0 : -slideAngle, \\\"deg) rotateY(\\\").concat(isHorizontal ? slideAngle : 0, \\\"deg) translate3d(\\\").concat(tx, \\\"px, \\\").concat(ty, \\\"px, \\\").concat(tz, \\\"px)\\\");\\n\\n        if (progress <= 1 && progress > -1) {\\n          wrapperRotate = slideIndex * 90 + progress * 90;\\n\\n          if (rtl) {\\n            wrapperRotate = -slideIndex * 90 - progress * 90;\\n          }\\n        }\\n\\n        $slideEl.transform(_transform);\\n\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n\\n          if (shadowBefore.length === 0) {\\n            shadowBefore = $(\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\".concat(isHorizontal ? 'left' : 'top', \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowBefore);\\n          }\\n\\n          if (shadowAfter.length === 0) {\\n            shadowAfter = $(\\\"<div class=\\\\\\\"swiper-slide-shadow-\\\".concat(isHorizontal ? 'right' : 'bottom', \\\"\\\\\\\"></div>\\\"));\\n            $slideEl.append(shadowAfter);\\n          }\\n\\n          if (shadowBefore.length) {\\n            shadowBefore[0].style.opacity = Math.max(-progress, 0);\\n          }\\n\\n          if (shadowAfter.length) {\\n            shadowAfter[0].style.opacity = Math.max(progress, 0);\\n          }\\n        }\\n      }\\n\\n      $wrapperEl.css({\\n        '-webkit-transform-origin': \\\"50% 50% -\\\".concat(swiperSize / 2, \\\"px\\\"),\\n        'transform-origin': \\\"50% 50% -\\\".concat(swiperSize / 2, \\\"px\\\")\\n      });\\n\\n      if (params.shadow) {\\n        if (isHorizontal) {\\n          $cubeShadowEl.transform(\\\"translate3d(0px, \\\".concat(swiperWidth / 2 + params.shadowOffset, \\\"px, \\\").concat(-swiperWidth / 2, \\\"px) rotateX(90deg) rotateZ(0deg) scale(\\\").concat(params.shadowScale, \\\")\\\"));\\n        } else {\\n          var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\\n          var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\\n          var scale1 = params.shadowScale;\\n          var scale2 = params.shadowScale / multiplier;\\n          var _offset2 = params.shadowOffset;\\n          $cubeShadowEl.transform(\\\"scale3d(\\\".concat(scale1, \\\", 1, \\\").concat(scale2, \\\") translate3d(0px, \\\").concat(swiperHeight / 2 + _offset2, \\\"px, \\\").concat(-swiperHeight / 2 / scale2, \\\"px) rotateX(-90deg)\\\"));\\n        }\\n      }\\n\\n      var zFactor = browser.isSafari || browser.isWebView ? -swiperSize / 2 : 0;\\n      $wrapperEl.transform(\\\"translate3d(0px,0,\\\".concat(zFactor, \\\"px) rotateX(\\\").concat(swiper.isHorizontal() ? 0 : wrapperRotate, \\\"deg) rotateY(\\\").concat(swiper.isHorizontal() ? -wrapperRotate : 0, \\\"deg)\\\"));\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var $el = swiper.$el,\\n          slides = swiper.slides;\\n      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);\\n\\n      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\\n        $el.find('.swiper-cube-shadow').transition(duration);\\n      }\\n    };\\n\\n    effectInit({\\n      effect: 'cube',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      perspective: function perspective() {\\n        return true;\\n      },\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          slidesPerView: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          resistanceRatio: 0,\\n          spaceBetween: 0,\\n          centeredSlides: false,\\n          virtualTranslate: true\\n        };\\n      }\\n    });\\n  }\\n\\n  function createShadow(params, $slideEl, side) {\\n    var shadowClass = \\\"swiper-slide-shadow\\\".concat(side ? \\\"-\\\".concat(side) : '');\\n    var $shadowContainer = params.transformEl ? $slideEl.find(params.transformEl) : $slideEl;\\n    var $shadowEl = $shadowContainer.children(\\\".\\\".concat(shadowClass));\\n\\n    if (!$shadowEl.length) {\\n      $shadowEl = $(\\\"<div class=\\\\\\\"swiper-slide-shadow\\\".concat(side ? \\\"-\\\".concat(side) : '', \\\"\\\\\\\"></div>\\\"));\\n      $shadowContainer.append($shadowEl);\\n    }\\n\\n    return $shadowEl;\\n  }\\n\\n  function EffectFlip(_ref29) {\\n    var swiper = _ref29.swiper,\\n        extendParams = _ref29.extendParams,\\n        on = _ref29.on;\\n    extendParams({\\n      flipEffect: {\\n        slideShadows: true,\\n        limitRotation: true,\\n        transformEl: null\\n      }\\n    });\\n\\n    var setTranslate = function setTranslate() {\\n      var slides = swiper.slides,\\n          rtl = swiper.rtlTranslate;\\n      var params = swiper.params.flipEffect;\\n\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var progress = $slideEl[0].progress;\\n\\n        if (swiper.params.flipEffect.limitRotation) {\\n          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);\\n        }\\n\\n        var _offset3 = $slideEl[0].swiperSlideOffset;\\n        var rotate = -180 * progress;\\n        var rotateY = rotate;\\n        var rotateX = 0;\\n        var tx = swiper.params.cssMode ? -_offset3 - swiper.translate : -_offset3;\\n        var ty = 0;\\n\\n        if (!swiper.isHorizontal()) {\\n          ty = tx;\\n          tx = 0;\\n          rotateX = -rotateY;\\n          rotateY = 0;\\n        } else if (rtl) {\\n          rotateY = -rotateY;\\n        }\\n\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\\n\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n\\n          if (shadowBefore.length === 0) {\\n            shadowBefore = createShadow(params, $slideEl, swiper.isHorizontal() ? 'left' : 'top');\\n          }\\n\\n          if (shadowAfter.length === 0) {\\n            shadowAfter = createShadow(params, $slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\\n          }\\n\\n          if (shadowBefore.length) {\\n            shadowBefore[0].style.opacity = Math.max(-progress, 0);\\n          }\\n\\n          if (shadowAfter.length) {\\n            shadowAfter[0].style.opacity = Math.max(progress, 0);\\n          }\\n        }\\n\\n        var _transform2 = \\\"translate3d(\\\".concat(tx, \\\"px, \\\").concat(ty, \\\"px, 0px) rotateX(\\\").concat(rotateX, \\\"deg) rotateY(\\\").concat(rotateY, \\\"deg)\\\");\\n\\n        var $targetEl = effectTarget(params, $slideEl);\\n        $targetEl.transform(_transform2);\\n      }\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var transformEl = swiper.params.flipEffect.transformEl;\\n      var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\\n      $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);\\n      effectVirtualTransitionEnd({\\n        swiper: swiper,\\n        duration: duration,\\n        transformEl: transformEl\\n      });\\n    };\\n\\n    effectInit({\\n      effect: 'flip',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      perspective: function perspective() {\\n        return true;\\n      },\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          slidesPerView: 1,\\n          slidesPerGroup: 1,\\n          watchSlidesProgress: true,\\n          spaceBetween: 0,\\n          virtualTranslate: !swiper.params.cssMode\\n        };\\n      }\\n    });\\n  }\\n\\n  function EffectCoverflow(_ref30) {\\n    var swiper = _ref30.swiper,\\n        extendParams = _ref30.extendParams,\\n        on = _ref30.on;\\n    extendParams({\\n      coverflowEffect: {\\n        rotate: 50,\\n        stretch: 0,\\n        depth: 100,\\n        scale: 1,\\n        modifier: 1,\\n        slideShadows: true,\\n        transformEl: null\\n      }\\n    });\\n\\n    var setTranslate = function setTranslate() {\\n      var swiperWidth = swiper.width,\\n          swiperHeight = swiper.height,\\n          slides = swiper.slides,\\n          slidesSizesGrid = swiper.slidesSizesGrid;\\n      var params = swiper.params.coverflowEffect;\\n      var isHorizontal = swiper.isHorizontal();\\n      var transform = swiper.translate;\\n      var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\\n      var rotate = isHorizontal ? params.rotate : -params.rotate;\\n      var translate = params.depth; // Each slide offset from center\\n\\n      for (var i = 0, length = slides.length; i < length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var slideSize = slidesSizesGrid[i];\\n        var slideOffset = $slideEl[0].swiperSlideOffset;\\n        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;\\n        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\\n        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0\\n\\n        var translateZ = -translate * Math.abs(offsetMultiplier);\\n        var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders\\n\\n        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\\n          stretch = parseFloat(params.stretch) / 100 * slideSize;\\n        }\\n\\n        var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\\n        var translateX = isHorizontal ? stretch * offsetMultiplier : 0;\\n        var scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier); // Fix for ultra small values\\n\\n        if (Math.abs(translateX) < 0.001) {\\n          translateX = 0;\\n        }\\n\\n        if (Math.abs(translateY) < 0.001) {\\n          translateY = 0;\\n        }\\n\\n        if (Math.abs(translateZ) < 0.001) {\\n          translateZ = 0;\\n        }\\n\\n        if (Math.abs(rotateY) < 0.001) {\\n          rotateY = 0;\\n        }\\n\\n        if (Math.abs(rotateX) < 0.001) {\\n          rotateX = 0;\\n        }\\n\\n        if (Math.abs(scale) < 0.001) {\\n          scale = 0;\\n        }\\n\\n        var slideTransform = \\\"translate3d(\\\".concat(translateX, \\\"px,\\\").concat(translateY, \\\"px,\\\").concat(translateZ, \\\"px)  rotateX(\\\").concat(rotateX, \\\"deg) rotateY(\\\").concat(rotateY, \\\"deg) scale(\\\").concat(scale, \\\")\\\");\\n        var $targetEl = effectTarget(params, $slideEl);\\n        $targetEl.transform(slideTransform);\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\\n\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');\\n          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');\\n\\n          if ($shadowBeforeEl.length === 0) {\\n            $shadowBeforeEl = createShadow(params, $slideEl, isHorizontal ? 'left' : 'top');\\n          }\\n\\n          if ($shadowAfterEl.length === 0) {\\n            $shadowAfterEl = createShadow(params, $slideEl, isHorizontal ? 'right' : 'bottom');\\n          }\\n\\n          if ($shadowBeforeEl.length) {\\n            $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\\n          }\\n\\n          if ($shadowAfterEl.length) {\\n            $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\\n          }\\n        }\\n      }\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var transformEl = swiper.params.coverflowEffect.transformEl;\\n      var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\\n      $transitionElements.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);\\n    };\\n\\n    effectInit({\\n      effect: 'coverflow',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      perspective: function perspective() {\\n        return true;\\n      },\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          watchSlidesProgress: true\\n        };\\n      }\\n    });\\n  }\\n\\n  function EffectCreative(_ref31) {\\n    var swiper = _ref31.swiper,\\n        extendParams = _ref31.extendParams,\\n        on = _ref31.on;\\n    extendParams({\\n      creativeEffect: {\\n        transformEl: null,\\n        limitProgress: 1,\\n        shadowPerProgress: false,\\n        progressMultiplier: 1,\\n        perspective: true,\\n        prev: {\\n          translate: [0, 0, 0],\\n          rotate: [0, 0, 0],\\n          opacity: 1,\\n          scale: 1\\n        },\\n        next: {\\n          translate: [0, 0, 0],\\n          rotate: [0, 0, 0],\\n          opacity: 1,\\n          scale: 1\\n        }\\n      }\\n    });\\n\\n    var getTranslateValue = function getTranslateValue(value) {\\n      if (typeof value === 'string') {\\n        return value;\\n      }\\n\\n      return \\\"\\\".concat(value, \\\"px\\\");\\n    };\\n\\n    var setTranslate = function setTranslate() {\\n      var slides = swiper.slides,\\n          $wrapperEl = swiper.$wrapperEl,\\n          slidesSizesGrid = swiper.slidesSizesGrid;\\n      var params = swiper.params.creativeEffect;\\n      var multiplier = params.progressMultiplier;\\n      var isCenteredSlides = swiper.params.centeredSlides;\\n\\n      if (isCenteredSlides) {\\n        var margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\\n        $wrapperEl.transform(\\\"translateX(calc(50% - \\\".concat(margin, \\\"px))\\\"));\\n      }\\n\\n      var _loop = function _loop(i) {\\n        var $slideEl = slides.eq(i);\\n        var slideProgress = $slideEl[0].progress;\\n        var progress = Math.min(Math.max($slideEl[0].progress, -params.limitProgress), params.limitProgress);\\n        var originalProgress = progress;\\n\\n        if (!isCenteredSlides) {\\n          originalProgress = Math.min(Math.max($slideEl[0].originalProgress, -params.limitProgress), params.limitProgress);\\n        }\\n\\n        var offset = $slideEl[0].swiperSlideOffset;\\n        var t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\\n        var r = [0, 0, 0];\\n        var custom = false;\\n\\n        if (!swiper.isHorizontal()) {\\n          t[1] = t[0];\\n          t[0] = 0;\\n        }\\n\\n        var data = {\\n          translate: [0, 0, 0],\\n          rotate: [0, 0, 0],\\n          scale: 1,\\n          opacity: 1\\n        };\\n\\n        if (progress < 0) {\\n          data = params.next;\\n          custom = true;\\n        } else if (progress > 0) {\\n          data = params.prev;\\n          custom = true;\\n        } // set translate\\n\\n\\n        t.forEach(function (value, index) {\\n          t[index] = \\\"calc(\\\".concat(value, \\\"px + (\\\").concat(getTranslateValue(data.translate[index]), \\\" * \\\").concat(Math.abs(progress * multiplier), \\\"))\\\");\\n        }); // set rotates\\n\\n        r.forEach(function (value, index) {\\n          r[index] = data.rotate[index] * Math.abs(progress * multiplier);\\n        });\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\\n        var translateString = t.join(', ');\\n        var rotateString = \\\"rotateX(\\\".concat(r[0], \\\"deg) rotateY(\\\").concat(r[1], \\\"deg) rotateZ(\\\").concat(r[2], \\\"deg)\\\");\\n        var scaleString = originalProgress < 0 ? \\\"scale(\\\".concat(1 + (1 - data.scale) * originalProgress * multiplier, \\\")\\\") : \\\"scale(\\\".concat(1 - (1 - data.scale) * originalProgress * multiplier, \\\")\\\");\\n        var opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\\n        var transform = \\\"translate3d(\\\".concat(translateString, \\\") \\\").concat(rotateString, \\\" \\\").concat(scaleString); // Set shadows\\n\\n        if (custom && data.shadow || !custom) {\\n          var $shadowEl = $slideEl.children('.swiper-slide-shadow');\\n\\n          if ($shadowEl.length === 0 && data.shadow) {\\n            $shadowEl = createShadow(params, $slideEl);\\n          }\\n\\n          if ($shadowEl.length) {\\n            var shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\\n            $shadowEl[0].style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\\n          }\\n        }\\n\\n        var $targetEl = effectTarget(params, $slideEl);\\n        $targetEl.transform(transform).css({\\n          opacity: opacityString\\n        });\\n\\n        if (data.origin) {\\n          $targetEl.css('transform-origin', data.origin);\\n        }\\n      };\\n\\n      for (var i = 0; i < slides.length; i += 1) {\\n        _loop(i);\\n      }\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var transformEl = swiper.params.creativeEffect.transformEl;\\n      var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\\n      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\\n      effectVirtualTransitionEnd({\\n        swiper: swiper,\\n        duration: duration,\\n        transformEl: transformEl,\\n        allSlides: true\\n      });\\n    };\\n\\n    effectInit({\\n      effect: 'creative',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      perspective: function perspective() {\\n        return swiper.params.creativeEffect.perspective;\\n      },\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          watchSlidesProgress: true,\\n          virtualTranslate: !swiper.params.cssMode\\n        };\\n      }\\n    });\\n  }\\n\\n  function EffectCards(_ref32) {\\n    var swiper = _ref32.swiper,\\n        extendParams = _ref32.extendParams,\\n        on = _ref32.on;\\n    extendParams({\\n      cardsEffect: {\\n        slideShadows: true,\\n        transformEl: null\\n      }\\n    });\\n\\n    var setTranslate = function setTranslate() {\\n      var slides = swiper.slides,\\n          activeIndex = swiper.activeIndex;\\n      var params = swiper.params.cardsEffect;\\n      var _swiper$touchEventsDa = swiper.touchEventsData,\\n          startTranslate = _swiper$touchEventsDa.startTranslate,\\n          isTouched = _swiper$touchEventsDa.isTouched;\\n      var currentTranslate = swiper.translate;\\n\\n      for (var i = 0; i < slides.length; i += 1) {\\n        var $slideEl = slides.eq(i);\\n        var slideProgress = $slideEl[0].progress;\\n        var progress = Math.min(Math.max(slideProgress, -4), 4);\\n        var _offset4 = $slideEl[0].swiperSlideOffset;\\n\\n        if (swiper.params.centeredSlides && !swiper.params.cssMode) {\\n          swiper.$wrapperEl.transform(\\\"translateX(\\\".concat(swiper.minTranslate(), \\\"px)\\\"));\\n        }\\n\\n        if (swiper.params.centeredSlides && swiper.params.cssMode) {\\n          _offset4 -= slides[0].swiperSlideOffset;\\n        }\\n\\n        var tX = swiper.params.cssMode ? -_offset4 - swiper.translate : -_offset4;\\n        var tY = 0;\\n        var tZ = -100 * Math.abs(progress);\\n        var scale = 1;\\n        var rotate = -2 * progress;\\n        var tXAdd = 8 - Math.abs(progress) * 0.75;\\n        var isSwipeToNext = (i === activeIndex || i === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\\n        var isSwipeToPrev = (i === activeIndex || i === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\\n\\n        if (isSwipeToNext || isSwipeToPrev) {\\n          var subProgress = Math.pow(1 - Math.abs((Math.abs(progress) - 0.5) / 0.5), 0.5);\\n          rotate += -28 * progress * subProgress;\\n          scale += -0.5 * subProgress;\\n          tXAdd += 96 * subProgress;\\n          tY = \\\"\\\".concat(-25 * subProgress * Math.abs(progress), \\\"%\\\");\\n        }\\n\\n        if (progress < 0) {\\n          // next\\n          tX = \\\"calc(\\\".concat(tX, \\\"px + (\\\").concat(tXAdd * Math.abs(progress), \\\"%))\\\");\\n        } else if (progress > 0) {\\n          // prev\\n          tX = \\\"calc(\\\".concat(tX, \\\"px + (-\\\").concat(tXAdd * Math.abs(progress), \\\"%))\\\");\\n        } else {\\n          tX = \\\"\\\".concat(tX, \\\"px\\\");\\n        }\\n\\n        if (!swiper.isHorizontal()) {\\n          var prevY = tY;\\n          tY = tX;\\n          tX = prevY;\\n        }\\n\\n        var scaleString = progress < 0 ? \\\"\\\".concat(1 + (1 - scale) * progress) : \\\"\\\".concat(1 - (1 - scale) * progress);\\n\\n        var _transform3 = \\\"\\\\n      translate3d(\\\".concat(tX, \\\", \\\").concat(tY, \\\", \\\").concat(tZ, \\\"px)\\\\n      rotateZ(\\\").concat(rotate, \\\"deg)\\\\n      scale(\\\").concat(scaleString, \\\")\\\\n    \\\");\\n\\n        if (params.slideShadows) {\\n          // Set shadows\\n          var $shadowEl = $slideEl.find('.swiper-slide-shadow');\\n\\n          if ($shadowEl.length === 0) {\\n            $shadowEl = createShadow(params, $slideEl);\\n          }\\n\\n          if ($shadowEl.length) {\\n            $shadowEl[0].style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\\n          }\\n        }\\n\\n        $slideEl[0].style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\\n        var $targetEl = effectTarget(params, $slideEl);\\n        $targetEl.transform(_transform3);\\n      }\\n    };\\n\\n    var setTransition = function setTransition(duration) {\\n      var transformEl = swiper.params.cardsEffect.transformEl;\\n      var $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\\n      $transitionElements.transition(duration).find('.swiper-slide-shadow').transition(duration);\\n      effectVirtualTransitionEnd({\\n        swiper: swiper,\\n        duration: duration,\\n        transformEl: transformEl\\n      });\\n    };\\n\\n    effectInit({\\n      effect: 'cards',\\n      swiper: swiper,\\n      on: on,\\n      setTranslate: setTranslate,\\n      setTransition: setTransition,\\n      perspective: function perspective() {\\n        return true;\\n      },\\n      overwriteParams: function overwriteParams() {\\n        return {\\n          watchSlidesProgress: true,\\n          virtualTranslate: !swiper.params.cssMode\\n        };\\n      }\\n    });\\n  } // Swiper Class\\n\\n\\n  var modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Lazy, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\\n  Swiper.use(modules);\\n  return Swiper;\\n});\\n\\n//# sourceURL=webpack:///./source/js/vendor/swiper-bundle.js?\");\n\n/***/ })\n\n/******/ });"],"file":"main.js"}